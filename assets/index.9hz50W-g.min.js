import { j as T } from "./icons.PNTxq22g.min.js"; import { r as x, R as ls, a as Pt } from "./index.C7p2QPr_.min.js"; import { g as yy } from "./_commonjsHelpers.Cpj98o6Y.min.js"; import { S as Go, s as wy, a as xy, r as Sy } from "./Global.CZoLVvO7.min.js"; import { B as Oi } from "./button.D3_5ZC4C.min.js"; import { I as vi } from "./edit.B10NtA-j.min.js"; import { l as Gr, m as Cy, s as Py } from "./destroy.DH6u2IrP.min.js"; import { l as Ey, f as Ty, c as ky, a as Ry } from "./customerSlice.Cr7KRhfA.min.js"; import { c as Ly } from "./redux-toolkit.modern.BkT_WIq0.min.js"; import "./index.CF_yH-CU.min.js"; import "./index.Bb4qSo10.min.js"; import "./utils.CHtjtCvc.min.js"; import "./fetchCustomersByAdminAPI.CyCBsWMi.min.js"; function Dy(e, t) { for (var n = 0; n < t.length; n++) { const r = t[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const i in r) if (i !== "default" && !(i in e)) { const o = Object.getOwnPropertyDescriptor(r, i); o && Object.defineProperty(e, i, o.get ? o : { enumerable: !0, get: () => r[i] }) } } } return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })) } var np = { exports: {} }, st = {}, rp = { exports: {} }, ip = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(N, U) { var b = N.length; N.push(U); e: for (; 0 < b;) { var Y = b - 1 >>> 1, ne = N[Y]; if (0 < i(ne, U)) N[Y] = U, N[b] = ne, b = Y; else break e } } function n(N) { return N.length === 0 ? null : N[0] } function r(N) { if (N.length === 0) return null; var U = N[0], b = N.pop(); if (b !== U) { N[0] = b; e: for (var Y = 0, ne = N.length, Dt = ne >>> 1; Y < Dt;) { var Le = 2 * (Y + 1) - 1, vt = N[Le], be = Le + 1, en = N[be]; if (0 > i(vt, b)) be < ne && 0 > i(en, vt) ? (N[Y] = en, N[be] = b, Y = be) : (N[Y] = vt, N[Le] = b, Y = Le); else if (be < ne && 0 > i(en, b)) N[Y] = en, N[be] = b, Y = be; else break e } } return U } function i(N, U) { var b = N.sortIndex - U.sortIndex; return b !== 0 ? b : N.id - U.id } if (typeof performance == "object" && typeof performance.now == "function") { var o = performance; e.unstable_now = function () { return o.now() } } else { var s = Date, a = s.now(); e.unstable_now = function () { return s.now() - a } } var l = [], u = [], c = 1, f = null, d = 3, g = !1, v = !1, y = !1, S = typeof setTimeout == "function" ? setTimeout : null, p = typeof clearTimeout == "function" ? clearTimeout : null, h = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function m(N) { for (var U = n(u); U !== null;) { if (U.callback === null) r(u); else if (U.startTime <= N) r(u), U.sortIndex = U.expirationTime, t(l, U); else break; U = n(u) } } function P(N) { if (y = !1, m(N), !v) if (n(l) !== null) v = !0, Ce(R); else { var U = n(u); U !== null && J(P, U.startTime - N) } } function R(N, U) { v = !1, y && (y = !1, p(k), k = -1), g = !0; var b = d; try { for (m(U), f = n(l); f !== null && (!(f.expirationTime > U) || N && !W());) { var Y = f.callback; if (typeof Y == "function") { f.callback = null, d = f.priorityLevel; var ne = Y(f.expirationTime <= U); U = e.unstable_now(), typeof ne == "function" ? f.callback = ne : f === n(l) && r(l), m(U) } else r(l); f = n(l) } if (f !== null) var Dt = !0; else { var Le = n(u); Le !== null && J(P, Le.startTime - U), Dt = !1 } return Dt } finally { f = null, d = b, g = !1 } } var w = !1, D = null, k = -1, j = 5, V = -1; function W() { return !(e.unstable_now() - V < j) } function fe() { if (D !== null) { var N = e.unstable_now(); V = N; var U = !0; try { U = D(!0, N) } finally { U ? de() : (w = !1, D = null) } } else w = !1 } var de; if (typeof h == "function") de = function () { h(fe) }; else if (typeof MessageChannel < "u") { var Be = new MessageChannel, he = Be.port2; Be.port1.onmessage = fe, de = function () { he.postMessage(null) } } else de = function () { S(fe, 0) }; function Ce(N) { D = N, w || (w = !0, de()) } function J(N, U) { k = S(function () { N(e.unstable_now()) }, U) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (N) { N.callback = null }, e.unstable_continueExecution = function () { v || g || (v = !0, Ce(R)) }, e.unstable_forceFrameRate = function (N) { 0 > N || 125 < N ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : j = 0 < N ? Math.floor(1e3 / N) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return d }, e.unstable_getFirstCallbackNode = function () { return n(l) }, e.unstable_next = function (N) { switch (d) { case 1: case 2: case 3: var U = 3; break; default: U = d }var b = d; d = U; try { return N() } finally { d = b } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (N, U) { switch (N) { case 1: case 2: case 3: case 4: case 5: break; default: N = 3 }var b = d; d = N; try { return U() } finally { d = b } }, e.unstable_scheduleCallback = function (N, U, b) { var Y = e.unstable_now(); switch (typeof b == "object" && b !== null ? (b = b.delay, b = typeof b == "number" && 0 < b ? Y + b : Y) : b = Y, N) { case 1: var ne = -1; break; case 2: ne = 250; break; case 5: ne = 1073741823; break; case 4: ne = 1e4; break; default: ne = 5e3 }return ne = b + ne, N = { id: c++, callback: U, priorityLevel: N, startTime: b, expirationTime: ne, sortIndex: -1 }, b > Y ? (N.sortIndex = b, t(u, N), n(l) === null && N === n(u) && (y ? (p(k), k = -1) : y = !0, J(P, b - Y))) : (N.sortIndex = ne, t(l, N), v || g || (v = !0, Ce(R))), N }, e.unstable_shouldYield = W, e.unstable_wrapCallback = function (N) { var U = d; return function () { var b = d; d = U; try { return N.apply(this, arguments) } finally { d = b } } } })(ip); rp.exports = ip; var My = rp.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var op = x, it = My; function M(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var sp = new Set, Ii = {}; function ar(e, t) { Ir(e, t), Ir(e + "Capture", t) } function Ir(e, t) { for (Ii[e] = t, e = 0; e < t.length; e++)sp.add(t[e]) } var Yt = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), pl = Object.prototype.hasOwnProperty, Ay = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, mf = {}, gf = {}; function jy(e) { return pl.call(gf, e) ? !0 : pl.call(mf, e) ? !1 : Ay.test(e) ? gf[e] = !0 : (mf[e] = !0, !1) } function Ny(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function Vy(e, t, n, r) { if (t === null || typeof t > "u" || Ny(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function $e(e, t, n, r, i, o, s) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = s } var Ne = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { Ne[e] = new $e(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; Ne[t] = new $e(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { Ne[e] = new $e(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { Ne[e] = new $e(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { Ne[e] = new $e(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { Ne[e] = new $e(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { Ne[e] = new $e(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { Ne[e] = new $e(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { Ne[e] = new $e(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var Ru = /[\-:]([a-z])/g; function Lu(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(Ru, Lu); Ne[t] = new $e(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(Ru, Lu); Ne[t] = new $e(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(Ru, Lu); Ne[t] = new $e(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { Ne[e] = new $e(e, 1, !1, e.toLowerCase(), null, !1, !1) }); Ne.xlinkHref = new $e("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { Ne[e] = new $e(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function Du(e, t, n, r) { var i = Ne.hasOwnProperty(t) ? Ne[t] : null; (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (Vy(t, n, i, r) && (n = null), r || i === null ? jy(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var qt = op.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Ro = Symbol.for("react.element"), pr = Symbol.for("react.portal"), mr = Symbol.for("react.fragment"), Mu = Symbol.for("react.strict_mode"), ml = Symbol.for("react.profiler"), ap = Symbol.for("react.provider"), lp = Symbol.for("react.context"), Au = Symbol.for("react.forward_ref"), gl = Symbol.for("react.suspense"), vl = Symbol.for("react.suspense_list"), ju = Symbol.for("react.memo"), ln = Symbol.for("react.lazy"), up = Symbol.for("react.offscreen"), vf = Symbol.iterator; function ni(e) { return e === null || typeof e != "object" ? null : (e = vf && e[vf] || e["@@iterator"], typeof e == "function" ? e : null) } var ce = Object.assign, Pa; function yi(e) {
  if (Pa === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); Pa = t && t[1] || "" } return `
`+ Pa + e
} var Ea = !1; function Ta(e, t) {
  if (!e || Ea) return ""; Ea = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (u) { var r = u } Reflect.construct(e, [], t) } else { try { t.call() } catch (u) { r = u } e.call(t.prototype) } else { try { throw Error() } catch (u) { r = u } e() } } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (var i = u.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a];)a--; for (; 1 <= s && 0 <= a; s--, a--)if (i[s] !== o[a]) {
        if (s !== 1 || a !== 1) do if (s--, a--, 0 > a || i[s] !== o[a]) {
          var l = `
`+ i[s].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
        } while (1 <= s && 0 <= a); break
      }
    }
  } finally { Ea = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? yi(e) : ""
} function Fy(e) { switch (e.tag) { case 5: return yi(e.type); case 16: return yi("Lazy"); case 13: return yi("Suspense"); case 19: return yi("SuspenseList"); case 0: case 2: case 15: return e = Ta(e.type, !1), e; case 11: return e = Ta(e.type.render, !1), e; case 1: return e = Ta(e.type, !0), e; default: return "" } } function yl(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case mr: return "Fragment"; case pr: return "Portal"; case ml: return "Profiler"; case Mu: return "StrictMode"; case gl: return "Suspense"; case vl: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case lp: return (e.displayName || "Context") + ".Consumer"; case ap: return (e._context.displayName || "Context") + ".Provider"; case Au: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case ju: return t = e.displayName || null, t !== null ? t : yl(e.type) || "Memo"; case ln: t = e._payload, e = e._init; try { return yl(e(t)) } catch { } }return null } function _y(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return yl(t); case 8: return t === Mu ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function Tn(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function cp(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function Oy(e) { var t = cp(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, o = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (s) { r = "" + s, o.call(this, s) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (s) { r = "" + s }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Lo(e) { e._valueTracker || (e._valueTracker = Oy(e)) } function fp(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = cp(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1 } function us(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function wl(e, t) { var n = t.checked; return ce({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function yf(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = Tn(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function dp(e, t) { t = t.checked, t != null && Du(e, "checked", t, !1) } function xl(e, t) { dp(e, t); var n = Tn(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? Sl(e, t.type, n) : t.hasOwnProperty("defaultValue") && Sl(e, t.type, Tn(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function wf(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function Sl(e, t, n) { (t !== "number" || us(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var wi = Array.isArray; function jr(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + Tn(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) { e[i].selected = !0, r && (e[i].defaultSelected = !0); return } t !== null || e[i].disabled || (t = e[i]) } t !== null && (t.selected = !0) } } function Cl(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(M(91)); return ce({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function xf(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(M(92)); if (wi(n)) { if (1 < n.length) throw Error(M(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: Tn(n) } } function hp(e, t) { var n = Tn(t.value), r = Tn(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function Sf(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function pp(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Pl(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? pp(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var Do, mp = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, i) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (Do = Do || document.createElement("div"), Do.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Do.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function zi(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var Pi = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Iy = ["Webkit", "ms", "Moz", "O"]; Object.keys(Pi).forEach(function (e) { Iy.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Pi[t] = Pi[e] }) }); function gp(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Pi.hasOwnProperty(e) && Pi[e] ? ("" + t).trim() : t + "px" } function vp(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = gp(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } var zy = ce({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function El(e, t) { if (t) { if (zy[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(M(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(M(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(M(61)) } if (t.style != null && typeof t.style != "object") throw Error(M(62)) } } function Tl(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var kl = null; function Nu(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Rl = null, Nr = null, Vr = null; function Cf(e) { if (e = co(e)) { if (typeof Rl != "function") throw Error(M(280)); var t = e.stateNode; t && (t = Ks(t), Rl(e.stateNode, e.type, t)) } } function yp(e) { Nr ? Vr ? Vr.push(e) : Vr = [e] : Nr = e } function wp() { if (Nr) { var e = Nr, t = Vr; if (Vr = Nr = null, Cf(e), t) for (e = 0; e < t.length; e++)Cf(t[e]) } } function xp(e, t) { return e(t) } function Sp() { } var ka = !1; function Cp(e, t, n) { if (ka) return e(t, n); ka = !0; try { return xp(e, t, n) } finally { ka = !1, (Nr !== null || Vr !== null) && (Sp(), wp()) } } function Ui(e, t) { var n = e.stateNode; if (n === null) return null; var r = Ks(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(M(231, t, typeof n)); return n } var Ll = !1; if (Yt) try { var ri = {}; Object.defineProperty(ri, "passive", { get: function () { Ll = !0 } }), window.addEventListener("test", ri, ri), window.removeEventListener("test", ri, ri) } catch { Ll = !1 } function Uy(e, t, n, r, i, o, s, a, l) { var u = Array.prototype.slice.call(arguments, 3); try { t.apply(n, u) } catch (c) { this.onError(c) } } var Ei = !1, cs = null, fs = !1, Dl = null, By = { onError: function (e) { Ei = !0, cs = e } }; function by(e, t, n, r, i, o, s, a, l) { Ei = !1, cs = null, Uy.apply(By, arguments) } function Hy(e, t, n, r, i, o, s, a, l) { if (by.apply(this, arguments), Ei) { if (Ei) { var u = cs; Ei = !1, cs = null } else throw Error(M(198)); fs || (fs = !0, Dl = u) } } function lr(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function Pp(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Pf(e) { if (lr(e) !== e) throw Error(M(188)) } function Wy(e) { var t = e.alternate; if (!t) { if (t = lr(e), t === null) throw Error(M(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (i === null) break; var o = i.alternate; if (o === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === o.child) { for (o = i.child; o;) { if (o === n) return Pf(i), e; if (o === r) return Pf(i), t; o = o.sibling } throw Error(M(188)) } if (n.return !== r.return) n = i, r = o; else { for (var s = !1, a = i.child; a;) { if (a === n) { s = !0, n = i, r = o; break } if (a === r) { s = !0, r = i, n = o; break } a = a.sibling } if (!s) { for (a = o.child; a;) { if (a === n) { s = !0, n = o, r = i; break } if (a === r) { s = !0, r = o, n = i; break } a = a.sibling } if (!s) throw Error(M(189)) } } if (n.alternate !== r) throw Error(M(190)) } if (n.tag !== 3) throw Error(M(188)); return n.stateNode.current === n ? e : t } function Ep(e) { return e = Wy(e), e !== null ? Tp(e) : null } function Tp(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = Tp(e); if (t !== null) return t; e = e.sibling } return null } var kp = it.unstable_scheduleCallback, Ef = it.unstable_cancelCallback, $y = it.unstable_shouldYield, Ky = it.unstable_requestPaint, ye = it.unstable_now, Gy = it.unstable_getCurrentPriorityLevel, Vu = it.unstable_ImmediatePriority, Rp = it.unstable_UserBlockingPriority, ds = it.unstable_NormalPriority, Qy = it.unstable_LowPriority, Lp = it.unstable_IdlePriority, bs = null, Nt = null; function Yy(e) { if (Nt && typeof Nt.onCommitFiberRoot == "function") try { Nt.onCommitFiberRoot(bs, e, void 0, (e.current.flags & 128) === 128) } catch { } } var Et = Math.clz32 ? Math.clz32 : Jy, Xy = Math.log, Zy = Math.LN2; function Jy(e) { return e >>>= 0, e === 0 ? 32 : 31 - (Xy(e) / Zy | 0) | 0 } var Mo = 64, Ao = 4194304; function xi(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function hs(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, i = e.suspendedLanes, o = e.pingedLanes, s = n & 268435455; if (s !== 0) { var a = s & ~i; a !== 0 ? r = xi(a) : (o &= s, o !== 0 && (r = xi(o))) } else s = n & ~i, s !== 0 ? r = xi(s) : o !== 0 && (r = xi(o)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & i) && (i = r & -r, o = t & -t, i >= o || i === 16 && (o & 4194240) !== 0)) return t; if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - Et(t), i = 1 << n, r |= e[n], t &= ~i; return r } function qy(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function e0(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) { var s = 31 - Et(o), a = 1 << s, l = i[s]; l === -1 ? (!(a & n) || a & r) && (i[s] = qy(a, t)) : l <= t && (e.expiredLanes |= a), o &= ~a } } function Ml(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function Dp() { var e = Mo; return Mo <<= 1, !(Mo & 4194240) && (Mo = 64), e } function Ra(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function lo(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - Et(t), e[t] = n } function t0(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - Et(n), o = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o } } function Fu(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - Et(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var Z = 0; function Mp(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var Ap, _u, jp, Np, Vp, Al = !1, jo = [], mn = null, gn = null, vn = null, Bi = new Map, bi = new Map, fn = [], n0 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Tf(e, t) { switch (e) { case "focusin": case "focusout": mn = null; break; case "dragenter": case "dragleave": gn = null; break; case "mouseover": case "mouseout": vn = null; break; case "pointerover": case "pointerout": Bi.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": bi.delete(t.pointerId) } } function ii(e, t, n, r, i, o) { return e === null || e.nativeEvent !== o ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }, t !== null && (t = co(t), t !== null && _u(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e) } function r0(e, t, n, r, i) { switch (t) { case "focusin": return mn = ii(mn, e, t, n, r, i), !0; case "dragenter": return gn = ii(gn, e, t, n, r, i), !0; case "mouseover": return vn = ii(vn, e, t, n, r, i), !0; case "pointerover": var o = i.pointerId; return Bi.set(o, ii(Bi.get(o) || null, e, t, n, r, i)), !0; case "gotpointercapture": return o = i.pointerId, bi.set(o, ii(bi.get(o) || null, e, t, n, r, i)), !0 }return !1 } function Fp(e) { var t = Kn(e.target); if (t !== null) { var n = lr(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = Pp(n), t !== null) { e.blockedOn = t, Vp(e.priority, function () { jp(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function Qo(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = jl(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var r = new n.constructor(n.type, n); kl = r, n.target.dispatchEvent(r), kl = null } else return t = co(n), t !== null && _u(t), e.blockedOn = n, !1; t.shift() } return !0 } function kf(e, t, n) { Qo(e) && n.delete(t) } function i0() { Al = !1, mn !== null && Qo(mn) && (mn = null), gn !== null && Qo(gn) && (gn = null), vn !== null && Qo(vn) && (vn = null), Bi.forEach(kf), bi.forEach(kf) } function oi(e, t) { e.blockedOn === t && (e.blockedOn = null, Al || (Al = !0, it.unstable_scheduleCallback(it.unstable_NormalPriority, i0))) } function Hi(e) { function t(i) { return oi(i, e) } if (0 < jo.length) { oi(jo[0], e); for (var n = 1; n < jo.length; n++) { var r = jo[n]; r.blockedOn === e && (r.blockedOn = null) } } for (mn !== null && oi(mn, e), gn !== null && oi(gn, e), vn !== null && oi(vn, e), Bi.forEach(t), bi.forEach(t), n = 0; n < fn.length; n++)r = fn[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < fn.length && (n = fn[0], n.blockedOn === null);)Fp(n), n.blockedOn === null && fn.shift() } var Fr = qt.ReactCurrentBatchConfig, ps = !0; function o0(e, t, n, r) { var i = Z, o = Fr.transition; Fr.transition = null; try { Z = 1, Ou(e, t, n, r) } finally { Z = i, Fr.transition = o } } function s0(e, t, n, r) { var i = Z, o = Fr.transition; Fr.transition = null; try { Z = 4, Ou(e, t, n, r) } finally { Z = i, Fr.transition = o } } function Ou(e, t, n, r) { if (ps) { var i = jl(e, t, n, r); if (i === null) Oa(e, t, r, ms, n), Tf(e, r); else if (r0(i, e, t, n, r)) r.stopPropagation(); else if (Tf(e, r), t & 4 && -1 < n0.indexOf(e)) { for (; i !== null;) { var o = co(i); if (o !== null && Ap(o), o = jl(e, t, n, r), o === null && Oa(e, t, r, ms, n), o === i) break; i = o } i !== null && r.stopPropagation() } else Oa(e, t, r, null, n) } } var ms = null; function jl(e, t, n, r) { if (ms = null, e = Nu(r), e = Kn(e), e !== null) if (t = lr(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = Pp(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return ms = e, null } function _p(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Gy()) { case Vu: return 1; case Rp: return 4; case ds: case Qy: return 16; case Lp: return 536870912; default: return 16 }default: return 16 } } var hn = null, Iu = null, Yo = null; function Op() { if (Yo) return Yo; var e, t = Iu, n = t.length, r, i = "value" in hn ? hn.value : hn.textContent, o = i.length; for (e = 0; e < n && t[e] === i[e]; e++); var s = n - e; for (r = 1; r <= s && t[n - r] === i[o - r]; r++); return Yo = i.slice(e, 1 < r ? 1 - r : void 0) } function Xo(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function No() { return !0 } function Rf() { return !1 } function at(e) { function t(n, r, i, o, s) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = s, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(o) : o[a]); return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? No : Rf, this.isPropagationStopped = Rf, this } return ce(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = No) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = No) }, persist: function () { }, isPersistent: No }), t } var Qr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, zu = at(Qr), uo = ce({}, Qr, { view: 0, detail: 0 }), a0 = at(uo), La, Da, si, Hs = ce({}, uo, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Uu, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== si && (si && e.type === "mousemove" ? (La = e.screenX - si.screenX, Da = e.screenY - si.screenY) : Da = La = 0, si = e), La) }, movementY: function (e) { return "movementY" in e ? e.movementY : Da } }), Lf = at(Hs), l0 = ce({}, Hs, { dataTransfer: 0 }), u0 = at(l0), c0 = ce({}, uo, { relatedTarget: 0 }), Ma = at(c0), f0 = ce({}, Qr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), d0 = at(f0), h0 = ce({}, Qr, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), p0 = at(h0), m0 = ce({}, Qr, { data: 0 }), Df = at(m0), g0 = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, v0 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, y0 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function w0(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = y0[e]) ? !!t[e] : !1 } function Uu() { return w0 } var x0 = ce({}, uo, { key: function (e) { if (e.key) { var t = g0[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = Xo(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? v0[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Uu, charCode: function (e) { return e.type === "keypress" ? Xo(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? Xo(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), S0 = at(x0), C0 = ce({}, Hs, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Mf = at(C0), P0 = ce({}, uo, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Uu }), E0 = at(P0), T0 = ce({}, Qr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), k0 = at(T0), R0 = ce({}, Hs, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), L0 = at(R0), D0 = [9, 13, 27, 32], Bu = Yt && "CompositionEvent" in window, Ti = null; Yt && "documentMode" in document && (Ti = document.documentMode); var M0 = Yt && "TextEvent" in window && !Ti, Ip = Yt && (!Bu || Ti && 8 < Ti && 11 >= Ti), Af = " ", jf = !1; function zp(e, t) { switch (e) { case "keyup": return D0.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Up(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var gr = !1; function A0(e, t) { switch (e) { case "compositionend": return Up(t); case "keypress": return t.which !== 32 ? null : (jf = !0, Af); case "textInput": return e = t.data, e === Af && jf ? null : e; default: return null } } function j0(e, t) { if (gr) return e === "compositionend" || !Bu && zp(e, t) ? (e = Op(), Yo = Iu = hn = null, gr = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return Ip && t.locale !== "ko" ? null : t.data; default: return null } } var N0 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Nf(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!N0[e.type] : t === "textarea" } function Bp(e, t, n, r) { yp(r), t = gs(t, "onChange"), 0 < t.length && (n = new zu("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var ki = null, Wi = null; function V0(e) { Jp(e, 0) } function Ws(e) { var t = wr(e); if (fp(t)) return e } function F0(e, t) { if (e === "change") return t } var bp = !1; if (Yt) { var Aa; if (Yt) { var ja = "oninput" in document; if (!ja) { var Vf = document.createElement("div"); Vf.setAttribute("oninput", "return;"), ja = typeof Vf.oninput == "function" } Aa = ja } else Aa = !1; bp = Aa && (!document.documentMode || 9 < document.documentMode) } function Ff() { ki && (ki.detachEvent("onpropertychange", Hp), Wi = ki = null) } function Hp(e) { if (e.propertyName === "value" && Ws(Wi)) { var t = []; Bp(t, Wi, e, Nu(e)), Cp(V0, t) } } function _0(e, t, n) { e === "focusin" ? (Ff(), ki = t, Wi = n, ki.attachEvent("onpropertychange", Hp)) : e === "focusout" && Ff() } function O0(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return Ws(Wi) } function I0(e, t) { if (e === "click") return Ws(t) } function z0(e, t) { if (e === "input" || e === "change") return Ws(t) } function U0(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var Rt = typeof Object.is == "function" ? Object.is : U0; function $i(e, t) { if (Rt(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!pl.call(t, i) || !Rt(e[i], t[i])) return !1 } return !0 } function _f(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Of(e, t) { var n = _f(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = _f(n) } } function Wp(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? Wp(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function $p() { for (var e = window, t = us(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = us(e.document) } return t } function bu(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function B0(e) { var t = $p(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && Wp(n.ownerDocument.documentElement, n)) { if (r !== null && bu(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var i = n.textContent.length, o = Math.min(r.start, i); r = r.end === void 0 ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = Of(n, o); var s = Of(n, r); i && s && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var b0 = Yt && "documentMode" in document && 11 >= document.documentMode, vr = null, Nl = null, Ri = null, Vl = !1; function If(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Vl || vr == null || vr !== us(r) || (r = vr, "selectionStart" in r && bu(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Ri && $i(Ri, r) || (Ri = r, r = gs(Nl, "onSelect"), 0 < r.length && (t = new zu("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = vr))) } function Vo(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var yr = { animationend: Vo("Animation", "AnimationEnd"), animationiteration: Vo("Animation", "AnimationIteration"), animationstart: Vo("Animation", "AnimationStart"), transitionend: Vo("Transition", "TransitionEnd") }, Na = {}, Kp = {}; Yt && (Kp = document.createElement("div").style, "AnimationEvent" in window || (delete yr.animationend.animation, delete yr.animationiteration.animation, delete yr.animationstart.animation), "TransitionEvent" in window || delete yr.transitionend.transition); function $s(e) { if (Na[e]) return Na[e]; if (!yr[e]) return e; var t = yr[e], n; for (n in t) if (t.hasOwnProperty(n) && n in Kp) return Na[e] = t[n]; return e } var Gp = $s("animationend"), Qp = $s("animationiteration"), Yp = $s("animationstart"), Xp = $s("transitionend"), Zp = new Map, zf = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Vn(e, t) { Zp.set(e, t), ar(t, [e]) } for (var Va = 0; Va < zf.length; Va++) { var Fa = zf[Va], H0 = Fa.toLowerCase(), W0 = Fa[0].toUpperCase() + Fa.slice(1); Vn(H0, "on" + W0) } Vn(Gp, "onAnimationEnd"); Vn(Qp, "onAnimationIteration"); Vn(Yp, "onAnimationStart"); Vn("dblclick", "onDoubleClick"); Vn("focusin", "onFocus"); Vn("focusout", "onBlur"); Vn(Xp, "onTransitionEnd"); Ir("onMouseEnter", ["mouseout", "mouseover"]); Ir("onMouseLeave", ["mouseout", "mouseover"]); Ir("onPointerEnter", ["pointerout", "pointerover"]); Ir("onPointerLeave", ["pointerout", "pointerover"]); ar("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); ar("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); ar("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); ar("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); ar("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); ar("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Si = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), $0 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Si)); function Uf(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, Hy(r, t, void 0, e), e.currentTarget = null } function Jp(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var o = void 0; if (t) for (var s = r.length - 1; 0 <= s; s--) { var a = r[s], l = a.instance, u = a.currentTarget; if (a = a.listener, l !== o && i.isPropagationStopped()) break e; Uf(i, a, u), o = l } else for (s = 0; s < r.length; s++) { if (a = r[s], l = a.instance, u = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped()) break e; Uf(i, a, u), o = l } } } if (fs) throw e = Dl, fs = !1, Dl = null, e } function re(e, t) { var n = t[zl]; n === void 0 && (n = t[zl] = new Set); var r = e + "__bubble"; n.has(r) || (qp(t, e, 2, !1), n.add(r)) } function _a(e, t, n) { var r = 0; t && (r |= 4), qp(n, e, r, t) } var Fo = "_reactListening" + Math.random().toString(36).slice(2); function Ki(e) { if (!e[Fo]) { e[Fo] = !0, sp.forEach(function (n) { n !== "selectionchange" && ($0.has(n) || _a(n, !1, e), _a(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[Fo] || (t[Fo] = !0, _a("selectionchange", !1, t)) } } function qp(e, t, n, r) { switch (_p(t)) { case 1: var i = o0; break; case 4: i = s0; break; default: i = Ou }n = i.bind(null, t, n, e), i = void 0, !Ll || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function Oa(e, t, n, r, i) { var o = r; if (!(t & 1) && !(t & 2) && r !== null) e: for (; ;) { if (r === null) return; var s = r.tag; if (s === 3 || s === 4) { var a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (s === 4) for (s = r.return; s !== null;) { var l = s.tag; if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return; s = s.return } for (; a !== null;) { if (s = Kn(a), s === null) return; if (l = s.tag, l === 5 || l === 6) { r = o = s; continue e } a = a.parentNode } } r = r.return } Cp(function () { var u = o, c = Nu(n), f = []; e: { var d = Zp.get(e); if (d !== void 0) { var g = zu, v = e; switch (e) { case "keypress": if (Xo(n) === 0) break e; case "keydown": case "keyup": g = S0; break; case "focusin": v = "focus", g = Ma; break; case "focusout": v = "blur", g = Ma; break; case "beforeblur": case "afterblur": g = Ma; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": g = Lf; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": g = u0; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": g = E0; break; case Gp: case Qp: case Yp: g = d0; break; case Xp: g = k0; break; case "scroll": g = a0; break; case "wheel": g = L0; break; case "copy": case "cut": case "paste": g = p0; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": g = Mf }var y = (t & 4) !== 0, S = !y && e === "scroll", p = y ? d !== null ? d + "Capture" : null : d; y = []; for (var h = u, m; h !== null;) { m = h; var P = m.stateNode; if (m.tag === 5 && P !== null && (m = P, p !== null && (P = Ui(h, p), P != null && y.push(Gi(h, P, m)))), S) break; h = h.return } 0 < y.length && (d = new g(d, v, null, n, c), f.push({ event: d, listeners: y })) } } if (!(t & 7)) { e: { if (d = e === "mouseover" || e === "pointerover", g = e === "mouseout" || e === "pointerout", d && n !== kl && (v = n.relatedTarget || n.fromElement) && (Kn(v) || v[Xt])) break e; if ((g || d) && (d = c.window === c ? c : (d = c.ownerDocument) ? d.defaultView || d.parentWindow : window, g ? (v = n.relatedTarget || n.toElement, g = u, v = v ? Kn(v) : null, v !== null && (S = lr(v), v !== S || v.tag !== 5 && v.tag !== 6) && (v = null)) : (g = null, v = u), g !== v)) { if (y = Lf, P = "onMouseLeave", p = "onMouseEnter", h = "mouse", (e === "pointerout" || e === "pointerover") && (y = Mf, P = "onPointerLeave", p = "onPointerEnter", h = "pointer"), S = g == null ? d : wr(g), m = v == null ? d : wr(v), d = new y(P, h + "leave", g, n, c), d.target = S, d.relatedTarget = m, P = null, Kn(c) === u && (y = new y(p, h + "enter", v, n, c), y.target = m, y.relatedTarget = S, P = y), S = P, g && v) t: { for (y = g, p = v, h = 0, m = y; m; m = hr(m))h++; for (m = 0, P = p; P; P = hr(P))m++; for (; 0 < h - m;)y = hr(y), h--; for (; 0 < m - h;)p = hr(p), m--; for (; h--;) { if (y === p || p !== null && y === p.alternate) break t; y = hr(y), p = hr(p) } y = null } else y = null; g !== null && Bf(f, d, g, y, !1), v !== null && S !== null && Bf(f, S, v, y, !0) } } e: { if (d = u ? wr(u) : window, g = d.nodeName && d.nodeName.toLowerCase(), g === "select" || g === "input" && d.type === "file") var R = F0; else if (Nf(d)) if (bp) R = z0; else { R = O0; var w = _0 } else (g = d.nodeName) && g.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (R = I0); if (R && (R = R(e, u))) { Bp(f, R, n, c); break e } w && w(e, d, u), e === "focusout" && (w = d._wrapperState) && w.controlled && d.type === "number" && Sl(d, "number", d.value) } switch (w = u ? wr(u) : window, e) { case "focusin": (Nf(w) || w.contentEditable === "true") && (vr = w, Nl = u, Ri = null); break; case "focusout": Ri = Nl = vr = null; break; case "mousedown": Vl = !0; break; case "contextmenu": case "mouseup": case "dragend": Vl = !1, If(f, n, c); break; case "selectionchange": if (b0) break; case "keydown": case "keyup": If(f, n, c) }var D; if (Bu) e: { switch (e) { case "compositionstart": var k = "onCompositionStart"; break e; case "compositionend": k = "onCompositionEnd"; break e; case "compositionupdate": k = "onCompositionUpdate"; break e }k = void 0 } else gr ? zp(e, n) && (k = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (k = "onCompositionStart"); k && (Ip && n.locale !== "ko" && (gr || k !== "onCompositionStart" ? k === "onCompositionEnd" && gr && (D = Op()) : (hn = c, Iu = "value" in hn ? hn.value : hn.textContent, gr = !0)), w = gs(u, k), 0 < w.length && (k = new Df(k, e, null, n, c), f.push({ event: k, listeners: w }), D ? k.data = D : (D = Up(n), D !== null && (k.data = D)))), (D = M0 ? A0(e, n) : j0(e, n)) && (u = gs(u, "onBeforeInput"), 0 < u.length && (c = new Df("onBeforeInput", "beforeinput", null, n, c), f.push({ event: c, listeners: u }), c.data = D)) } Jp(f, t) }) } function Gi(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function gs(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var i = e, o = i.stateNode; i.tag === 5 && o !== null && (i = o, o = Ui(e, n), o != null && r.unshift(Gi(e, o, i)), o = Ui(e, t), o != null && r.push(Gi(e, o, i))), e = e.return } return r } function hr(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Bf(e, t, n, r, i) { for (var o = t._reactName, s = []; n !== null && n !== r;) { var a = n, l = a.alternate, u = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && u !== null && (a = u, i ? (l = Ui(n, o), l != null && s.unshift(Gi(n, l, a))) : i || (l = Ui(n, o), l != null && s.push(Gi(n, l, a)))), n = n.return } s.length !== 0 && e.push({ event: t, listeners: s }) } var K0 = /\r\n?/g, G0 = /\u0000|\uFFFD/g; function bf(e) {
  return (typeof e == "string" ? e : "" + e).replace(K0, `
`).replace(G0, "")
} function _o(e, t, n) { if (t = bf(t), bf(e) !== t && n) throw Error(M(425)) } function vs() { } var Fl = null, _l = null; function Ol(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var Il = typeof setTimeout == "function" ? setTimeout : void 0, Q0 = typeof clearTimeout == "function" ? clearTimeout : void 0, Hf = typeof Promise == "function" ? Promise : void 0, Y0 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function (e) { return Hf.resolve(null).then(e).catch(X0) } : Il; function X0(e) { setTimeout(function () { throw e }) } function Ia(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { e.removeChild(i), Hi(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); Hi(t) } function yn(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function Wf(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var Yr = Math.random().toString(36).slice(2), jt = "__reactFiber$" + Yr, Qi = "__reactProps$" + Yr, Xt = "__reactContainer$" + Yr, zl = "__reactEvents$" + Yr, Z0 = "__reactListeners$" + Yr, J0 = "__reactHandles$" + Yr; function Kn(e) { var t = e[jt]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[Xt] || n[jt]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Wf(e); e !== null;) { if (n = e[jt]) return n; e = Wf(e) } return t } e = n, n = e.parentNode } return null } function co(e) { return e = e[jt] || e[Xt], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function wr(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(M(33)) } function Ks(e) { return e[Qi] || null } var Ul = [], xr = -1; function Fn(e) { return { current: e } } function ie(e) { 0 > xr || (e.current = Ul[xr], Ul[xr] = null, xr--) } function te(e, t) { xr++, Ul[xr] = e.current, e.current = t } var kn = {}, Ue = Fn(kn), Ye = Fn(!1), tr = kn; function zr(e, t) { var n = e.type.contextTypes; if (!n) return kn; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, o; for (o in n) i[o] = t[o]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i } function Xe(e) { return e = e.childContextTypes, e != null } function ys() { ie(Ye), ie(Ue) } function $f(e, t, n) { if (Ue.current !== kn) throw Error(M(168)); te(Ue, t), te(Ye, n) } function em(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in t)) throw Error(M(108, _y(e) || "Unknown", i)); return ce({}, n, r) } function ws(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || kn, tr = Ue.current, te(Ue, e), te(Ye, Ye.current), !0 } function Kf(e, t, n) { var r = e.stateNode; if (!r) throw Error(M(169)); n ? (e = em(e, t, tr), r.__reactInternalMemoizedMergedChildContext = e, ie(Ye), ie(Ue), te(Ue, e)) : ie(Ye), te(Ye, n) } var Bt = null, Gs = !1, za = !1; function tm(e) { Bt === null ? Bt = [e] : Bt.push(e) } function q0(e) { Gs = !0, tm(e) } function _n() { if (!za && Bt !== null) { za = !0; var e = 0, t = Z; try { var n = Bt; for (Z = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } Bt = null, Gs = !1 } catch (i) { throw Bt !== null && (Bt = Bt.slice(e + 1)), kp(Vu, _n), i } finally { Z = t, za = !1 } } return null } var Sr = [], Cr = 0, xs = null, Ss = 0, ft = [], dt = 0, nr = null, bt = 1, Ht = ""; function Bn(e, t) { Sr[Cr++] = Ss, Sr[Cr++] = xs, xs = e, Ss = t } function nm(e, t, n) { ft[dt++] = bt, ft[dt++] = Ht, ft[dt++] = nr, nr = e; var r = bt; e = Ht; var i = 32 - Et(r) - 1; r &= ~(1 << i), n += 1; var o = 32 - Et(t) + i; if (30 < o) { var s = i - i % 5; o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, bt = 1 << 32 - Et(t) + i | n << i | r, Ht = o + e } else bt = 1 << o | n << i | r, Ht = e } function Hu(e) { e.return !== null && (Bn(e, 1), nm(e, 1, 0)) } function Wu(e) { for (; e === xs;)xs = Sr[--Cr], Sr[Cr] = null, Ss = Sr[--Cr], Sr[Cr] = null; for (; e === nr;)nr = ft[--dt], ft[dt] = null, Ht = ft[--dt], ft[dt] = null, bt = ft[--dt], ft[dt] = null } var rt = null, tt = null, oe = !1, Ct = null; function rm(e, t) { var n = ht(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function Gf(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, rt = e, tt = yn(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, rt = e, tt = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = nr !== null ? { id: bt, overflow: Ht } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = ht(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, rt = e, tt = null, !0) : !1; default: return !1 } } function Bl(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function bl(e) { if (oe) { var t = tt; if (t) { var n = t; if (!Gf(e, t)) { if (Bl(e)) throw Error(M(418)); t = yn(n.nextSibling); var r = rt; t && Gf(e, t) ? rm(r, n) : (e.flags = e.flags & -4097 | 2, oe = !1, rt = e) } } else { if (Bl(e)) throw Error(M(418)); e.flags = e.flags & -4097 | 2, oe = !1, rt = e } } } function Qf(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; rt = e } function Oo(e) { if (e !== rt) return !1; if (!oe) return Qf(e), oe = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !Ol(e.type, e.memoizedProps)), t && (t = tt)) { if (Bl(e)) throw im(), Error(M(418)); for (; t;)rm(e, t), t = yn(t.nextSibling) } if (Qf(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(M(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { tt = yn(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } tt = null } } else tt = rt ? yn(e.stateNode.nextSibling) : null; return !0 } function im() { for (var e = tt; e;)e = yn(e.nextSibling) } function Ur() { tt = rt = null, oe = !1 } function $u(e) { Ct === null ? Ct = [e] : Ct.push(e) } var e1 = qt.ReactCurrentBatchConfig; function wt(e, t) { if (e && e.defaultProps) { t = ce({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } var Cs = Fn(null), Ps = null, Pr = null, Ku = null; function Gu() { Ku = Pr = Ps = null } function Qu(e) { var t = Cs.current; ie(Cs), e._currentValue = t } function Hl(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function _r(e, t) { Ps = e, Ku = Pr = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Qe = !0), e.firstContext = null) } function mt(e) { var t = e._currentValue; if (Ku !== e) if (e = { context: e, memoizedValue: t, next: null }, Pr === null) { if (Ps === null) throw Error(M(308)); Pr = e, Ps.dependencies = { lanes: 0, firstContext: e } } else Pr = Pr.next = e; return t } var Gn = null; function Yu(e) { Gn === null ? Gn = [e] : Gn.push(e) } function om(e, t, n, r) { var i = t.interleaved; return i === null ? (n.next = n, Yu(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Zt(e, r) } function Zt(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var un = !1; function Xu(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function sm(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function $t(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function wn(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, Q & 2) { var i = r.pending; return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Zt(e, n) } return i = r.interleaved, i === null ? (t.next = t, Yu(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Zt(e, n) } function Zo(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Fu(e, n) } } function Yf(e, t) { var n = e.updateQueue, r = e.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var i = null, o = null; if (n = n.firstBaseUpdate, n !== null) { do { var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; o === null ? i = o = s : o = o.next = s, n = n.next } while (n !== null); o === null ? i = o = t : o = o.next = t } else i = o = t; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Es(e, t, n, r) { var i = e.updateQueue; un = !1; var o = i.firstBaseUpdate, s = i.lastBaseUpdate, a = i.shared.pending; if (a !== null) { i.shared.pending = null; var l = a, u = l.next; l.next = null, s === null ? o = u : s.next = u, s = l; var c = e.alternate; c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== s && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l)) } if (o !== null) { var f = i.baseState; s = 0, c = u = l = null, a = o; do { var d = a.lane, g = a.eventTime; if ((r & d) === d) { c !== null && (c = c.next = { eventTime: g, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var v = e, y = a; switch (d = t, g = n, y.tag) { case 1: if (v = y.payload, typeof v == "function") { f = v.call(g, f, d); break e } f = v; break e; case 3: v.flags = v.flags & -65537 | 128; case 0: if (v = y.payload, d = typeof v == "function" ? v.call(g, f, d) : v, d == null) break e; f = ce({}, f, d); break e; case 2: un = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, d = i.effects, d === null ? i.effects = [a] : d.push(a)) } else g = { eventTime: g, lane: d, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, c === null ? (u = c = g, l = f) : c = c.next = g, s |= d; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; d = a, a = d.next, d.next = null, i.lastBaseUpdate = d, i.shared.pending = null } } while (!0); if (c === null && (l = f), i.baseState = l, i.firstBaseUpdate = u, i.lastBaseUpdate = c, t = i.shared.interleaved, t !== null) { i = t; do s |= i.lane, i = i.next; while (i !== t) } else o === null && (i.shared.lanes = 0); ir |= s, e.lanes = s, e.memoizedState = f } } function Xf(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(M(191, i)); i.call(r) } } } var am = new op.Component().refs; function Wl(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : ce({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var Qs = { isMounted: function (e) { return (e = e._reactInternals) ? lr(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = We(), i = Sn(e), o = $t(r, i); o.payload = t, n != null && (o.callback = n), t = wn(e, o, i), t !== null && (Tt(t, e, i, r), Zo(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = We(), i = Sn(e), o = $t(r, i); o.tag = 1, o.payload = t, n != null && (o.callback = n), t = wn(e, o, i), t !== null && (Tt(t, e, i, r), Zo(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = We(), r = Sn(e), i = $t(n, r); i.tag = 2, t != null && (i.callback = t), t = wn(e, i, r), t !== null && (Tt(t, e, r, n), Zo(t, e, r)) } }; function Zf(e, t, n, r, i, o, s) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, o, s) : t.prototype && t.prototype.isPureReactComponent ? !$i(n, r) || !$i(i, o) : !0 } function lm(e, t, n) { var r = !1, i = kn, o = t.contextType; return typeof o == "object" && o !== null ? o = mt(o) : (i = Xe(t) ? tr : Ue.current, r = t.contextTypes, o = (r = r != null) ? zr(e, i) : kn), t = new t(n, o), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Qs, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t } function Jf(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Qs.enqueueReplaceState(t, t.state, null) } function $l(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = am, Xu(e); var o = t.contextType; typeof o == "object" && o !== null ? i.context = mt(o) : (o = Xe(t) ? tr : Ue.current, i.context = zr(e, o)), i.state = e.memoizedState, o = t.getDerivedStateFromProps, typeof o == "function" && (Wl(e, t, o, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && Qs.enqueueReplaceState(i, i.state, null), Es(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308) } function ai(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(M(309)); var r = n.stateNode } if (!r) throw Error(M(147, e)); var i = r, o = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === o ? t.ref : (t = function (s) { var a = i.refs; a === am && (a = i.refs = {}), s === null ? delete a[o] : a[o] = s }, t._stringRef = o, t) } if (typeof e != "string") throw Error(M(284)); if (!n._owner) throw Error(M(290, e)) } return e } function Io(e, t) { throw e = Object.prototype.toString.call(t), Error(M(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function qf(e) { var t = e._init; return t(e._payload) } function um(e) { function t(p, h) { if (e) { var m = p.deletions; m === null ? (p.deletions = [h], p.flags |= 16) : m.push(h) } } function n(p, h) { if (!e) return null; for (; h !== null;)t(p, h), h = h.sibling; return null } function r(p, h) { for (p = new Map; h !== null;)h.key !== null ? p.set(h.key, h) : p.set(h.index, h), h = h.sibling; return p } function i(p, h) { return p = Cn(p, h), p.index = 0, p.sibling = null, p } function o(p, h, m) { return p.index = m, e ? (m = p.alternate, m !== null ? (m = m.index, m < h ? (p.flags |= 2, h) : m) : (p.flags |= 2, h)) : (p.flags |= 1048576, h) } function s(p) { return e && p.alternate === null && (p.flags |= 2), p } function a(p, h, m, P) { return h === null || h.tag !== 6 ? (h = Ka(m, p.mode, P), h.return = p, h) : (h = i(h, m), h.return = p, h) } function l(p, h, m, P) { var R = m.type; return R === mr ? c(p, h, m.props.children, P, m.key) : h !== null && (h.elementType === R || typeof R == "object" && R !== null && R.$$typeof === ln && qf(R) === h.type) ? (P = i(h, m.props), P.ref = ai(p, h, m), P.return = p, P) : (P = rs(m.type, m.key, m.props, null, p.mode, P), P.ref = ai(p, h, m), P.return = p, P) } function u(p, h, m, P) { return h === null || h.tag !== 4 || h.stateNode.containerInfo !== m.containerInfo || h.stateNode.implementation !== m.implementation ? (h = Ga(m, p.mode, P), h.return = p, h) : (h = i(h, m.children || []), h.return = p, h) } function c(p, h, m, P, R) { return h === null || h.tag !== 7 ? (h = qn(m, p.mode, P, R), h.return = p, h) : (h = i(h, m), h.return = p, h) } function f(p, h, m) { if (typeof h == "string" && h !== "" || typeof h == "number") return h = Ka("" + h, p.mode, m), h.return = p, h; if (typeof h == "object" && h !== null) { switch (h.$$typeof) { case Ro: return m = rs(h.type, h.key, h.props, null, p.mode, m), m.ref = ai(p, null, h), m.return = p, m; case pr: return h = Ga(h, p.mode, m), h.return = p, h; case ln: var P = h._init; return f(p, P(h._payload), m) }if (wi(h) || ni(h)) return h = qn(h, p.mode, m, null), h.return = p, h; Io(p, h) } return null } function d(p, h, m, P) { var R = h !== null ? h.key : null; if (typeof m == "string" && m !== "" || typeof m == "number") return R !== null ? null : a(p, h, "" + m, P); if (typeof m == "object" && m !== null) { switch (m.$$typeof) { case Ro: return m.key === R ? l(p, h, m, P) : null; case pr: return m.key === R ? u(p, h, m, P) : null; case ln: return R = m._init, d(p, h, R(m._payload), P) }if (wi(m) || ni(m)) return R !== null ? null : c(p, h, m, P, null); Io(p, m) } return null } function g(p, h, m, P, R) { if (typeof P == "string" && P !== "" || typeof P == "number") return p = p.get(m) || null, a(h, p, "" + P, R); if (typeof P == "object" && P !== null) { switch (P.$$typeof) { case Ro: return p = p.get(P.key === null ? m : P.key) || null, l(h, p, P, R); case pr: return p = p.get(P.key === null ? m : P.key) || null, u(h, p, P, R); case ln: var w = P._init; return g(p, h, m, w(P._payload), R) }if (wi(P) || ni(P)) return p = p.get(m) || null, c(h, p, P, R, null); Io(h, P) } return null } function v(p, h, m, P) { for (var R = null, w = null, D = h, k = h = 0, j = null; D !== null && k < m.length; k++) { D.index > k ? (j = D, D = null) : j = D.sibling; var V = d(p, D, m[k], P); if (V === null) { D === null && (D = j); break } e && D && V.alternate === null && t(p, D), h = o(V, h, k), w === null ? R = V : w.sibling = V, w = V, D = j } if (k === m.length) return n(p, D), oe && Bn(p, k), R; if (D === null) { for (; k < m.length; k++)D = f(p, m[k], P), D !== null && (h = o(D, h, k), w === null ? R = D : w.sibling = D, w = D); return oe && Bn(p, k), R } for (D = r(p, D); k < m.length; k++)j = g(D, p, k, m[k], P), j !== null && (e && j.alternate !== null && D.delete(j.key === null ? k : j.key), h = o(j, h, k), w === null ? R = j : w.sibling = j, w = j); return e && D.forEach(function (W) { return t(p, W) }), oe && Bn(p, k), R } function y(p, h, m, P) { var R = ni(m); if (typeof R != "function") throw Error(M(150)); if (m = R.call(m), m == null) throw Error(M(151)); for (var w = R = null, D = h, k = h = 0, j = null, V = m.next(); D !== null && !V.done; k++, V = m.next()) { D.index > k ? (j = D, D = null) : j = D.sibling; var W = d(p, D, V.value, P); if (W === null) { D === null && (D = j); break } e && D && W.alternate === null && t(p, D), h = o(W, h, k), w === null ? R = W : w.sibling = W, w = W, D = j } if (V.done) return n(p, D), oe && Bn(p, k), R; if (D === null) { for (; !V.done; k++, V = m.next())V = f(p, V.value, P), V !== null && (h = o(V, h, k), w === null ? R = V : w.sibling = V, w = V); return oe && Bn(p, k), R } for (D = r(p, D); !V.done; k++, V = m.next())V = g(D, p, k, V.value, P), V !== null && (e && V.alternate !== null && D.delete(V.key === null ? k : V.key), h = o(V, h, k), w === null ? R = V : w.sibling = V, w = V); return e && D.forEach(function (fe) { return t(p, fe) }), oe && Bn(p, k), R } function S(p, h, m, P) { if (typeof m == "object" && m !== null && m.type === mr && m.key === null && (m = m.props.children), typeof m == "object" && m !== null) { switch (m.$$typeof) { case Ro: e: { for (var R = m.key, w = h; w !== null;) { if (w.key === R) { if (R = m.type, R === mr) { if (w.tag === 7) { n(p, w.sibling), h = i(w, m.props.children), h.return = p, p = h; break e } } else if (w.elementType === R || typeof R == "object" && R !== null && R.$$typeof === ln && qf(R) === w.type) { n(p, w.sibling), h = i(w, m.props), h.ref = ai(p, w, m), h.return = p, p = h; break e } n(p, w); break } else t(p, w); w = w.sibling } m.type === mr ? (h = qn(m.props.children, p.mode, P, m.key), h.return = p, p = h) : (P = rs(m.type, m.key, m.props, null, p.mode, P), P.ref = ai(p, h, m), P.return = p, p = P) } return s(p); case pr: e: { for (w = m.key; h !== null;) { if (h.key === w) if (h.tag === 4 && h.stateNode.containerInfo === m.containerInfo && h.stateNode.implementation === m.implementation) { n(p, h.sibling), h = i(h, m.children || []), h.return = p, p = h; break e } else { n(p, h); break } else t(p, h); h = h.sibling } h = Ga(m, p.mode, P), h.return = p, p = h } return s(p); case ln: return w = m._init, S(p, h, w(m._payload), P) }if (wi(m)) return v(p, h, m, P); if (ni(m)) return y(p, h, m, P); Io(p, m) } return typeof m == "string" && m !== "" || typeof m == "number" ? (m = "" + m, h !== null && h.tag === 6 ? (n(p, h.sibling), h = i(h, m), h.return = p, p = h) : (n(p, h), h = Ka(m, p.mode, P), h.return = p, p = h), s(p)) : n(p, h) } return S } var Br = um(!0), cm = um(!1), fo = {}, Vt = Fn(fo), Yi = Fn(fo), Xi = Fn(fo); function Qn(e) { if (e === fo) throw Error(M(174)); return e } function Zu(e, t) { switch (te(Xi, t), te(Yi, e), te(Vt, fo), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Pl(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Pl(t, e) }ie(Vt), te(Vt, t) } function br() { ie(Vt), ie(Yi), ie(Xi) } function fm(e) { Qn(Xi.current); var t = Qn(Vt.current), n = Pl(t, e.type); t !== n && (te(Yi, e), te(Vt, n)) } function Ju(e) { Yi.current === e && (ie(Vt), ie(Yi)) } var ae = Fn(0); function Ts(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var Ua = []; function qu() { for (var e = 0; e < Ua.length; e++)Ua[e]._workInProgressVersionPrimary = null; Ua.length = 0 } var Jo = qt.ReactCurrentDispatcher, Ba = qt.ReactCurrentBatchConfig, rr = 0, ue = null, xe = null, Te = null, ks = !1, Li = !1, Zi = 0, t1 = 0; function Ve() { throw Error(M(321)) } function ec(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!Rt(e[n], t[n])) return !1; return !0 } function tc(e, t, n, r, i, o) { if (rr = o, ue = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Jo.current = e === null || e.memoizedState === null ? o1 : s1, e = n(r, i), Li) { o = 0; do { if (Li = !1, Zi = 0, 25 <= o) throw Error(M(301)); o += 1, Te = xe = null, t.updateQueue = null, Jo.current = a1, e = n(r, i) } while (Li) } if (Jo.current = Rs, t = xe !== null && xe.next !== null, rr = 0, Te = xe = ue = null, ks = !1, t) throw Error(M(300)); return e } function nc() { var e = Zi !== 0; return Zi = 0, e } function At() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Te === null ? ue.memoizedState = Te = e : Te = Te.next = e, Te } function gt() { if (xe === null) { var e = ue.alternate; e = e !== null ? e.memoizedState : null } else e = xe.next; var t = Te === null ? ue.memoizedState : Te.next; if (t !== null) Te = t, xe = e; else { if (e === null) throw Error(M(310)); xe = e, e = { memoizedState: xe.memoizedState, baseState: xe.baseState, baseQueue: xe.baseQueue, queue: xe.queue, next: null }, Te === null ? ue.memoizedState = Te = e : Te = Te.next = e } return Te } function Ji(e, t) { return typeof t == "function" ? t(e) : t } function ba(e) { var t = gt(), n = t.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = e; var r = xe, i = r.baseQueue, o = n.pending; if (o !== null) { if (i !== null) { var s = i.next; i.next = o.next, o.next = s } r.baseQueue = i = o, n.pending = null } if (i !== null) { o = i.next, r = r.baseState; var a = s = null, l = null, u = o; do { var c = u.lane; if ((rr & c) === c) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var f = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (a = l = f, s = r) : l = l.next = f, ue.lanes |= c, ir |= c } u = u.next } while (u !== null && u !== o); l === null ? s = r : l.next = a, Rt(r, t.memoizedState) || (Qe = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = l, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { i = e; do o = i.lane, ue.lanes |= o, ir |= o, i = i.next; while (i !== e) } else i === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Ha(e) { var t = gt(), n = t.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, o = t.memoizedState; if (i !== null) { n.pending = null; var s = i = i.next; do o = e(o, s.action), s = s.next; while (s !== i); Rt(o, t.memoizedState) || (Qe = !0), t.memoizedState = o, t.baseQueue === null && (t.baseState = o), n.lastRenderedState = o } return [o, r] } function dm() { } function hm(e, t) { var n = ue, r = gt(), i = t(), o = !Rt(r.memoizedState, i); if (o && (r.memoizedState = i, Qe = !0), r = r.queue, rc(gm.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || Te !== null && Te.memoizedState.tag & 1) { if (n.flags |= 2048, qi(9, mm.bind(null, n, r, i, t), void 0, null), ke === null) throw Error(M(349)); rr & 30 || pm(n, t, i) } return i } function pm(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = ue.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ue.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function mm(e, t, n, r) { t.value = n, t.getSnapshot = r, vm(t) && ym(e) } function gm(e, t, n) { return n(function () { vm(t) && ym(e) }) } function vm(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Rt(e, n) } catch { return !0 } } function ym(e) { var t = Zt(e, 1); t !== null && Tt(t, e, 1, -1) } function ed(e) { var t = At(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ji, lastRenderedState: e }, t.queue = e, e = e.dispatch = i1.bind(null, ue, e), [t.memoizedState, e] } function qi(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = ue.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ue.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function wm() { return gt().memoizedState } function qo(e, t, n, r) { var i = At(); ue.flags |= e, i.memoizedState = qi(1 | t, n, void 0, r === void 0 ? null : r) } function Ys(e, t, n, r) { var i = gt(); r = r === void 0 ? null : r; var o = void 0; if (xe !== null) { var s = xe.memoizedState; if (o = s.destroy, r !== null && ec(r, s.deps)) { i.memoizedState = qi(t, n, o, r); return } } ue.flags |= e, i.memoizedState = qi(1 | t, n, o, r) } function td(e, t) { return qo(8390656, 8, e, t) } function rc(e, t) { return Ys(2048, 8, e, t) } function xm(e, t) { return Ys(4, 2, e, t) } function Sm(e, t) { return Ys(4, 4, e, t) } function Cm(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function Pm(e, t, n) { return n = n != null ? n.concat([e]) : null, Ys(4, 4, Cm.bind(null, t, e), n) } function ic() { } function Em(e, t) { var n = gt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && ec(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Tm(e, t) { var n = gt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && ec(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function km(e, t, n) { return rr & 21 ? (Rt(n, t) || (n = Dp(), ue.lanes |= n, ir |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Qe = !0), e.memoizedState = n) } function n1(e, t) { var n = Z; Z = n !== 0 && 4 > n ? n : 4, e(!0); var r = Ba.transition; Ba.transition = {}; try { e(!1), t() } finally { Z = n, Ba.transition = r } } function Rm() { return gt().memoizedState } function r1(e, t, n) { var r = Sn(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Lm(e)) Dm(t, n); else if (n = om(e, t, n, r), n !== null) { var i = We(); Tt(n, e, r, i), Mm(n, t, r) } } function i1(e, t, n) { var r = Sn(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Lm(e)) Dm(t, i); else { var o = e.alternate; if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer, o !== null)) try { var s = t.lastRenderedState, a = o(s, n); if (i.hasEagerState = !0, i.eagerState = a, Rt(a, s)) { var l = t.interleaved; l === null ? (i.next = i, Yu(t)) : (i.next = l.next, l.next = i), t.interleaved = i; return } } catch { } finally { } n = om(e, t, i, r), n !== null && (i = We(), Tt(n, e, r, i), Mm(n, t, r)) } } function Lm(e) { var t = e.alternate; return e === ue || t !== null && t === ue } function Dm(e, t) { Li = ks = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function Mm(e, t, n) { if (n & 4194240) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Fu(e, n) } } var Rs = { readContext: mt, useCallback: Ve, useContext: Ve, useEffect: Ve, useImperativeHandle: Ve, useInsertionEffect: Ve, useLayoutEffect: Ve, useMemo: Ve, useReducer: Ve, useRef: Ve, useState: Ve, useDebugValue: Ve, useDeferredValue: Ve, useTransition: Ve, useMutableSource: Ve, useSyncExternalStore: Ve, useId: Ve, unstable_isNewReconciler: !1 }, o1 = { readContext: mt, useCallback: function (e, t) { return At().memoizedState = [e, t === void 0 ? null : t], e }, useContext: mt, useEffect: td, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, qo(4194308, 4, Cm.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return qo(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return qo(4, 2, e, t) }, useMemo: function (e, t) { var n = At(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = At(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = r1.bind(null, ue, e), [r.memoizedState, e] }, useRef: function (e) { var t = At(); return e = { current: e }, t.memoizedState = e }, useState: ed, useDebugValue: ic, useDeferredValue: function (e) { return At().memoizedState = e }, useTransition: function () { var e = ed(!1), t = e[0]; return e = n1.bind(null, e[1]), At().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = ue, i = At(); if (oe) { if (n === void 0) throw Error(M(407)); n = n() } else { if (n = t(), ke === null) throw Error(M(349)); rr & 30 || pm(r, t, n) } i.memoizedState = n; var o = { value: n, getSnapshot: t }; return i.queue = o, td(gm.bind(null, r, o, e), [e]), r.flags |= 2048, qi(9, mm.bind(null, r, o, n, t), void 0, null), n }, useId: function () { var e = At(), t = ke.identifierPrefix; if (oe) { var n = Ht, r = bt; n = (r & ~(1 << 32 - Et(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = Zi++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = t1++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, s1 = { readContext: mt, useCallback: Em, useContext: mt, useEffect: rc, useImperativeHandle: Pm, useInsertionEffect: xm, useLayoutEffect: Sm, useMemo: Tm, useReducer: ba, useRef: wm, useState: function () { return ba(Ji) }, useDebugValue: ic, useDeferredValue: function (e) { var t = gt(); return km(t, xe.memoizedState, e) }, useTransition: function () { var e = ba(Ji)[0], t = gt().memoizedState; return [e, t] }, useMutableSource: dm, useSyncExternalStore: hm, useId: Rm, unstable_isNewReconciler: !1 }, a1 = { readContext: mt, useCallback: Em, useContext: mt, useEffect: rc, useImperativeHandle: Pm, useInsertionEffect: xm, useLayoutEffect: Sm, useMemo: Tm, useReducer: Ha, useRef: wm, useState: function () { return Ha(Ji) }, useDebugValue: ic, useDeferredValue: function (e) { var t = gt(); return xe === null ? t.memoizedState = e : km(t, xe.memoizedState, e) }, useTransition: function () { var e = Ha(Ji)[0], t = gt().memoizedState; return [e, t] }, useMutableSource: dm, useSyncExternalStore: hm, useId: Rm, unstable_isNewReconciler: !1 }; function Hr(e, t) {
  try { var n = "", r = t; do n += Fy(r), r = r.return; while (r); var i = n } catch (o) {
    i = `
Error generating stack: `+ o.message + `
`+ o.stack
  } return { value: e, source: t, stack: i, digest: null }
} function Wa(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function Kl(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var l1 = typeof WeakMap == "function" ? WeakMap : Map; function Am(e, t, n) { n = $t(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Ds || (Ds = !0, nu = r), Kl(e, t) }, n } function jm(e, t, n) { n = $t(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { Kl(e, t) } } var o = e.stateNode; return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function () { Kl(e, t), typeof r != "function" && (xn === null ? xn = new Set([this]) : xn.add(this)); var s = t.stack; this.componentDidCatch(t.value, { componentStack: s !== null ? s : "" }) }), n } function nd(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new l1; var i = new Set; r.set(t, i) } else i = r.get(t), i === void 0 && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = C1.bind(null, e, t, n), t.then(e, e)) } function rd(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function id(e, t, n, r, i) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = $t(-1, 1), t.tag = 2, wn(n, t, 1))), n.lanes |= 1), e) } var u1 = qt.ReactCurrentOwner, Qe = !1; function He(e, t, n, r) { t.child = e === null ? cm(t, null, n, r) : Br(t, e.child, n, r) } function od(e, t, n, r, i) { n = n.render; var o = t.ref; return _r(t, i), r = tc(e, t, n, r, o, i), n = nc(), e !== null && !Qe ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Jt(e, t, i)) : (oe && n && Hu(t), t.flags |= 1, He(e, t, r, i), t.child) } function sd(e, t, n, r, i) { if (e === null) { var o = n.type; return typeof o == "function" && !dc(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = o, Nm(e, t, o, r, i)) : (e = rs(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e) } if (o = e.child, !(e.lanes & i)) { var s = o.memoizedProps; if (n = n.compare, n = n !== null ? n : $i, n(s, r) && e.ref === t.ref) return Jt(e, t, i) } return t.flags |= 1, e = Cn(o, r), e.ref = t.ref, e.return = t, t.child = e } function Nm(e, t, n, r, i) { if (e !== null) { var o = e.memoizedProps; if ($i(o, r) && e.ref === t.ref) if (Qe = !1, t.pendingProps = r = o, (e.lanes & i) !== 0) e.flags & 131072 && (Qe = !0); else return t.lanes = e.lanes, Jt(e, t, i) } return Gl(e, t, n, r, i) } function Vm(e, t, n) { var r = t.pendingProps, i = r.children, o = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, te(Tr, et), et |= n; else { if (!(n & 1073741824)) return e = o !== null ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, te(Tr, et), et |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = o !== null ? o.baseLanes : n, te(Tr, et), et |= r } else o !== null ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, te(Tr, et), et |= r; return He(e, t, i, n), t.child } function Fm(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Gl(e, t, n, r, i) { var o = Xe(n) ? tr : Ue.current; return o = zr(t, o), _r(t, i), n = tc(e, t, n, r, o, i), r = nc(), e !== null && !Qe ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Jt(e, t, i)) : (oe && r && Hu(t), t.flags |= 1, He(e, t, n, i), t.child) } function ad(e, t, n, r, i) { if (Xe(n)) { var o = !0; ws(t) } else o = !1; if (_r(t, i), t.stateNode === null) es(e, t), lm(t, n, r), $l(t, n, r, i), r = !0; else if (e === null) { var s = t.stateNode, a = t.memoizedProps; s.props = a; var l = s.context, u = n.contextType; typeof u == "object" && u !== null ? u = mt(u) : (u = Xe(n) ? tr : Ue.current, u = zr(t, u)); var c = n.getDerivedStateFromProps, f = typeof c == "function" || typeof s.getSnapshotBeforeUpdate == "function"; f || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== u) && Jf(t, s, r, u), un = !1; var d = t.memoizedState; s.state = d, Es(t, r, s, i), l = t.memoizedState, a !== r || d !== l || Ye.current || un ? (typeof c == "function" && (Wl(t, n, c, r), l = t.memoizedState), (a = un || Zf(t, n, a, r, d, l, u)) ? (f || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), s.props = r, s.state = l, s.context = u, r = a) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { s = t.stateNode, sm(e, t), a = t.memoizedProps, u = t.type === t.elementType ? a : wt(t.type, a), s.props = u, f = t.pendingProps, d = s.context, l = n.contextType, typeof l == "object" && l !== null ? l = mt(l) : (l = Xe(n) ? tr : Ue.current, l = zr(t, l)); var g = n.getDerivedStateFromProps; (c = typeof g == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== f || d !== l) && Jf(t, s, r, l), un = !1, d = t.memoizedState, s.state = d, Es(t, r, s, i); var v = t.memoizedState; a !== f || d !== v || Ye.current || un ? (typeof g == "function" && (Wl(t, n, g, r), v = t.memoizedState), (u = un || Zf(t, n, u, r, d, v, l) || !1) ? (c || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, v, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, v, l)), typeof s.componentDidUpdate == "function" && (t.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = v), s.props = r, s.state = v, s.context = l, r = u) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), r = !1) } return Ql(e, t, n, r, o, i) } function Ql(e, t, n, r, i, o) { Fm(e, t); var s = (t.flags & 128) !== 0; if (!r && !s) return i && Kf(t, n, !1), Jt(e, t, o); r = t.stateNode, u1.current = t; var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && s ? (t.child = Br(t, e.child, null, o), t.child = Br(t, null, a, o)) : He(e, t, a, o), t.memoizedState = r.state, i && Kf(t, n, !0), t.child } function _m(e) { var t = e.stateNode; t.pendingContext ? $f(e, t.pendingContext, t.pendingContext !== t.context) : t.context && $f(e, t.context, !1), Zu(e, t.containerInfo) } function ld(e, t, n, r, i) { return Ur(), $u(i), t.flags |= 256, He(e, t, n, r), t.child } var Yl = { dehydrated: null, treeContext: null, retryLane: 0 }; function Xl(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Om(e, t, n) { var r = t.pendingProps, i = ae.current, o = !1, s = (t.flags & 128) !== 0, a; if ((a = s) || (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), a ? (o = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), te(ae, i & 1), e === null) return bl(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (s = r.children, e = r.fallback, o ? (r = t.mode, o = t.child, s = { mode: "hidden", children: s }, !(r & 1) && o !== null ? (o.childLanes = 0, o.pendingProps = s) : o = Js(s, r, 0, null), e = qn(e, r, n, null), o.return = t, e.return = t, o.sibling = e, t.child = o, t.child.memoizedState = Xl(n), t.memoizedState = Yl, e) : oc(t, s)); if (i = e.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return c1(e, t, s, r, a, i, n); if (o) { o = r.fallback, s = t.mode, i = e.child, a = i.sibling; var l = { mode: "hidden", children: r.children }; return !(s & 1) && t.child !== i ? (r = t.child, r.childLanes = 0, r.pendingProps = l, t.deletions = null) : (r = Cn(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? o = Cn(a, o) : (o = qn(o, s, n, null), o.flags |= 2), o.return = t, r.return = t, r.sibling = o, t.child = r, r = o, o = t.child, s = e.child.memoizedState, s = s === null ? Xl(n) : { baseLanes: s.baseLanes | n, cachePool: null, transitions: s.transitions }, o.memoizedState = s, o.childLanes = e.childLanes & ~n, t.memoizedState = Yl, r } return o = e.child, e = o.sibling, r = Cn(o, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r } function oc(e, t) { return t = Js({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function zo(e, t, n, r) { return r !== null && $u(r), Br(t, e.child, null, n), e = oc(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function c1(e, t, n, r, i, o, s) { if (n) return t.flags & 256 ? (t.flags &= -257, r = Wa(Error(M(422))), zo(e, t, s, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, i = t.mode, r = Js({ mode: "visible", children: r.children }, i, 0, null), o = qn(o, i, s, null), o.flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, t.mode & 1 && Br(t, e.child, null, s), t.child.memoizedState = Xl(s), t.memoizedState = Yl, o); if (!(t.mode & 1)) return zo(e, t, s, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, o = Error(M(419)), r = Wa(o, r, void 0), zo(e, t, s, r) } if (a = (s & e.childLanes) !== 0, Qe || a) { if (r = ke, r !== null) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | s) ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, Zt(e, i), Tt(r, e, i, -1)) } return fc(), r = Wa(Error(M(421))), zo(e, t, s, r) } return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = P1.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, tt = yn(i.nextSibling), rt = t, oe = !0, Ct = null, e !== null && (ft[dt++] = bt, ft[dt++] = Ht, ft[dt++] = nr, bt = e.id, Ht = e.overflow, nr = t), t = oc(t, r.children), t.flags |= 4096, t) } function ud(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), Hl(e.return, t, n) } function $a(e, t, n, r, i) { var o = e.memoizedState; o === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i) } function Im(e, t, n) { var r = t.pendingProps, i = r.revealOrder, o = r.tail; if (He(e, t, r.children, n), r = ae.current, r & 2) r = r & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && ud(e, n, t); else if (e.tag === 19) ud(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (te(ae, r), !(t.mode & 1)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; n !== null;)e = n.alternate, e !== null && Ts(e) === null && (i = n), n = n.sibling; n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), $a(t, !1, i, n, o); break; case "backwards": for (n = null, i = t.child, t.child = null; i !== null;) { if (e = i.alternate, e !== null && Ts(e) === null) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } $a(t, !0, n, null, o); break; case "together": $a(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function es(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Jt(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), ir |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(M(153)); if (t.child !== null) { for (e = t.child, n = Cn(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = Cn(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function f1(e, t, n) { switch (t.tag) { case 3: _m(t), Ur(); break; case 5: fm(t); break; case 1: Xe(t.type) && ws(t); break; case 4: Zu(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; te(Cs, r._currentValue), r._currentValue = i; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (te(ae, ae.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? Om(e, t, n) : (te(ae, ae.current & 1), e = Jt(e, t, n), e !== null ? e.sibling : null); te(ae, ae.current & 1); break; case 19: if (r = (n & t.childLanes) !== 0, e.flags & 128) { if (r) return Im(e, t, n); t.flags |= 128 } if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), te(ae, ae.current), r) break; return null; case 22: case 23: return t.lanes = 0, Vm(e, t, n) }return Jt(e, t, n) } var zm, Zl, Um, Bm; zm = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; Zl = function () { }; Um = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, Qn(Vt.current); var o = null; switch (n) { case "input": i = wl(e, i), r = wl(e, r), o = []; break; case "select": i = ce({}, i, { value: void 0 }), r = ce({}, r, { value: void 0 }), o = []; break; case "textarea": i = Cl(e, i), r = Cl(e, r), o = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = vs) }El(n, r); var s; n = null; for (u in i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null) if (u === "style") { var a = i[u]; for (s in a) a.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (Ii.hasOwnProperty(u) ? o || (o = []) : (o = o || []).push(u, null)); for (u in r) { var l = r[u]; if (a = i != null ? i[u] : void 0, r.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) { for (s in a) !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in l) l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}), n[s] = l[s]) } else n || (o || (o = []), o.push(u, n)), n = l; else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (o = o || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (Ii.hasOwnProperty(u) ? (l != null && u === "onScroll" && re("scroll", e), o || a === l || (o = [])) : (o = o || []).push(u, l)) } n && (o = o || []).push("style", n); var u = o; (t.updateQueue = u) && (t.flags |= 4) } }; Bm = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function li(e, t) { if (!oe) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Fe(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = e, i = i.sibling; else for (i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function d1(e, t, n) { var r = t.pendingProps; switch (Wu(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Fe(t), null; case 1: return Xe(t.type) && ys(), Fe(t), null; case 3: return r = t.stateNode, br(), ie(Ye), ie(Ue), qu(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (Oo(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Ct !== null && (ou(Ct), Ct = null))), Zl(e, t), Fe(t), null; case 5: Ju(t); var i = Qn(Xi.current); if (n = t.type, e !== null && t.stateNode != null) Um(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(M(166)); return Fe(t), null } if (e = Qn(Vt.current), Oo(t)) { r = t.stateNode, n = t.type; var o = t.memoizedProps; switch (r[jt] = t, r[Qi] = o, e = (t.mode & 1) !== 0, n) { case "dialog": re("cancel", r), re("close", r); break; case "iframe": case "object": case "embed": re("load", r); break; case "video": case "audio": for (i = 0; i < Si.length; i++)re(Si[i], r); break; case "source": re("error", r); break; case "img": case "image": case "link": re("error", r), re("load", r); break; case "details": re("toggle", r); break; case "input": yf(r, o), re("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, re("invalid", r); break; case "textarea": xf(r, o), re("invalid", r) }El(n, o), i = null; for (var s in o) if (o.hasOwnProperty(s)) { var a = o[s]; s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== !0 && _o(r.textContent, a, e), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== !0 && _o(r.textContent, a, e), i = ["children", "" + a]) : Ii.hasOwnProperty(s) && a != null && s === "onScroll" && re("scroll", r) } switch (n) { case "input": Lo(r), wf(r, o, !0); break; case "textarea": Lo(r), Sf(r); break; case "select": case "option": break; default: typeof o.onClick == "function" && (r.onclick = vs) }r = i, t.updateQueue = r, r !== null && (t.flags |= 4) } else { s = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = pp(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = s.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = s.createElement(n, { is: r.is }) : (e = s.createElement(n), n === "select" && (s = e, r.multiple ? s.multiple = !0 : r.size && (s.size = r.size))) : e = s.createElementNS(e, n), e[jt] = t, e[Qi] = r, zm(e, t, !1, !1), t.stateNode = e; e: { switch (s = Tl(n, r), n) { case "dialog": re("cancel", e), re("close", e), i = r; break; case "iframe": case "object": case "embed": re("load", e), i = r; break; case "video": case "audio": for (i = 0; i < Si.length; i++)re(Si[i], e); i = r; break; case "source": re("error", e), i = r; break; case "img": case "image": case "link": re("error", e), re("load", e), i = r; break; case "details": re("toggle", e), i = r; break; case "input": yf(e, r), i = wl(e, r), re("invalid", e); break; case "option": i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = ce({}, r, { value: void 0 }), re("invalid", e); break; case "textarea": xf(e, r), i = Cl(e, r), re("invalid", e); break; default: i = r }El(n, i), a = i; for (o in a) if (a.hasOwnProperty(o)) { var l = a[o]; o === "style" ? vp(e, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && mp(e, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && zi(e, l) : typeof l == "number" && zi(e, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (Ii.hasOwnProperty(o) ? l != null && o === "onScroll" && re("scroll", e) : l != null && Du(e, o, l, s)) } switch (n) { case "input": Lo(e), wf(e, r, !1); break; case "textarea": Lo(e), Sf(e); break; case "option": r.value != null && e.setAttribute("value", "" + Tn(r.value)); break; case "select": e.multiple = !!r.multiple, o = r.value, o != null ? jr(e, !!r.multiple, o, !1) : r.defaultValue != null && jr(e, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (e.onclick = vs) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return Fe(t), null; case 6: if (e && t.stateNode != null) Bm(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(M(166)); if (n = Qn(Xi.current), Qn(Vt.current), Oo(t)) { if (r = t.stateNode, n = t.memoizedProps, r[jt] = t, (o = r.nodeValue !== n) && (e = rt, e !== null)) switch (e.tag) { case 3: _o(r.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && _o(r.nodeValue, n, (e.mode & 1) !== 0) }o && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[jt] = t, t.stateNode = r } return Fe(t), null; case 13: if (ie(ae), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (oe && tt !== null && t.mode & 1 && !(t.flags & 128)) im(), Ur(), t.flags |= 98560, o = !1; else if (o = Oo(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!o) throw Error(M(318)); if (o = t.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(M(317)); o[jt] = t } else Ur(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; Fe(t), o = !1 } else Ct !== null && (ou(Ct), Ct = null), o = !0; if (!o) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || ae.current & 1 ? Se === 0 && (Se = 3) : fc())), t.updateQueue !== null && (t.flags |= 4), Fe(t), null); case 4: return br(), Zl(e, t), e === null && Ki(t.stateNode.containerInfo), Fe(t), null; case 10: return Qu(t.type._context), Fe(t), null; case 17: return Xe(t.type) && ys(), Fe(t), null; case 19: if (ie(ae), o = t.memoizedState, o === null) return Fe(t), null; if (r = (t.flags & 128) !== 0, s = o.rendering, s === null) if (r) li(o, !1); else { if (Se !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (s = Ts(e), s !== null) { for (t.flags |= 128, li(o, !1), r = s.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)o = n, e = r, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, e = s.dependencies, o.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return te(ae, ae.current & 1 | 2), t.child } e = e.sibling } o.tail !== null && ye() > Wr && (t.flags |= 128, r = !0, li(o, !1), t.lanes = 4194304) } else { if (!r) if (e = Ts(s), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), li(o, !0), o.tail === null && o.tailMode === "hidden" && !s.alternate && !oe) return Fe(t), null } else 2 * ye() - o.renderingStartTime > Wr && n !== 1073741824 && (t.flags |= 128, r = !0, li(o, !1), t.lanes = 4194304); o.isBackwards ? (s.sibling = t.child, t.child = s) : (n = o.last, n !== null ? n.sibling = s : t.child = s, o.last = s) } return o.tail !== null ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = ye(), t.sibling = null, n = ae.current, te(ae, r ? n & 1 | 2 : n & 1), t) : (Fe(t), null); case 22: case 23: return cc(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? et & 1073741824 && (Fe(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Fe(t), null; case 24: return null; case 25: return null }throw Error(M(156, t.tag)) } function h1(e, t) { switch (Wu(t), t.tag) { case 1: return Xe(t.type) && ys(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return br(), ie(Ye), ie(Ue), qu(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return Ju(t), null; case 13: if (ie(ae), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(M(340)); Ur() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return ie(ae), null; case 4: return br(), null; case 10: return Qu(t.type._context), null; case 22: case 23: return cc(), null; case 24: return null; default: return null } } var Uo = !1, Oe = !1, p1 = typeof WeakSet == "function" ? WeakSet : Set, F = null; function Er(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { me(e, t, r) } else n.current = null } function Jl(e, t, n) { try { n() } catch (r) { me(e, t, r) } } var cd = !1; function m1(e, t) { if (Fl = ps, e = $p(), bu(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { n.nodeType, o.nodeType } catch { n = null; break e } var s = 0, a = -1, l = -1, u = 0, c = 0, f = e, d = null; t: for (; ;) { for (var g; f !== n || i !== 0 && f.nodeType !== 3 || (a = s + i), f !== o || r !== 0 && f.nodeType !== 3 || (l = s + r), f.nodeType === 3 && (s += f.nodeValue.length), (g = f.firstChild) !== null;)d = f, f = g; for (; ;) { if (f === e) break t; if (d === n && ++u === i && (a = s), d === o && ++c === r && (l = s), (g = f.nextSibling) !== null) break; f = d, d = f.parentNode } f = g } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (_l = { focusedElem: e, selectionRange: n }, ps = !1, F = t; F !== null;)if (t = F, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, F = e; else for (; F !== null;) { t = F; try { var v = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (v !== null) { var y = v.memoizedProps, S = v.memoizedState, p = t.stateNode, h = p.getSnapshotBeforeUpdate(t.elementType === t.type ? y : wt(t.type, y), S); p.__reactInternalSnapshotBeforeUpdate = h } break; case 3: var m = t.stateNode.containerInfo; m.nodeType === 1 ? m.textContent = "" : m.nodeType === 9 && m.documentElement && m.removeChild(m.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(M(163)) } } catch (P) { me(t, t.return, P) } if (e = t.sibling, e !== null) { e.return = t.return, F = e; break } F = t.return } return v = cd, cd = !1, v } function Di(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & e) === e) { var o = i.destroy; i.destroy = void 0, o !== void 0 && Jl(t, n, o) } i = i.next } while (i !== r) } } function Xs(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function ql(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function bm(e) { var t = e.alternate; t !== null && (e.alternate = null, bm(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[jt], delete t[Qi], delete t[zl], delete t[Z0], delete t[J0])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function Hm(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function fd(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || Hm(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function eu(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = vs)); else if (r !== 4 && (e = e.child, e !== null)) for (eu(e, t, n), e = e.sibling; e !== null;)eu(e, t, n), e = e.sibling } function tu(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (tu(e, t, n), e = e.sibling; e !== null;)tu(e, t, n), e = e.sibling } var Me = null, xt = !1; function on(e, t, n) { for (n = n.child; n !== null;)Wm(e, t, n), n = n.sibling } function Wm(e, t, n) { if (Nt && typeof Nt.onCommitFiberUnmount == "function") try { Nt.onCommitFiberUnmount(bs, n) } catch { } switch (n.tag) { case 5: Oe || Er(n, t); case 6: var r = Me, i = xt; Me = null, on(e, t, n), Me = r, xt = i, Me !== null && (xt ? (e = Me, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : Me.removeChild(n.stateNode)); break; case 18: Me !== null && (xt ? (e = Me, n = n.stateNode, e.nodeType === 8 ? Ia(e.parentNode, n) : e.nodeType === 1 && Ia(e, n), Hi(e)) : Ia(Me, n.stateNode)); break; case 4: r = Me, i = xt, Me = n.stateNode.containerInfo, xt = !0, on(e, t, n), Me = r, xt = i; break; case 0: case 11: case 14: case 15: if (!Oe && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var o = i, s = o.destroy; o = o.tag, s !== void 0 && (o & 2 || o & 4) && Jl(n, t, s), i = i.next } while (i !== r) } on(e, t, n); break; case 1: if (!Oe && (Er(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { me(n, t, a) } on(e, t, n); break; case 21: on(e, t, n); break; case 22: n.mode & 1 ? (Oe = (r = Oe) || n.memoizedState !== null, on(e, t, n), Oe = r) : on(e, t, n); break; default: on(e, t, n) } } function dd(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new p1), t.forEach(function (r) { var i = E1.bind(null, e, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function yt(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var o = e, s = t, a = s; e: for (; a !== null;) { switch (a.tag) { case 5: Me = a.stateNode, xt = !1; break e; case 3: Me = a.stateNode.containerInfo, xt = !0; break e; case 4: Me = a.stateNode.containerInfo, xt = !0; break e }a = a.return } if (Me === null) throw Error(M(160)); Wm(o, s, i), Me = null, xt = !1; var l = i.alternate; l !== null && (l.return = null), i.return = null } catch (u) { me(i, t, u) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)$m(t, e), t = t.sibling } function $m(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (yt(t, e), Mt(e), r & 4) { try { Di(3, e, e.return), Xs(3, e) } catch (y) { me(e, e.return, y) } try { Di(5, e, e.return) } catch (y) { me(e, e.return, y) } } break; case 1: yt(t, e), Mt(e), r & 512 && n !== null && Er(n, n.return); break; case 5: if (yt(t, e), Mt(e), r & 512 && n !== null && Er(n, n.return), e.flags & 32) { var i = e.stateNode; try { zi(i, "") } catch (y) { me(e, e.return, y) } } if (r & 4 && (i = e.stateNode, i != null)) { var o = e.memoizedProps, s = n !== null ? n.memoizedProps : o, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && o.type === "radio" && o.name != null && dp(i, o), Tl(a, s); var u = Tl(a, o); for (s = 0; s < l.length; s += 2) { var c = l[s], f = l[s + 1]; c === "style" ? vp(i, f) : c === "dangerouslySetInnerHTML" ? mp(i, f) : c === "children" ? zi(i, f) : Du(i, c, f, u) } switch (a) { case "input": xl(i, o); break; case "textarea": hp(i, o); break; case "select": var d = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var g = o.value; g != null ? jr(i, !!o.multiple, g, !1) : d !== !!o.multiple && (o.defaultValue != null ? jr(i, !!o.multiple, o.defaultValue, !0) : jr(i, !!o.multiple, o.multiple ? [] : "", !1)) }i[Qi] = o } catch (y) { me(e, e.return, y) } } break; case 6: if (yt(t, e), Mt(e), r & 4) { if (e.stateNode === null) throw Error(M(162)); i = e.stateNode, o = e.memoizedProps; try { i.nodeValue = o } catch (y) { me(e, e.return, y) } } break; case 3: if (yt(t, e), Mt(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try { Hi(t.containerInfo) } catch (y) { me(e, e.return, y) } break; case 4: yt(t, e), Mt(e); break; case 13: yt(t, e), Mt(e), i = e.child, i.flags & 8192 && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (lc = ye())), r & 4 && dd(e); break; case 22: if (c = n !== null && n.memoizedState !== null, e.mode & 1 ? (Oe = (u = Oe) || c, yt(t, e), Oe = u) : yt(t, e), Mt(e), r & 8192) { if (u = e.memoizedState !== null, (e.stateNode.isHidden = u) && !c && e.mode & 1) for (F = e, c = e.child; c !== null;) { for (f = F = c; F !== null;) { switch (d = F, g = d.child, d.tag) { case 0: case 11: case 14: case 15: Di(4, d, d.return); break; case 1: Er(d, d.return); var v = d.stateNode; if (typeof v.componentWillUnmount == "function") { r = d, n = d.return; try { t = r, v.props = t.memoizedProps, v.state = t.memoizedState, v.componentWillUnmount() } catch (y) { me(r, n, y) } } break; case 5: Er(d, d.return); break; case 22: if (d.memoizedState !== null) { pd(f); continue } }g !== null ? (g.return = d, F = g) : pd(f) } c = c.sibling } e: for (c = null, f = e; ;) { if (f.tag === 5) { if (c === null) { c = f; try { i = f.stateNode, u ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = f.stateNode, l = f.memoizedProps.style, s = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = gp("display", s)) } catch (y) { me(e, e.return, y) } } } else if (f.tag === 6) { if (c === null) try { f.stateNode.nodeValue = u ? "" : f.memoizedProps } catch (y) { me(e, e.return, y) } } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) { f.child.return = f, f = f.child; continue } if (f === e) break e; for (; f.sibling === null;) { if (f.return === null || f.return === e) break e; c === f && (c = null), f = f.return } c === f && (c = null), f.sibling.return = f.return, f = f.sibling } } break; case 19: yt(t, e), Mt(e), r & 4 && dd(e); break; case 21: break; default: yt(t, e), Mt(e) } } function Mt(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (Hm(n)) { var r = n; break e } n = n.return } throw Error(M(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (zi(i, ""), r.flags &= -33); var o = fd(e); tu(e, o, i); break; case 3: case 4: var s = r.stateNode.containerInfo, a = fd(e); eu(e, a, s); break; default: throw Error(M(161)) } } catch (l) { me(e, e.return, l) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function g1(e, t, n) { F = e, Km(e) } function Km(e, t, n) { for (var r = (e.mode & 1) !== 0; F !== null;) { var i = F, o = i.child; if (i.tag === 22 && r) { var s = i.memoizedState !== null || Uo; if (!s) { var a = i.alternate, l = a !== null && a.memoizedState !== null || Oe; a = Uo; var u = Oe; if (Uo = s, (Oe = l) && !u) for (F = i; F !== null;)s = F, l = s.child, s.tag === 22 && s.memoizedState !== null ? md(i) : l !== null ? (l.return = s, F = l) : md(i); for (; o !== null;)F = o, Km(o), o = o.sibling; F = i, Uo = a, Oe = u } hd(e) } else i.subtreeFlags & 8772 && o !== null ? (o.return = i, F = o) : hd(e) } } function hd(e) { for (; F !== null;) { var t = F; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: Oe || Xs(5, t); break; case 1: var r = t.stateNode; if (t.flags & 4 && !Oe) if (n === null) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : wt(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = t.updateQueue; o !== null && Xf(t, o, r); break; case 3: var s = t.updateQueue; if (s !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }Xf(t, s, n) } break; case 5: var a = t.stateNode; if (n === null && t.flags & 4) { n = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var u = t.alternate; if (u !== null) { var c = u.memoizedState; if (c !== null) { var f = c.dehydrated; f !== null && Hi(f) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(M(163)) }Oe || t.flags & 512 && ql(t) } catch (d) { me(t, t.return, d) } } if (t === e) { F = null; break } if (n = t.sibling, n !== null) { n.return = t.return, F = n; break } F = t.return } } function pd(e) { for (; F !== null;) { var t = F; if (t === e) { F = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, F = n; break } F = t.return } } function md(e) { for (; F !== null;) { var t = F; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { Xs(4, t) } catch (l) { me(t, n, l) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var i = t.return; try { r.componentDidMount() } catch (l) { me(t, i, l) } } var o = t.return; try { ql(t) } catch (l) { me(t, o, l) } break; case 5: var s = t.return; try { ql(t) } catch (l) { me(t, s, l) } } } catch (l) { me(t, t.return, l) } if (t === e) { F = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, F = a; break } F = t.return } } var v1 = Math.ceil, Ls = qt.ReactCurrentDispatcher, sc = qt.ReactCurrentOwner, pt = qt.ReactCurrentBatchConfig, Q = 0, ke = null, we = null, je = 0, et = 0, Tr = Fn(0), Se = 0, eo = null, ir = 0, Zs = 0, ac = 0, Mi = null, Ge = null, lc = 0, Wr = 1 / 0, Ut = null, Ds = !1, nu = null, xn = null, Bo = !1, pn = null, Ms = 0, Ai = 0, ru = null, ts = -1, ns = 0; function We() { return Q & 6 ? ye() : ts !== -1 ? ts : ts = ye() } function Sn(e) { return e.mode & 1 ? Q & 2 && je !== 0 ? je & -je : e1.transition !== null ? (ns === 0 && (ns = Dp()), ns) : (e = Z, e !== 0 || (e = window.event, e = e === void 0 ? 16 : _p(e.type)), e) : 1 } function Tt(e, t, n, r) { if (50 < Ai) throw Ai = 0, ru = null, Error(M(185)); lo(e, n, r), (!(Q & 2) || e !== ke) && (e === ke && (!(Q & 2) && (Zs |= n), Se === 4 && dn(e, je)), Ze(e, r), n === 1 && Q === 0 && !(t.mode & 1) && (Wr = ye() + 500, Gs && _n())) } function Ze(e, t) { var n = e.callbackNode; e0(e, t); var r = hs(e, e === ke ? je : 0); if (r === 0) n !== null && Ef(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && Ef(n), t === 1) e.tag === 0 ? q0(gd.bind(null, e)) : tm(gd.bind(null, e)), Y0(function () { !(Q & 6) && _n() }), n = null; else { switch (Mp(r)) { case 1: n = Vu; break; case 4: n = Rp; break; case 16: n = ds; break; case 536870912: n = Lp; break; default: n = ds }n = eg(n, Gm.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function Gm(e, t) { if (ts = -1, ns = 0, Q & 6) throw Error(M(327)); var n = e.callbackNode; if (Or() && e.callbackNode !== n) return null; var r = hs(e, e === ke ? je : 0); if (r === 0) return null; if (r & 30 || r & e.expiredLanes || t) t = As(e, r); else { t = r; var i = Q; Q |= 2; var o = Ym(); (ke !== e || je !== t) && (Ut = null, Wr = ye() + 500, Jn(e, t)); do try { x1(); break } catch (a) { Qm(e, a) } while (!0); Gu(), Ls.current = o, Q = i, we !== null ? t = 0 : (ke = null, je = 0, t = Se) } if (t !== 0) { if (t === 2 && (i = Ml(e), i !== 0 && (r = i, t = iu(e, i))), t === 1) throw n = eo, Jn(e, 0), dn(e, r), Ze(e, ye()), n; if (t === 6) dn(e, r); else { if (i = e.current.alternate, !(r & 30) && !y1(i) && (t = As(e, r), t === 2 && (o = Ml(e), o !== 0 && (r = o, t = iu(e, o))), t === 1)) throw n = eo, Jn(e, 0), dn(e, r), Ze(e, ye()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(M(345)); case 2: bn(e, Ge, Ut); break; case 3: if (dn(e, r), (r & 130023424) === r && (t = lc + 500 - ye(), 10 < t)) { if (hs(e, 0) !== 0) break; if (i = e.suspendedLanes, (i & r) !== r) { We(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = Il(bn.bind(null, e, Ge, Ut), t); break } bn(e, Ge, Ut); break; case 4: if (dn(e, r), (r & 4194240) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - Et(r); o = 1 << s, s = t[s], s > i && (i = s), r &= ~o } if (r = i, r = ye() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * v1(r / 1960)) - r, 10 < r) { e.timeoutHandle = Il(bn.bind(null, e, Ge, Ut), r); break } bn(e, Ge, Ut); break; case 5: bn(e, Ge, Ut); break; default: throw Error(M(329)) } } } return Ze(e, ye()), e.callbackNode === n ? Gm.bind(null, e) : null } function iu(e, t) { var n = Mi; return e.current.memoizedState.isDehydrated && (Jn(e, t).flags |= 256), e = As(e, t), e !== 2 && (t = Ge, Ge = n, t !== null && ou(t)), e } function ou(e) { Ge === null ? Ge = e : Ge.push.apply(Ge, e) } function y1(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], o = i.getSnapshot; i = i.value; try { if (!Rt(o(), i)) return !1 } catch { return !1 } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function dn(e, t) { for (t &= ~ac, t &= ~Zs, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - Et(t), r = 1 << n; e[n] = -1, t &= ~r } } function gd(e) { if (Q & 6) throw Error(M(327)); Or(); var t = hs(e, 0); if (!(t & 1)) return Ze(e, ye()), null; var n = As(e, t); if (e.tag !== 0 && n === 2) { var r = Ml(e); r !== 0 && (t = r, n = iu(e, r)) } if (n === 1) throw n = eo, Jn(e, 0), dn(e, t), Ze(e, ye()), n; if (n === 6) throw Error(M(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, bn(e, Ge, Ut), Ze(e, ye()), null } function uc(e, t) { var n = Q; Q |= 1; try { return e(t) } finally { Q = n, Q === 0 && (Wr = ye() + 500, Gs && _n()) } } function or(e) { pn !== null && pn.tag === 0 && !(Q & 6) && Or(); var t = Q; Q |= 1; var n = pt.transition, r = Z; try { if (pt.transition = null, Z = 1, e) return e() } finally { Z = r, pt.transition = n, Q = t, !(Q & 6) && _n() } } function cc() { et = Tr.current, ie(Tr) } function Jn(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, Q0(n)), we !== null) for (n = we.return; n !== null;) { var r = n; switch (Wu(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && ys(); break; case 3: br(), ie(Ye), ie(Ue), qu(); break; case 5: Ju(r); break; case 4: br(); break; case 13: ie(ae); break; case 19: ie(ae); break; case 10: Qu(r.type._context); break; case 22: case 23: cc() }n = n.return } if (ke = e, we = e = Cn(e.current, null), je = et = t, Se = 0, eo = null, ac = Zs = ir = 0, Ge = Mi = null, Gn !== null) { for (t = 0; t < Gn.length; t++)if (n = Gn[t], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, o = n.pending; if (o !== null) { var s = o.next; o.next = i, r.next = s } n.pending = r } Gn = null } return e } function Qm(e, t) { do { var n = we; try { if (Gu(), Jo.current = Rs, ks) { for (var r = ue.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } ks = !1 } if (rr = 0, Te = xe = ue = null, Li = !1, Zi = 0, sc.current = null, n === null || n.return === null) { Se = 1, eo = t, we = null; break } e: { var o = e, s = n.return, a = n, l = t; if (t = je, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var u = l, c = a, f = c.tag; if (!(c.mode & 1) && (f === 0 || f === 11 || f === 15)) { var d = c.alternate; d ? (c.updateQueue = d.updateQueue, c.memoizedState = d.memoizedState, c.lanes = d.lanes) : (c.updateQueue = null, c.memoizedState = null) } var g = rd(s); if (g !== null) { g.flags &= -257, id(g, s, a, o, t), g.mode & 1 && nd(o, u, t), t = g, l = u; var v = t.updateQueue; if (v === null) { var y = new Set; y.add(l), t.updateQueue = y } else v.add(l); break e } else { if (!(t & 1)) { nd(o, u, t), fc(); break e } l = Error(M(426)) } } else if (oe && a.mode & 1) { var S = rd(s); if (S !== null) { !(S.flags & 65536) && (S.flags |= 256), id(S, s, a, o, t), $u(Hr(l, a)); break e } } o = l = Hr(l, a), Se !== 4 && (Se = 2), Mi === null ? Mi = [o] : Mi.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t; var p = Am(o, l, t); Yf(o, p); break e; case 1: a = l; var h = o.type, m = o.stateNode; if (!(o.flags & 128) && (typeof h.getDerivedStateFromError == "function" || m !== null && typeof m.componentDidCatch == "function" && (xn === null || !xn.has(m)))) { o.flags |= 65536, t &= -t, o.lanes |= t; var P = jm(o, a, t); Yf(o, P); break e } }o = o.return } while (o !== null) } Zm(n) } catch (R) { t = R, we === n && n !== null && (we = n = n.return); continue } break } while (!0) } function Ym() { var e = Ls.current; return Ls.current = Rs, e === null ? Rs : e } function fc() { (Se === 0 || Se === 3 || Se === 2) && (Se = 4), ke === null || !(ir & 268435455) && !(Zs & 268435455) || dn(ke, je) } function As(e, t) { var n = Q; Q |= 2; var r = Ym(); (ke !== e || je !== t) && (Ut = null, Jn(e, t)); do try { w1(); break } catch (i) { Qm(e, i) } while (!0); if (Gu(), Q = n, Ls.current = r, we !== null) throw Error(M(261)); return ke = null, je = 0, Se } function w1() { for (; we !== null;)Xm(we) } function x1() { for (; we !== null && !$y();)Xm(we) } function Xm(e) { var t = qm(e.alternate, e, et); e.memoizedProps = e.pendingProps, t === null ? Zm(e) : we = t, sc.current = null } function Zm(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = h1(n, t), n !== null) { n.flags &= 32767, we = n; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { Se = 6, we = null; return } } else if (n = d1(n, t, et), n !== null) { we = n; return } if (t = t.sibling, t !== null) { we = t; return } we = t = e } while (t !== null); Se === 0 && (Se = 5) } function bn(e, t, n) { var r = Z, i = pt.transition; try { pt.transition = null, Z = 1, S1(e, t, n, r) } finally { pt.transition = i, Z = r } return null } function S1(e, t, n, r) { do Or(); while (pn !== null); if (Q & 6) throw Error(M(327)); n = e.finishedWork; var i = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(M(177)); e.callbackNode = null, e.callbackPriority = 0; var o = n.lanes | n.childLanes; if (t0(e, o), e === ke && (we = ke = null, je = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Bo || (Bo = !0, eg(ds, function () { return Or(), null })), o = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || o) { o = pt.transition, pt.transition = null; var s = Z; Z = 1; var a = Q; Q |= 4, sc.current = null, m1(e, n), $m(n, e), B0(_l), ps = !!Fl, _l = Fl = null, e.current = n, g1(n), Ky(), Q = a, Z = s, pt.transition = o } else e.current = n; if (Bo && (Bo = !1, pn = e, Ms = i), o = e.pendingLanes, o === 0 && (xn = null), Yy(n.stateNode), Ze(e, ye()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Ds) throw Ds = !1, e = nu, nu = null, e; return Ms & 1 && e.tag !== 0 && Or(), o = e.pendingLanes, o & 1 ? e === ru ? Ai++ : (Ai = 0, ru = e) : Ai = 0, _n(), null } function Or() { if (pn !== null) { var e = Mp(Ms), t = pt.transition, n = Z; try { if (pt.transition = null, Z = 16 > e ? 16 : e, pn === null) var r = !1; else { if (e = pn, pn = null, Ms = 0, Q & 6) throw Error(M(331)); var i = Q; for (Q |= 4, F = e.current; F !== null;) { var o = F, s = o.child; if (F.flags & 16) { var a = o.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var u = a[l]; for (F = u; F !== null;) { var c = F; switch (c.tag) { case 0: case 11: case 15: Di(8, c, o) }var f = c.child; if (f !== null) f.return = c, F = f; else for (; F !== null;) { c = F; var d = c.sibling, g = c.return; if (bm(c), c === u) { F = null; break } if (d !== null) { d.return = g, F = d; break } F = g } } } var v = o.alternate; if (v !== null) { var y = v.child; if (y !== null) { v.child = null; do { var S = y.sibling; y.sibling = null, y = S } while (y !== null) } } F = o } } if (o.subtreeFlags & 2064 && s !== null) s.return = o, F = s; else e: for (; F !== null;) { if (o = F, o.flags & 2048) switch (o.tag) { case 0: case 11: case 15: Di(9, o, o.return) }var p = o.sibling; if (p !== null) { p.return = o.return, F = p; break e } F = o.return } } var h = e.current; for (F = h; F !== null;) { s = F; var m = s.child; if (s.subtreeFlags & 2064 && m !== null) m.return = s, F = m; else e: for (s = h; F !== null;) { if (a = F, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: Xs(9, a) } } catch (R) { me(a, a.return, R) } if (a === s) { F = null; break e } var P = a.sibling; if (P !== null) { P.return = a.return, F = P; break e } F = a.return } } if (Q = i, _n(), Nt && typeof Nt.onPostCommitFiberRoot == "function") try { Nt.onPostCommitFiberRoot(bs, e) } catch { } r = !0 } return r } finally { Z = n, pt.transition = t } } return !1 } function vd(e, t, n) { t = Hr(n, t), t = Am(e, t, 1), e = wn(e, t, 1), t = We(), e !== null && (lo(e, 1, t), Ze(e, t)) } function me(e, t, n) { if (e.tag === 3) vd(e, e, n); else for (; t !== null;) { if (t.tag === 3) { vd(t, e, n); break } else if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (xn === null || !xn.has(r))) { e = Hr(n, e), e = jm(t, e, 1), t = wn(t, e, 1), e = We(), t !== null && (lo(t, 1, e), Ze(t, e)); break } } t = t.return } } function C1(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = We(), e.pingedLanes |= e.suspendedLanes & n, ke === e && (je & n) === n && (Se === 4 || Se === 3 && (je & 130023424) === je && 500 > ye() - lc ? Jn(e, 0) : ac |= n), Ze(e, t) } function Jm(e, t) { t === 0 && (e.mode & 1 ? (t = Ao, Ao <<= 1, !(Ao & 130023424) && (Ao = 4194304)) : t = 1); var n = We(); e = Zt(e, t), e !== null && (lo(e, t, n), Ze(e, n)) } function P1(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), Jm(e, n) } function E1(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(M(314)) }r !== null && r.delete(t), Jm(e, n) } var qm; qm = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || Ye.current) Qe = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return Qe = !1, f1(e, t, n); Qe = !!(e.flags & 131072) } else Qe = !1, oe && t.flags & 1048576 && nm(t, Ss, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; es(e, t), e = t.pendingProps; var i = zr(t, Ue.current); _r(t, n), i = tc(null, t, r, e, i, n); var o = nc(); return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Xe(r) ? (o = !0, ws(t)) : o = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, Xu(t), i.updater = Qs, t.stateNode = i, i._reactInternals = t, $l(t, r, e, n), t = Ql(null, t, r, !0, o, n)) : (t.tag = 0, oe && o && Hu(t), He(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (es(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = k1(r), e = wt(r, e), i) { case 0: t = Gl(null, t, r, e, n); break e; case 1: t = ad(null, t, r, e, n); break e; case 11: t = od(null, t, r, e, n); break e; case 14: t = sd(null, t, r, wt(r.type, e), n); break e }throw Error(M(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : wt(r, i), Gl(e, t, r, i, n); case 1: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : wt(r, i), ad(e, t, r, i, n); case 3: e: { if (_m(t), e === null) throw Error(M(387)); r = t.pendingProps, o = t.memoizedState, i = o.element, sm(e, t), Es(t, r, null, n); var s = t.memoizedState; if (r = s.element, o.isDehydrated) if (o = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = o, t.memoizedState = o, t.flags & 256) { i = Hr(Error(M(423)), t), t = ld(e, t, r, n, i); break e } else if (r !== i) { i = Hr(Error(M(424)), t), t = ld(e, t, r, n, i); break e } else for (tt = yn(t.stateNode.containerInfo.firstChild), rt = t, oe = !0, Ct = null, n = cm(t, null, r, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (Ur(), r === i) { t = Jt(e, t, n); break e } He(e, t, r, n) } t = t.child } return t; case 5: return fm(t), e === null && bl(t), r = t.type, i = t.pendingProps, o = e !== null ? e.memoizedProps : null, s = i.children, Ol(r, i) ? s = null : o !== null && Ol(r, o) && (t.flags |= 32), Fm(e, t), He(e, t, s, n), t.child; case 6: return e === null && bl(t), null; case 13: return Om(e, t, n); case 4: return Zu(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = Br(t, null, r, n) : He(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : wt(r, i), od(e, t, r, i, n); case 7: return He(e, t, t.pendingProps, n), t.child; case 8: return He(e, t, t.pendingProps.children, n), t.child; case 12: return He(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, s = i.value, te(Cs, r._currentValue), r._currentValue = s, o !== null) if (Rt(o.value, s)) { if (o.children === i.children && !Ye.current) { t = Jt(e, t, n); break e } } else for (o = t.child, o !== null && (o.return = t); o !== null;) { var a = o.dependencies; if (a !== null) { s = o.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (o.tag === 1) { l = $t(-1, n & -n), l.tag = 2; var u = o.updateQueue; if (u !== null) { u = u.shared; var c = u.pending; c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l } } o.lanes |= n, l = o.alternate, l !== null && (l.lanes |= n), Hl(o.return, n, t), a.lanes |= n; break } l = l.next } } else if (o.tag === 10) s = o.type === t.type ? null : o.child; else if (o.tag === 18) { if (s = o.return, s === null) throw Error(M(341)); s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), Hl(s, n, t), s = o.sibling } else s = o.child; if (s !== null) s.return = o; else for (s = o; s !== null;) { if (s === t) { s = null; break } if (o = s.sibling, o !== null) { o.return = s.return, s = o; break } s = s.return } o = s } He(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, _r(t, n), i = mt(i), r = r(i), t.flags |= 1, He(e, t, r, n), t.child; case 14: return r = t.type, i = wt(r, t.pendingProps), i = wt(r.type, i), sd(e, t, r, i, n); case 15: return Nm(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : wt(r, i), es(e, t), t.tag = 1, Xe(r) ? (e = !0, ws(t)) : e = !1, _r(t, n), lm(t, r, i), $l(t, r, i, n), Ql(null, t, r, !0, e, n); case 19: return Im(e, t, n); case 22: return Vm(e, t, n) }throw Error(M(156, t.tag)) }; function eg(e, t) { return kp(e, t) } function T1(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function ht(e, t, n, r) { return new T1(e, t, n, r) } function dc(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function k1(e) { if (typeof e == "function") return dc(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Au) return 11; if (e === ju) return 14 } return 2 } function Cn(e, t) { var n = e.alternate; return n === null ? (n = ht(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function rs(e, t, n, r, i, o) { var s = 2; if (r = e, typeof e == "function") dc(e) && (s = 1); else if (typeof e == "string") s = 5; else e: switch (e) { case mr: return qn(n.children, i, o, t); case Mu: s = 8, i |= 8; break; case ml: return e = ht(12, n, t, i | 2), e.elementType = ml, e.lanes = o, e; case gl: return e = ht(13, n, t, i), e.elementType = gl, e.lanes = o, e; case vl: return e = ht(19, n, t, i), e.elementType = vl, e.lanes = o, e; case up: return Js(n, i, o, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case ap: s = 10; break e; case lp: s = 9; break e; case Au: s = 11; break e; case ju: s = 14; break e; case ln: s = 16, r = null; break e }throw Error(M(130, e == null ? e : typeof e, "")) }return t = ht(s, n, t, i), t.elementType = e, t.type = r, t.lanes = o, t } function qn(e, t, n, r) { return e = ht(7, e, r, t), e.lanes = n, e } function Js(e, t, n, r) { return e = ht(22, e, r, t), e.elementType = up, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function Ka(e, t, n) { return e = ht(6, e, null, t), e.lanes = n, e } function Ga(e, t, n) { return t = ht(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function R1(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ra(0), this.expirationTimes = Ra(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ra(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function hc(e, t, n, r, i, o, s, a, l) { return e = new R1(e, t, n, a, l), t === 1 ? (t = 1, o === !0 && (t |= 8)) : t = 0, o = ht(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Xu(o), e } function L1(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: pr, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function tg(e) { if (!e) return kn; e = e._reactInternals; e: { if (lr(e) !== e || e.tag !== 1) throw Error(M(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Xe(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(M(171)) } if (e.tag === 1) { var n = e.type; if (Xe(n)) return em(e, n, t) } return t } function ng(e, t, n, r, i, o, s, a, l) { return e = hc(n, r, !0, e, i, o, s, a, l), e.context = tg(null), n = e.current, r = We(), i = Sn(n), o = $t(r, i), o.callback = t ?? null, wn(n, o, i), e.current.lanes = i, lo(e, i, r), Ze(e, r), e } function qs(e, t, n, r) { var i = t.current, o = We(), s = Sn(i); return n = tg(n), t.context === null ? t.context = n : t.pendingContext = n, t = $t(o, s), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = wn(i, t, s), e !== null && (Tt(e, i, s, o), Zo(e, i, s)), s } function js(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function yd(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function pc(e, t) { yd(e, t), (e = e.alternate) && yd(e, t) } function D1() { return null } var rg = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function mc(e) { this._internalRoot = e } ea.prototype.render = mc.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(M(409)); qs(e, t, null, null) }; ea.prototype.unmount = mc.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; or(function () { qs(null, e, null, null) }), t[Xt] = null } }; function ea(e) { this._internalRoot = e } ea.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = Np(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < fn.length && t !== 0 && t < fn[n].priority; n++); fn.splice(n, 0, e), n === 0 && Fp(e) } }; function gc(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function ta(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function wd() { } function M1(e, t, n, r, i) { if (i) { if (typeof r == "function") { var o = r; r = function () { var u = js(s); o.call(u) } } var s = ng(t, r, e, 0, null, !1, !1, "", wd); return e._reactRootContainer = s, e[Xt] = s.current, Ki(e.nodeType === 8 ? e.parentNode : e), or(), s } for (; i = e.lastChild;)e.removeChild(i); if (typeof r == "function") { var a = r; r = function () { var u = js(l); a.call(u) } } var l = hc(e, 0, !1, null, null, !1, !1, "", wd); return e._reactRootContainer = l, e[Xt] = l.current, Ki(e.nodeType === 8 ? e.parentNode : e), or(function () { qs(t, l, n, r) }), l } function na(e, t, n, r, i) { var o = n._reactRootContainer; if (o) { var s = o; if (typeof i == "function") { var a = i; i = function () { var l = js(s); a.call(l) } } qs(t, s, e, i) } else s = M1(n, t, e, i, r); return js(s) } Ap = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = xi(t.pendingLanes); n !== 0 && (Fu(t, n | 1), Ze(t, ye()), !(Q & 6) && (Wr = ye() + 500, _n())) } break; case 13: or(function () { var r = Zt(e, 1); if (r !== null) { var i = We(); Tt(r, e, 1, i) } }), pc(e, 1) } }; _u = function (e) { if (e.tag === 13) { var t = Zt(e, 134217728); if (t !== null) { var n = We(); Tt(t, e, 134217728, n) } pc(e, 134217728) } }; jp = function (e) { if (e.tag === 13) { var t = Sn(e), n = Zt(e, t); if (n !== null) { var r = We(); Tt(n, e, t, r) } pc(e, t) } }; Np = function () { return Z }; Vp = function (e, t) { var n = Z; try { return Z = e, t() } finally { Z = n } }; Rl = function (e, t, n) { switch (t) { case "input": if (xl(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = Ks(r); if (!i) throw Error(M(90)); fp(r), xl(r, i) } } } break; case "textarea": hp(e, n); break; case "select": t = n.value, t != null && jr(e, !!n.multiple, t, !1) } }; xp = uc; Sp = or; var A1 = { usingClientEntryPoint: !1, Events: [co, wr, Ks, yp, wp, uc] }, ui = { findFiberByHostInstance: Kn, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, j1 = { bundleType: ui.bundleType, version: ui.version, rendererPackageName: ui.rendererPackageName, rendererConfig: ui.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: qt.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Ep(e), e === null ? null : e.stateNode }, findFiberByHostInstance: ui.findFiberByHostInstance || D1, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var bo = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!bo.isDisabled && bo.supportsFiber) try { bs = bo.inject(j1), Nt = bo } catch { } } st.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = A1; st.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!gc(t)) throw Error(M(200)); return L1(e, t, null, n) }; st.createRoot = function (e, t) { if (!gc(e)) throw Error(M(299)); var n = !1, r = "", i = rg; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = hc(e, 1, !1, null, null, n, !1, r, i), e[Xt] = t.current, Ki(e.nodeType === 8 ? e.parentNode : e), new mc(t) }; st.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(M(188)) : (e = Object.keys(e).join(","), Error(M(268, e))); return e = Ep(t), e = e === null ? null : e.stateNode, e }; st.flushSync = function (e) { return or(e) }; st.hydrate = function (e, t, n) { if (!ta(t)) throw Error(M(200)); return na(null, e, t, !0, n) }; st.hydrateRoot = function (e, t, n) { if (!gc(e)) throw Error(M(405)); var r = n != null && n.hydratedSources || null, i = !1, o = "", s = rg; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), t = ng(t, null, e, 1, n ?? null, i, !1, o, s), e[Xt] = t.current, Ki(e), r) for (e = 0; e < r.length; e++)n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new ea(t) }; st.render = function (e, t, n) { if (!ta(t)) throw Error(M(200)); return na(null, e, t, !1, n) }; st.unmountComponentAtNode = function (e) { if (!ta(e)) throw Error(M(40)); return e._reactRootContainer ? (or(function () { na(null, null, e, !1, function () { e._reactRootContainer = null, e[Xt] = null }) }), !0) : !1 }; st.unstable_batchedUpdates = uc; st.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!ta(n)) throw Error(M(200)); if (e == null || e._reactInternals === void 0) throw Error(M(38)); return na(e, t, n, !1, r) }; st.version = "18.2.0-next-9e3b772b8-20220608"; function ig() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ig) } catch (e) { console.error(e) } } ig(), np.exports = st; var vc = np.exports; const N1 = yy(vc), V1 = Dy({ __proto__: null, default: N1 }, [vc]);/**
 * @remix-run/router v1.15.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function se() { return se = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, se.apply(this, arguments) } var ve; (function (e) { e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE" })(ve || (ve = {})); const xd = "popstate"; function F1(e) { e === void 0 && (e = {}); function t(i, o) { let { pathname: s = "/", search: a = "", hash: l = "" } = Ot(i.location.hash.substr(1)); return !s.startsWith("/") && !s.startsWith(".") && (s = "/" + s), to("", { pathname: s, search: a, hash: l }, o.state && o.state.usr || null, o.state && o.state.key || "default") } function n(i, o) { let s = i.document.querySelector("base"), a = ""; if (s && s.getAttribute("href")) { let l = i.location.href, u = l.indexOf("#"); a = u === -1 ? l : l.slice(0, u) } return a + "#" + (typeof o == "string" ? o : Rn(o)) } function r(i, o) { sr(i.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(o) + ")") } return O1(t, n, r, e) } function H(e, t) { if (e === !1 || e === null || typeof e > "u") throw new Error(t) } function sr(e, t) { if (!e) { typeof console < "u" && console.warn(t); try { throw new Error(t) } catch { } } } function _1() { return Math.random().toString(36).substr(2, 8) } function Sd(e, t) { return { usr: e.state, key: e.key, idx: t } } function to(e, t, n, r) { return n === void 0 && (n = null), se({ pathname: typeof e == "string" ? e : e.pathname, search: "", hash: "" }, typeof t == "string" ? Ot(t) : t, { state: n, key: t && t.key || r || _1() }) } function Rn(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r), t } function Ot(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } function O1(e, t, n, r) { r === void 0 && (r = {}); let { window: i = document.defaultView, v5Compat: o = !1 } = r, s = i.history, a = ve.Pop, l = null, u = c(); u == null && (u = 0, s.replaceState(se({}, s.state, { idx: u }), "")); function c() { return (s.state || { idx: null }).idx } function f() { a = ve.Pop; let S = c(), p = S == null ? null : S - u; u = S, l && l({ action: a, location: y.location, delta: p }) } function d(S, p) { a = ve.Push; let h = to(y.location, S, p); n && n(h, S), u = c() + 1; let m = Sd(h, u), P = y.createHref(h); try { s.pushState(m, "", P) } catch (R) { if (R instanceof DOMException && R.name === "DataCloneError") throw R; i.location.assign(P) } o && l && l({ action: a, location: y.location, delta: 1 }) } function g(S, p) { a = ve.Replace; let h = to(y.location, S, p); n && n(h, S), u = c(); let m = Sd(h, u), P = y.createHref(h); s.replaceState(m, "", P), o && l && l({ action: a, location: y.location, delta: 0 }) } function v(S) { let p = i.location.origin !== "null" ? i.location.origin : i.location.href, h = typeof S == "string" ? S : Rn(S); return h = h.replace(/ $/, "%20"), H(p, "No window.location.(origin|href) available to create URL for href: " + h), new URL(h, p) } let y = { get action() { return a }, get location() { return e(i, s) }, listen(S) { if (l) throw new Error("A history only accepts one active listener"); return i.addEventListener(xd, f), l = S, () => { i.removeEventListener(xd, f), l = null } }, createHref(S) { return t(i, S) }, createURL: v, encodeLocation(S) { let p = v(S); return { pathname: p.pathname, search: p.search, hash: p.hash } }, push: d, replace: g, go(S) { return s.go(S) } }; return y } var pe; (function (e) { e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error" })(pe || (pe = {})); const I1 = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]); function z1(e) { return e.index === !0 } function su(e, t, n, r) { return n === void 0 && (n = []), r === void 0 && (r = {}), e.map((i, o) => { let s = [...n, o], a = typeof i.id == "string" ? i.id : s.join("-"); if (H(i.index !== !0 || !i.children, "Cannot specify children on an index route"), H(!r[a], 'Found a route id collision on id "' + a + `".  Route id's must be globally unique within Data Router usages`), z1(i)) { let l = se({}, i, t(i), { id: a }); return r[a] = l, l } else { let l = se({}, i, t(i), { id: a, children: void 0 }); return r[a] = l, i.children && (l.children = su(i.children, t, s, r)), l } }) } function kr(e, t, n) { n === void 0 && (n = "/"); let r = typeof t == "string" ? Ot(t) : t, i = Lt(r.pathname || "/", n); if (i == null) return null; let o = og(e); B1(o); let s = null; for (let a = 0; s == null && a < o.length; ++a) { let l = J1(i); s = X1(o[a], l) } return s } function U1(e, t) { let { route: n, pathname: r, params: i } = e; return { id: n.id, pathname: r, params: i, data: t[n.id], handle: n.handle } } function og(e, t, n, r) { t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = ""); let i = (o, s, a) => { let l = { relativePath: a === void 0 ? o.path || "" : a, caseSensitive: o.caseSensitive === !0, childrenIndex: s, route: o }; l.relativePath.startsWith("/") && (H(l.relativePath.startsWith(r), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(r.length)); let u = Ft([r, l.relativePath]), c = n.concat(l); o.children && o.children.length > 0 && (H(o.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + u + '".')), og(o.children, t, c, u)), !(o.path == null && !o.index) && t.push({ path: u, score: Q1(u, o.index), routesMeta: c }) }; return e.forEach((o, s) => { var a; if (o.path === "" || !((a = o.path) != null && a.includes("?"))) i(o, s); else for (let l of sg(o.path)) i(o, s, l) }), t } function sg(e) { let t = e.split("/"); if (t.length === 0) return []; let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, ""); if (r.length === 0) return i ? [o, ""] : [o]; let s = sg(r.join("/")), a = []; return a.push(...s.map(l => l === "" ? o : [o, l].join("/"))), i && a.push(...s), a.map(l => e.startsWith("/") && l === "" ? "/" : l) } function B1(e) { e.sort((t, n) => t.score !== n.score ? n.score - t.score : Y1(t.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex))) } const b1 = /^:[\w-]+$/, H1 = 3, W1 = 2, $1 = 1, K1 = 10, G1 = -2, Cd = e => e === "*"; function Q1(e, t) { let n = e.split("/"), r = n.length; return n.some(Cd) && (r += G1), t && (r += W1), n.filter(i => !Cd(i)).reduce((i, o) => i + (b1.test(o) ? H1 : o === "" ? $1 : K1), r) } function Y1(e, t) { return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? e[e.length - 1] - t[t.length - 1] : 0 } function X1(e, t) { let { routesMeta: n } = e, r = {}, i = "/", o = []; for (let s = 0; s < n.length; ++s) { let a = n[s], l = s === n.length - 1, u = i === "/" ? t : t.slice(i.length) || "/", c = au({ path: a.relativePath, caseSensitive: a.caseSensitive, end: l }, u); if (!c) return null; Object.assign(r, c.params); let f = a.route; o.push({ params: r, pathname: Ft([i, c.pathname]), pathnameBase: tw(Ft([i, c.pathnameBase])), route: f }), c.pathnameBase !== "/" && (i = Ft([i, c.pathnameBase])) } return o } function au(e, t) { typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = Z1(e.path, e.caseSensitive, e.end), i = t.match(n); if (!i) return null; let o = i[0], s = o.replace(/(.)\/+$/, "$1"), a = i.slice(1); return { params: r.reduce((u, c, f) => { let { paramName: d, isOptional: g } = c; if (d === "*") { let y = a[f] || ""; s = o.slice(0, o.length - y.length).replace(/(.)\/+$/, "$1") } const v = a[f]; return g && !v ? u[d] = void 0 : u[d] = (v || "").replace(/%2F/g, "/"), u }, {}), pathname: o, pathnameBase: s, pattern: e } } function Z1(e, t, n) { t === void 0 && (t = !1), n === void 0 && (n = !0), sr(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".')); let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (s, a, l) => (r.push({ paramName: a, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")); return e.endsWith("*") ? (r.push({ paramName: "*" }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r] } function J1(e) { try { return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/") } catch (t) { return sr(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e } } function Lt(e, t) { if (t === "/") return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && r !== "/" ? null : e.slice(n) || "/" } function q1(e, t) { t === void 0 && (t = "/"); let { pathname: n, search: r = "", hash: i = "" } = typeof e == "string" ? Ot(e) : e; return { pathname: n ? n.startsWith("/") ? n : ew(n, t) : t, search: nw(r), hash: rw(i) } } function ew(e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach(i => { i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i) }), n.length > 1 ? n.join("/") : "/" } function Qa(e, t, n, r) { return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function ag(e) { return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0) } function yc(e, t) { let n = ag(e); return t ? n.map((r, i) => i === e.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase) } function wc(e, t, n, r) { r === void 0 && (r = !1); let i; typeof e == "string" ? i = Ot(e) : (i = se({}, e), H(!i.pathname || !i.pathname.includes("?"), Qa("?", "pathname", "search", i)), H(!i.pathname || !i.pathname.includes("#"), Qa("#", "pathname", "hash", i)), H(!i.search || !i.search.includes("#"), Qa("#", "search", "hash", i))); let o = e === "" || i.pathname === "", s = o ? "/" : i.pathname, a; if (s == null) a = n; else { let f = t.length - 1; if (!r && s.startsWith("..")) { let d = s.split("/"); for (; d[0] === "..";)d.shift(), f -= 1; i.pathname = d.join("/") } a = f >= 0 ? t[f] : "/" } let l = q1(i, a), u = s && s !== "/" && s.endsWith("/"), c = (o || s === ".") && n.endsWith("/"); return !l.pathname.endsWith("/") && (u || c) && (l.pathname += "/"), l } const Ft = e => e.join("/").replace(/\/\/+/g, "/"), tw = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), nw = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, rw = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, ra = function (t, n) { n === void 0 && (n = 302); let r = n; typeof r == "number" ? r = { status: r } : typeof r.status > "u" && (r.status = 302); let i = new Headers(r.headers); return i.set("Location", t), new Response(null, se({}, r, { headers: i })) }; class xc { constructor(t, n, r, i) { i === void 0 && (i = !1), this.status = t, this.statusText = n || "", this.internal = i, r instanceof Error ? (this.data = r.toString(), this.error = r) : this.data = r } } function lg(e) { return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e } const ug = ["post", "put", "patch", "delete"], iw = new Set(ug), ow = ["get", ...ug], sw = new Set(ow), aw = new Set([301, 302, 303, 307, 308]), lw = new Set([307, 308]), Ya = { state: "idle", location: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 }, cg = { state: "idle", data: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 }, ci = { state: "unblocked", proceed: void 0, reset: void 0, location: void 0 }, fg = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, uw = e => ({ hasErrorBoundary: !!e.hasErrorBoundary }), dg = "remix-router-transitions"; function cw(e) { const t = e.window ? e.window : typeof window < "u" ? window : void 0, n = typeof t < "u" && typeof t.document < "u" && typeof t.document.createElement < "u", r = !n; H(e.routes.length > 0, "You must provide a non-empty routes array to createRouter"); let i; if (e.mapRouteProperties) i = e.mapRouteProperties; else if (e.detectErrorBoundary) { let C = e.detectErrorBoundary; i = E => ({ hasErrorBoundary: C(E) }) } else i = uw; let o = {}, s = su(e.routes, i, void 0, o), a, l = e.basename || "/", u = se({ v7_fetcherPersist: !1, v7_normalizeFormMethod: !1, v7_partialHydration: !1, v7_prependBasename: !1, v7_relativeSplatPath: !1 }, e.future), c = null, f = new Set, d = null, g = null, v = null, y = e.hydrationData != null, S = kr(s, e.history.location, l), p = null; if (S == null) { let C = ct(404, { pathname: e.history.location.pathname }), { matches: E, route: L } = Md(s); S = E, p = { [L.id]: C } } let h, m = S.some(C => C.route.lazy), P = S.some(C => C.route.loader); if (m) h = !1; else if (!P) h = !0; else if (u.v7_partialHydration) { let C = e.hydrationData ? e.hydrationData.loaderData : null, E = e.hydrationData ? e.hydrationData.errors : null, L = A => A.route.loader ? A.route.loader.hydrate === !0 ? !1 : C && C[A.route.id] !== void 0 || E && E[A.route.id] !== void 0 : !0; if (E) { let A = S.findIndex(_ => E[_.route.id] !== void 0); h = S.slice(0, A + 1).every(L) } else h = S.every(L) } else h = e.hydrationData != null; let R, w = { historyAction: e.history.action, location: e.history.location, matches: S, initialized: h, navigation: Ya, restoreScrollPosition: e.hydrationData != null ? !1 : null, preventScrollReset: !1, revalidation: "idle", loaderData: e.hydrationData && e.hydrationData.loaderData || {}, actionData: e.hydrationData && e.hydrationData.actionData || null, errors: e.hydrationData && e.hydrationData.errors || p, fetchers: new Map, blockers: new Map }, D = ve.Pop, k = !1, j, V = !1, W = new Map, fe = null, de = !1, Be = !1, he = [], Ce = [], J = new Map, N = 0, U = -1, b = new Map, Y = new Set, ne = new Map, Dt = new Map, Le = new Set, vt = new Map, be = new Map, en = !1; function ry() { if (c = e.history.listen(C => { let { action: E, location: L, delta: A } = C; if (en) { en = !1; return } sr(be.size === 0 || A != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."); let _ = df({ currentLocation: w.location, nextLocation: L, historyAction: E }); if (_ && A != null) { en = !0, e.history.go(A * -1), Eo(_, { state: "blocked", location: L, proceed() { Eo(_, { state: "proceeding", proceed: void 0, reset: void 0, location: L }), e.history.go(A) }, reset() { let K = new Map(w.blockers); K.set(_, ci), Je({ blockers: K }) } }); return } return In(E, L) }), n) { Sw(t, W); let C = () => Cw(t, W); t.addEventListener("pagehide", C), fe = () => t.removeEventListener("pagehide", C) } return w.initialized || In(ve.Pop, w.location, { initialHydration: !0 }), R } function iy() { c && c(), fe && fe(), f.clear(), j && j.abort(), w.fetchers.forEach((C, E) => Po(E)), w.blockers.forEach((C, E) => ff(E)) } function oy(C) { return f.add(C), () => f.delete(C) } function Je(C, E) { E === void 0 && (E = {}), w = se({}, w, C); let L = [], A = []; u.v7_fetcherPersist && w.fetchers.forEach((_, K) => { _.state === "idle" && (Le.has(K) ? A.push(K) : L.push(K)) }), [...f].forEach(_ => _(w, { deletedFetchers: A, unstable_viewTransitionOpts: E.viewTransitionOpts, unstable_flushSync: E.flushSync === !0 })), u.v7_fetcherPersist && (L.forEach(_ => w.fetchers.delete(_)), A.forEach(_ => Po(_))) } function Jr(C, E, L) { var A, _; let { flushSync: K } = L === void 0 ? {} : L, B = w.actionData != null && w.navigation.formMethod != null && St(w.navigation.formMethod) && w.navigation.state === "loading" && ((A = C.state) == null ? void 0 : A._isRedirect) !== !0, z; E.actionData ? Object.keys(E.actionData).length > 0 ? z = E.actionData : z = null : B ? z = w.actionData : z = null; let O = E.loaderData ? Dd(w.loaderData, E.loaderData, E.matches || [], E.errors) : w.loaderData, G = w.blockers; G.size > 0 && (G = new Map(G), G.forEach((ee, De) => G.set(De, ci))); let Pe = k === !0 || w.navigation.formMethod != null && St(w.navigation.formMethod) && ((_ = C.state) == null ? void 0 : _._isRedirect) !== !0; a && (s = a, a = void 0), de || D === ve.Pop || (D === ve.Push ? e.history.push(C, C.state) : D === ve.Replace && e.history.replace(C, C.state)); let $; if (D === ve.Pop) { let ee = W.get(w.location.pathname); ee && ee.has(C.pathname) ? $ = { currentLocation: w.location, nextLocation: C } : W.has(C.pathname) && ($ = { currentLocation: C, nextLocation: w.location }) } else if (V) { let ee = W.get(w.location.pathname); ee ? ee.add(C.pathname) : (ee = new Set([C.pathname]), W.set(w.location.pathname, ee)), $ = { currentLocation: w.location, nextLocation: C } } Je(se({}, E, { actionData: z, loaderData: O, historyAction: D, location: C, initialized: !0, navigation: Ya, revalidation: "idle", restoreScrollPosition: pf(C, E.matches || w.matches), preventScrollReset: Pe, blockers: G }), { viewTransitionOpts: $, flushSync: K === !0 }), D = ve.Pop, k = !1, V = !1, de = !1, Be = !1, he = [], Ce = [] } async function of(C, E) { if (typeof C == "number") { e.history.go(C); return } let L = lu(w.location, w.matches, l, u.v7_prependBasename, C, u.v7_relativeSplatPath, E == null ? void 0 : E.fromRouteId, E == null ? void 0 : E.relative), { path: A, submission: _, error: K } = Pd(u.v7_normalizeFormMethod, !1, L, E), B = w.location, z = to(w.location, A, E && E.state); z = se({}, z, e.history.encodeLocation(z)); let O = E && E.replace != null ? E.replace : void 0, G = ve.Push; O === !0 ? G = ve.Replace : O === !1 || _ != null && St(_.formMethod) && _.formAction === w.location.pathname + w.location.search && (G = ve.Replace); let Pe = E && "preventScrollReset" in E ? E.preventScrollReset === !0 : void 0, $ = (E && E.unstable_flushSync) === !0, ee = df({ currentLocation: B, nextLocation: z, historyAction: G }); if (ee) { Eo(ee, { state: "blocked", location: z, proceed() { Eo(ee, { state: "proceeding", proceed: void 0, reset: void 0, location: z }), of(C, E) }, reset() { let De = new Map(w.blockers); De.set(ee, ci), Je({ blockers: De }) } }); return } return await In(G, z, { submission: _, pendingError: K, preventScrollReset: Pe, replace: E && E.replace, enableViewTransition: E && E.unstable_viewTransition, flushSync: $ }) } function sy() { if (ya(), Je({ revalidation: "loading" }), w.navigation.state !== "submitting") { if (w.navigation.state === "idle") { In(w.historyAction, w.location, { startUninterruptedRevalidation: !0 }); return } In(D || w.historyAction, w.navigation.location, { overrideNavigation: w.navigation }) } } async function In(C, E, L) { j && j.abort(), j = null, D = C, de = (L && L.startUninterruptedRevalidation) === !0, my(w.location, w.matches), k = (L && L.preventScrollReset) === !0, V = (L && L.enableViewTransition) === !0; let A = a || s, _ = L && L.overrideNavigation, K = kr(A, E, l), B = (L && L.flushSync) === !0; if (!K) { let De = ct(404, { pathname: E.pathname }), { matches: qe, route: Ee } = Md(A); wa(), Jr(E, { matches: qe, loaderData: {}, errors: { [Ee.id]: De } }, { flushSync: B }); return } if (w.initialized && !Be && mw(w.location, E) && !(L && L.submission && St(L.submission.formMethod))) { Jr(E, { matches: K }, { flushSync: B }); return } j = new AbortController; let z = di(e.history, E, j.signal, L && L.submission), O, G; if (L && L.pendingError) G = { [ji(K).route.id]: L.pendingError }; else if (L && L.submission && St(L.submission.formMethod)) { let De = await ay(z, E, L.submission, K, { replace: L.replace, flushSync: B }); if (De.shortCircuited) return; O = De.pendingActionData, G = De.pendingActionError, _ = Xa(E, L.submission), B = !1, z = new Request(z.url, { signal: z.signal }) } let { shortCircuited: Pe, loaderData: $, errors: ee } = await ly(z, E, K, _, L && L.submission, L && L.fetcherSubmission, L && L.replace, L && L.initialHydration === !0, B, O, G); Pe || (j = null, Jr(E, se({ matches: K }, O ? { actionData: O } : {}, { loaderData: $, errors: ee }))) } async function ay(C, E, L, A, _) { _ === void 0 && (_ = {}), ya(); let K = ww(E, L); Je({ navigation: K }, { flushSync: _.flushSync === !0 }); let B, z = cu(A, E); if (!z.route.action && !z.route.lazy) B = { type: pe.error, error: ct(405, { method: C.method, pathname: E.pathname, routeId: z.route.id }) }; else if (B = await fi("action", C, z, A, o, i, l, u.v7_relativeSplatPath), C.signal.aborted) return { shortCircuited: !0 }; if (Xn(B)) { let O; return _ && _.replace != null ? O = _.replace : O = B.location === w.location.pathname + w.location.search, await qr(w, B, { submission: L, replace: O }), { shortCircuited: !0 } } if (Rr(B)) { let O = ji(A, z.route.id); return (_ && _.replace) !== !0 && (D = ve.Push), { pendingActionData: {}, pendingActionError: { [O.route.id]: B.error } } } if (Yn(B)) throw ct(400, { type: "defer-action" }); return { pendingActionData: { [z.route.id]: B.data } } } async function ly(C, E, L, A, _, K, B, z, O, G, Pe) { let $ = A || Xa(E, _), ee = _ || K || Nd($), De = a || s, [qe, Ee] = Ed(e.history, w, L, ee, E, u.v7_partialHydration && z === !0, Be, he, Ce, Le, ne, Y, De, l, G, Pe); if (wa(X => !(L && L.some(q => q.route.id === X)) || qe && qe.some(q => q.route.id === X)), U = ++N, qe.length === 0 && Ee.length === 0) { let X = uf(); return Jr(E, se({ matches: L, loaderData: {}, errors: Pe || null }, G ? { actionData: G } : {}, X ? { fetchers: new Map(w.fetchers) } : {}), { flushSync: O }), { shortCircuited: !0 } } if (!de && (!u.v7_partialHydration || !z)) { Ee.forEach(q => { let Ke = w.fetchers.get(q.key), ko = hi(void 0, Ke ? Ke.data : void 0); w.fetchers.set(q.key, ko) }); let X = G || w.actionData; Je(se({ navigation: $ }, X ? Object.keys(X).length === 0 ? { actionData: null } : { actionData: X } : {}, Ee.length > 0 ? { fetchers: new Map(w.fetchers) } : {}), { flushSync: O }) } Ee.forEach(X => { J.has(X.key) && nn(X.key), X.controller && J.set(X.key, X.controller) }); let cr = () => Ee.forEach(X => nn(X.key)); j && j.signal.addEventListener("abort", cr); let { results: xa, loaderResults: fr, fetcherResults: rn } = await sf(w.matches, L, qe, Ee, C); if (C.signal.aborted) return { shortCircuited: !0 }; j && j.signal.removeEventListener("abort", cr), Ee.forEach(X => J.delete(X.key)); let zn = Ad(xa); if (zn) { if (zn.idx >= qe.length) { let X = Ee[zn.idx - qe.length].key; Y.add(X) } return await qr(w, zn.result, { replace: B }), { shortCircuited: !0 } } let { loaderData: Sa, errors: ti } = Ld(w, L, qe, fr, Pe, Ee, rn, vt); vt.forEach((X, q) => { X.subscribe(Ke => { (Ke || X.done) && vt.delete(q) }) }), u.v7_partialHydration && z && w.errors && Object.entries(w.errors).filter(X => { let [q] = X; return !qe.some(Ke => Ke.route.id === q) }).forEach(X => { let [q, Ke] = X; ti = Object.assign(ti || {}, { [q]: Ke }) }); let Ca = uf(), dr = cf(U), To = Ca || dr || Ee.length > 0; return se({ loaderData: Sa, errors: ti }, To ? { fetchers: new Map(w.fetchers) } : {}) } function uy(C, E, L, A) { if (r) throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback."); J.has(C) && nn(C); let _ = (A && A.unstable_flushSync) === !0, K = a || s, B = lu(w.location, w.matches, l, u.v7_prependBasename, L, u.v7_relativeSplatPath, E, A == null ? void 0 : A.relative), z = kr(K, B, l); if (!z) { ei(C, E, ct(404, { pathname: B }), { flushSync: _ }); return } let { path: O, submission: G, error: Pe } = Pd(u.v7_normalizeFormMethod, !0, B, A); if (Pe) { ei(C, E, Pe, { flushSync: _ }); return } let $ = cu(z, O); if (k = (A && A.preventScrollReset) === !0, G && St(G.formMethod)) { cy(C, E, O, $, z, _, G); return } ne.set(C, { routeId: E, path: O }), fy(C, E, O, $, z, _, G) } async function cy(C, E, L, A, _, K, B) { if (ya(), ne.delete(C), !A.route.action && !A.route.lazy) { let q = ct(405, { method: B.formMethod, pathname: L, routeId: E }); ei(C, E, q, { flushSync: K }); return } let z = w.fetchers.get(C); tn(C, xw(B, z), { flushSync: K }); let O = new AbortController, G = di(e.history, L, O.signal, B); J.set(C, O); let Pe = N, $ = await fi("action", G, A, _, o, i, l, u.v7_relativeSplatPath); if (G.signal.aborted) { J.get(C) === O && J.delete(C); return } if (u.v7_fetcherPersist && Le.has(C)) { if (Xn($) || Rr($)) { tn(C, sn(void 0)); return } } else { if (Xn($)) if (J.delete(C), U > Pe) { tn(C, sn(void 0)); return } else return Y.add(C), tn(C, hi(B)), qr(w, $, { fetcherSubmission: B }); if (Rr($)) { ei(C, E, $.error); return } } if (Yn($)) throw ct(400, { type: "defer-action" }); let ee = w.navigation.location || w.location, De = di(e.history, ee, O.signal), qe = a || s, Ee = w.navigation.state !== "idle" ? kr(qe, w.navigation.location, l) : w.matches; H(Ee, "Didn't find any matches after fetcher action"); let cr = ++N; b.set(C, cr); let xa = hi(B, $.data); w.fetchers.set(C, xa); let [fr, rn] = Ed(e.history, w, Ee, B, ee, !1, Be, he, Ce, Le, ne, Y, qe, l, { [A.route.id]: $.data }, void 0); rn.filter(q => q.key !== C).forEach(q => { let Ke = q.key, ko = w.fetchers.get(Ke), vy = hi(void 0, ko ? ko.data : void 0); w.fetchers.set(Ke, vy), J.has(Ke) && nn(Ke), q.controller && J.set(Ke, q.controller) }), Je({ fetchers: new Map(w.fetchers) }); let zn = () => rn.forEach(q => nn(q.key)); O.signal.addEventListener("abort", zn); let { results: Sa, loaderResults: ti, fetcherResults: Ca } = await sf(w.matches, Ee, fr, rn, De); if (O.signal.aborted) return; O.signal.removeEventListener("abort", zn), b.delete(C), J.delete(C), rn.forEach(q => J.delete(q.key)); let dr = Ad(Sa); if (dr) { if (dr.idx >= fr.length) { let q = rn[dr.idx - fr.length].key; Y.add(q) } return qr(w, dr.result) } let { loaderData: To, errors: X } = Ld(w, w.matches, fr, ti, void 0, rn, Ca, vt); if (w.fetchers.has(C)) { let q = sn($.data); w.fetchers.set(C, q) } cf(cr), w.navigation.state === "loading" && cr > U ? (H(D, "Expected pending action"), j && j.abort(), Jr(w.navigation.location, { matches: Ee, loaderData: To, errors: X, fetchers: new Map(w.fetchers) })) : (Je({ errors: X, loaderData: Dd(w.loaderData, To, Ee, X), fetchers: new Map(w.fetchers) }), Be = !1) } async function fy(C, E, L, A, _, K, B) { let z = w.fetchers.get(C); tn(C, hi(B, z ? z.data : void 0), { flushSync: K }); let O = new AbortController, G = di(e.history, L, O.signal); J.set(C, O); let Pe = N, $ = await fi("loader", G, A, _, o, i, l, u.v7_relativeSplatPath); if (Yn($) && ($ = await mg($, G.signal, !0) || $), J.get(C) === O && J.delete(C), !G.signal.aborted) { if (Le.has(C)) { tn(C, sn(void 0)); return } if (Xn($)) if (U > Pe) { tn(C, sn(void 0)); return } else { Y.add(C), await qr(w, $); return } if (Rr($)) { ei(C, E, $.error); return } H(!Yn($), "Unhandled fetcher deferred data"), tn(C, sn($.data)) } } async function qr(C, E, L) { let { submission: A, fetcherSubmission: _, replace: K } = L === void 0 ? {} : L; E.revalidate && (Be = !0); let B = to(C.location, E.location, { _isRedirect: !0 }); if (H(B, "Expected a location on the redirect navigation"), n) { let ee = !1; if (E.reloadDocument) ee = !0; else if (fg.test(E.location)) { const De = e.history.createURL(E.location); ee = De.origin !== t.location.origin || Lt(De.pathname, l) == null } if (ee) { K ? t.location.replace(E.location) : t.location.assign(E.location); return } } j = null; let z = K === !0 ? ve.Replace : ve.Push, { formMethod: O, formAction: G, formEncType: Pe } = C.navigation; !A && !_ && O && G && Pe && (A = Nd(C.navigation)); let $ = A || _; if (lw.has(E.status) && $ && St($.formMethod)) await In(z, B, { submission: se({}, $, { formAction: E.location }), preventScrollReset: k }); else { let ee = Xa(B, A); await In(z, B, { overrideNavigation: ee, fetcherSubmission: _, preventScrollReset: k }) } } async function sf(C, E, L, A, _) { let K = await Promise.all([...L.map(O => fi("loader", _, O, E, o, i, l, u.v7_relativeSplatPath)), ...A.map(O => O.matches && O.match && O.controller ? fi("loader", di(e.history, O.path, O.controller.signal), O.match, O.matches, o, i, l, u.v7_relativeSplatPath) : { type: pe.error, error: ct(404, { pathname: O.path }) })]), B = K.slice(0, L.length), z = K.slice(L.length); return await Promise.all([jd(C, L, B, B.map(() => _.signal), !1, w.loaderData), jd(C, A.map(O => O.match), z, A.map(O => O.controller ? O.controller.signal : null), !0)]), { results: K, loaderResults: B, fetcherResults: z } } function ya() { Be = !0, he.push(...wa()), ne.forEach((C, E) => { J.has(E) && (Ce.push(E), nn(E)) }) } function tn(C, E, L) { L === void 0 && (L = {}), w.fetchers.set(C, E), Je({ fetchers: new Map(w.fetchers) }, { flushSync: (L && L.flushSync) === !0 }) } function ei(C, E, L, A) { A === void 0 && (A = {}); let _ = ji(w.matches, E); Po(C), Je({ errors: { [_.route.id]: L }, fetchers: new Map(w.fetchers) }, { flushSync: (A && A.flushSync) === !0 }) } function af(C) { return u.v7_fetcherPersist && (Dt.set(C, (Dt.get(C) || 0) + 1), Le.has(C) && Le.delete(C)), w.fetchers.get(C) || cg } function Po(C) { let E = w.fetchers.get(C); J.has(C) && !(E && E.state === "loading" && b.has(C)) && nn(C), ne.delete(C), b.delete(C), Y.delete(C), Le.delete(C), w.fetchers.delete(C) } function dy(C) { if (u.v7_fetcherPersist) { let E = (Dt.get(C) || 0) - 1; E <= 0 ? (Dt.delete(C), Le.add(C)) : Dt.set(C, E) } else Po(C); Je({ fetchers: new Map(w.fetchers) }) } function nn(C) { let E = J.get(C); H(E, "Expected fetch controller: " + C), E.abort(), J.delete(C) } function lf(C) { for (let E of C) { let L = af(E), A = sn(L.data); w.fetchers.set(E, A) } } function uf() { let C = [], E = !1; for (let L of Y) { let A = w.fetchers.get(L); H(A, "Expected fetcher: " + L), A.state === "loading" && (Y.delete(L), C.push(L), E = !0) } return lf(C), E } function cf(C) { let E = []; for (let [L, A] of b) if (A < C) { let _ = w.fetchers.get(L); H(_, "Expected fetcher: " + L), _.state === "loading" && (nn(L), b.delete(L), E.push(L)) } return lf(E), E.length > 0 } function hy(C, E) { let L = w.blockers.get(C) || ci; return be.get(C) !== E && be.set(C, E), L } function ff(C) { w.blockers.delete(C), be.delete(C) } function Eo(C, E) { let L = w.blockers.get(C) || ci; H(L.state === "unblocked" && E.state === "blocked" || L.state === "blocked" && E.state === "blocked" || L.state === "blocked" && E.state === "proceeding" || L.state === "blocked" && E.state === "unblocked" || L.state === "proceeding" && E.state === "unblocked", "Invalid blocker state transition: " + L.state + " -> " + E.state); let A = new Map(w.blockers); A.set(C, E), Je({ blockers: A }) } function df(C) { let { currentLocation: E, nextLocation: L, historyAction: A } = C; if (be.size === 0) return; be.size > 1 && sr(!1, "A router only supports one blocker at a time"); let _ = Array.from(be.entries()), [K, B] = _[_.length - 1], z = w.blockers.get(K); if (!(z && z.state === "proceeding") && B({ currentLocation: E, nextLocation: L, historyAction: A })) return K } function wa(C) { let E = []; return vt.forEach((L, A) => { (!C || C(A)) && (L.cancel(), E.push(A), vt.delete(A)) }), E } function py(C, E, L) { if (d = C, v = E, g = L || null, !y && w.navigation === Ya) { y = !0; let A = pf(w.location, w.matches); A != null && Je({ restoreScrollPosition: A }) } return () => { d = null, v = null, g = null } } function hf(C, E) { return g && g(C, E.map(A => U1(A, w.loaderData))) || C.key } function my(C, E) { if (d && v) { let L = hf(C, E); d[L] = v() } } function pf(C, E) { if (d) { let L = hf(C, E), A = d[L]; if (typeof A == "number") return A } return null } function gy(C) { o = {}, a = su(C, i, void 0, o) } return R = { get basename() { return l }, get future() { return u }, get state() { return w }, get routes() { return s }, get window() { return t }, initialize: ry, subscribe: oy, enableScrollRestoration: py, navigate: of, fetch: uy, revalidate: sy, createHref: C => e.history.createHref(C), encodeLocation: C => e.history.encodeLocation(C), getFetcher: af, deleteFetcher: dy, dispose: iy, getBlocker: hy, deleteBlocker: ff, _internalFetchControllers: J, _internalActiveDeferreds: vt, _internalSetRoutes: gy }, R } function fw(e) { return e != null && ("formData" in e && e.formData != null || "body" in e && e.body !== void 0) } function lu(e, t, n, r, i, o, s, a) { let l, u; if (s) { l = []; for (let f of t) if (l.push(f), f.route.id === s) { u = f; break } } else l = t, u = t[t.length - 1]; let c = wc(i || ".", yc(l, o), Lt(e.pathname, n) || e.pathname, a === "path"); return i == null && (c.search = e.search, c.hash = e.hash), (i == null || i === "" || i === ".") && u && u.route.index && !Sc(c.search) && (c.search = c.search ? c.search.replace(/^\?/, "?index&") : "?index"), r && n !== "/" && (c.pathname = c.pathname === "/" ? n : Ft([n, c.pathname])), Rn(c) } function Pd(e, t, n, r) {
  if (!r || !fw(r)) return { path: n }; if (r.formMethod && !yw(r.formMethod)) return { path: n, error: ct(405, { method: r.formMethod }) }; let i = () => ({ path: n, error: ct(400, { type: "invalid-body" }) }), o = r.formMethod || "get", s = e ? o.toUpperCase() : o.toLowerCase(), a = pg(n); if (r.body !== void 0) {
    if (r.formEncType === "text/plain") {
      if (!St(s)) return i(); let d = typeof r.body == "string" ? r.body : r.body instanceof FormData || r.body instanceof URLSearchParams ? Array.from(r.body.entries()).reduce((g, v) => {
        let [y, S] = v; return "" + g + y + "=" + S + `
`}, "") : String(r.body); return { path: n, submission: { formMethod: s, formAction: a, formEncType: r.formEncType, formData: void 0, json: void 0, text: d } }
    } else if (r.formEncType === "application/json") { if (!St(s)) return i(); try { let d = typeof r.body == "string" ? JSON.parse(r.body) : r.body; return { path: n, submission: { formMethod: s, formAction: a, formEncType: r.formEncType, formData: void 0, json: d, text: void 0 } } } catch { return i() } }
  } H(typeof FormData == "function", "FormData is not available in this environment"); let l, u; if (r.formData) l = uu(r.formData), u = r.formData; else if (r.body instanceof FormData) l = uu(r.body), u = r.body; else if (r.body instanceof URLSearchParams) l = r.body, u = Rd(l); else if (r.body == null) l = new URLSearchParams, u = new FormData; else try { l = new URLSearchParams(r.body), u = Rd(l) } catch { return i() } let c = { formMethod: s, formAction: a, formEncType: r && r.formEncType || "application/x-www-form-urlencoded", formData: u, json: void 0, text: void 0 }; if (St(c.formMethod)) return { path: n, submission: c }; let f = Ot(n); return t && f.search && Sc(f.search) && l.append("index", ""), f.search = "?" + l, { path: Rn(f), submission: c }
} function dw(e, t) { let n = e; if (t) { let r = e.findIndex(i => i.route.id === t); r >= 0 && (n = e.slice(0, r)) } return n } function Ed(e, t, n, r, i, o, s, a, l, u, c, f, d, g, v, y) { let S = y ? Object.values(y)[0] : v ? Object.values(v)[0] : void 0, p = e.createURL(t.location), h = e.createURL(i), m = y ? Object.keys(y)[0] : void 0, R = dw(n, m).filter((D, k) => { let { route: j } = D; if (j.lazy) return !0; if (j.loader == null) return !1; if (o) return j.loader.hydrate ? !0 : t.loaderData[j.id] === void 0 && (!t.errors || t.errors[j.id] === void 0); if (hw(t.loaderData, t.matches[k], D) || a.some(fe => fe === D.route.id)) return !0; let V = t.matches[k], W = D; return Td(D, se({ currentUrl: p, currentParams: V.params, nextUrl: h, nextParams: W.params }, r, { actionResult: S, defaultShouldRevalidate: s || p.pathname + p.search === h.pathname + h.search || p.search !== h.search || hg(V, W) })) }), w = []; return c.forEach((D, k) => { if (o || !n.some(de => de.route.id === D.routeId) || u.has(k)) return; let j = kr(d, D.path, g); if (!j) { w.push({ key: k, routeId: D.routeId, path: D.path, matches: null, match: null, controller: null }); return } let V = t.fetchers.get(k), W = cu(j, D.path), fe = !1; f.has(k) ? fe = !1 : l.includes(k) ? fe = !0 : V && V.state !== "idle" && V.data === void 0 ? fe = s : fe = Td(W, se({ currentUrl: p, currentParams: t.matches[t.matches.length - 1].params, nextUrl: h, nextParams: n[n.length - 1].params }, r, { actionResult: S, defaultShouldRevalidate: s })), fe && w.push({ key: k, routeId: D.routeId, path: D.path, matches: j, match: W, controller: new AbortController }) }), [R, w] } function hw(e, t, n) { let r = !t || n.route.id !== t.route.id, i = e[n.route.id] === void 0; return r || i } function hg(e, t) { let n = e.route.path; return e.pathname !== t.pathname || n != null && n.endsWith("*") && e.params["*"] !== t.params["*"] } function Td(e, t) { if (e.route.shouldRevalidate) { let n = e.route.shouldRevalidate(t); if (typeof n == "boolean") return n } return t.defaultShouldRevalidate } async function kd(e, t, n) { if (!e.lazy) return; let r = await e.lazy(); if (!e.lazy) return; let i = n[e.id]; H(i, "No route found in manifest"); let o = {}; for (let s in r) { let l = i[s] !== void 0 && s !== "hasErrorBoundary"; sr(!l, 'Route "' + i.id + '" has a static property "' + s + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + s + '" will be ignored.')), !l && !I1.has(s) && (o[s] = r[s]) } Object.assign(i, o), Object.assign(i, se({}, t(i), { lazy: void 0 })) } async function fi(e, t, n, r, i, o, s, a, l) { l === void 0 && (l = {}); let u, c, f, d = y => { let S, p = new Promise((h, m) => S = m); return f = () => S(), t.signal.addEventListener("abort", f), Promise.race([y({ request: t, params: n.params, context: l.requestContext }), p]) }; try { let y = n.route[e]; if (n.route.lazy) if (y) { let S, p = await Promise.all([d(y).catch(h => { S = h }), kd(n.route, o, i)]); if (S) throw S; c = p[0] } else if (await kd(n.route, o, i), y = n.route[e], y) c = await d(y); else if (e === "action") { let S = new URL(t.url), p = S.pathname + S.search; throw ct(405, { method: t.method, pathname: p, routeId: n.route.id }) } else return { type: pe.data, data: void 0 }; else if (y) c = await d(y); else { let S = new URL(t.url), p = S.pathname + S.search; throw ct(404, { pathname: p }) } H(c !== void 0, "You defined " + (e === "action" ? "an action" : "a loader") + " for route " + ('"' + n.route.id + "\" but didn't return anything from your `" + e + "` ") + "function. Please return a value or `null`.") } catch (y) { u = pe.error, c = y } finally { f && t.signal.removeEventListener("abort", f) } if (vw(c)) { let y = c.status; if (aw.has(y)) { let p = c.headers.get("Location"); if (H(p, "Redirects returned/thrown from loaders/actions must have a Location header"), !fg.test(p)) p = lu(new URL(t.url), r.slice(0, r.indexOf(n) + 1), s, !0, p, a); else if (!l.isStaticRequest) { let h = new URL(t.url), m = p.startsWith("//") ? new URL(h.protocol + p) : new URL(p), P = Lt(m.pathname, s) != null; m.origin === h.origin && P && (p = m.pathname + m.search + m.hash) } if (l.isStaticRequest) throw c.headers.set("Location", p), c; return { type: pe.redirect, status: y, location: p, revalidate: c.headers.get("X-Remix-Revalidate") !== null, reloadDocument: c.headers.get("X-Remix-Reload-Document") !== null } } if (l.isRouteRequest) throw { type: u === pe.error ? pe.error : pe.data, response: c }; let S; try { let p = c.headers.get("Content-Type"); p && /\bapplication\/json\b/.test(p) ? c.body == null ? S = null : S = await c.json() : S = await c.text() } catch (p) { return { type: pe.error, error: p } } return u === pe.error ? { type: u, error: new xc(y, c.statusText, S), headers: c.headers } : { type: pe.data, data: S, statusCode: c.status, headers: c.headers } } if (u === pe.error) return { type: u, error: c }; if (gw(c)) { var g, v; return { type: pe.deferred, deferredData: c, statusCode: (g = c.init) == null ? void 0 : g.status, headers: ((v = c.init) == null ? void 0 : v.headers) && new Headers(c.init.headers) } } return { type: pe.data, data: c } } function di(e, t, n, r) { let i = e.createURL(pg(t)).toString(), o = { signal: n }; if (r && St(r.formMethod)) { let { formMethod: s, formEncType: a } = r; o.method = s.toUpperCase(), a === "application/json" ? (o.headers = new Headers({ "Content-Type": a }), o.body = JSON.stringify(r.json)) : a === "text/plain" ? o.body = r.text : a === "application/x-www-form-urlencoded" && r.formData ? o.body = uu(r.formData) : o.body = r.formData } return new Request(i, o) } function uu(e) { let t = new URLSearchParams; for (let [n, r] of e.entries()) t.append(n, typeof r == "string" ? r : r.name); return t } function Rd(e) { let t = new FormData; for (let [n, r] of e.entries()) t.append(n, r); return t } function pw(e, t, n, r, i) { let o = {}, s = null, a, l = !1, u = {}; return n.forEach((c, f) => { let d = t[f].route.id; if (H(!Xn(c), "Cannot handle redirect results in processLoaderData"), Rr(c)) { let g = ji(e, d), v = c.error; r && (v = Object.values(r)[0], r = void 0), s = s || {}, s[g.route.id] == null && (s[g.route.id] = v), o[d] = void 0, l || (l = !0, a = lg(c.error) ? c.error.status : 500), c.headers && (u[d] = c.headers) } else Yn(c) ? (i.set(d, c.deferredData), o[d] = c.deferredData.data) : o[d] = c.data, c.statusCode != null && c.statusCode !== 200 && !l && (a = c.statusCode), c.headers && (u[d] = c.headers) }), r && (s = r, o[Object.keys(r)[0]] = void 0), { loaderData: o, errors: s, statusCode: a || 200, loaderHeaders: u } } function Ld(e, t, n, r, i, o, s, a) { let { loaderData: l, errors: u } = pw(t, n, r, i, a); for (let c = 0; c < o.length; c++) { let { key: f, match: d, controller: g } = o[c]; H(s !== void 0 && s[c] !== void 0, "Did not find corresponding fetcher result"); let v = s[c]; if (!(g && g.signal.aborted)) if (Rr(v)) { let y = ji(e.matches, d == null ? void 0 : d.route.id); u && u[y.route.id] || (u = se({}, u, { [y.route.id]: v.error })), e.fetchers.delete(f) } else if (Xn(v)) H(!1, "Unhandled fetcher revalidation redirect"); else if (Yn(v)) H(!1, "Unhandled fetcher deferred data"); else { let y = sn(v.data); e.fetchers.set(f, y) } } return { loaderData: l, errors: u } } function Dd(e, t, n, r) { let i = se({}, t); for (let o of n) { let s = o.route.id; if (t.hasOwnProperty(s) ? t[s] !== void 0 && (i[s] = t[s]) : e[s] !== void 0 && o.route.loader && (i[s] = e[s]), r && r.hasOwnProperty(s)) break } return i } function ji(e, t) { return (t ? e.slice(0, e.findIndex(r => r.route.id === t) + 1) : [...e]).reverse().find(r => r.route.hasErrorBoundary === !0) || e[0] } function Md(e) { let t = e.length === 1 ? e[0] : e.find(n => n.index || !n.path || n.path === "/") || { id: "__shim-error-route__" }; return { matches: [{ params: {}, pathname: "", pathnameBase: "", route: t }], route: t } } function ct(e, t) { let { pathname: n, routeId: r, method: i, type: o } = t === void 0 ? {} : t, s = "Unknown Server Error", a = "Unknown @remix-run/router error"; return e === 400 ? (s = "Bad Request", i && n && r ? a = "You made a " + i + ' request to "' + n + '" but ' + ('did not provide a `loader` for route "' + r + '", ') + "so there is no way to handle the request." : o === "defer-action" ? a = "defer() is not supported in actions" : o === "invalid-body" && (a = "Unable to encode submission body")) : e === 403 ? (s = "Forbidden", a = 'Route "' + r + '" does not match URL "' + n + '"') : e === 404 ? (s = "Not Found", a = 'No route matches URL "' + n + '"') : e === 405 && (s = "Method Not Allowed", i && n && r ? a = "You made a " + i.toUpperCase() + ' request to "' + n + '" but ' + ('did not provide an `action` for route "' + r + '", ') + "so there is no way to handle the request." : i && (a = 'Invalid request method "' + i.toUpperCase() + '"')), new xc(e || 500, s, new Error(a), !0) } function Ad(e) { for (let t = e.length - 1; t >= 0; t--) { let n = e[t]; if (Xn(n)) return { result: n, idx: t } } } function pg(e) { let t = typeof e == "string" ? Ot(e) : e; return Rn(se({}, t, { hash: "" })) } function mw(e, t) { return e.pathname !== t.pathname || e.search !== t.search ? !1 : e.hash === "" ? t.hash !== "" : e.hash === t.hash ? !0 : t.hash !== "" } function Yn(e) { return e.type === pe.deferred } function Rr(e) { return e.type === pe.error } function Xn(e) { return (e && e.type) === pe.redirect } function gw(e) { let t = e; return t && typeof t == "object" && typeof t.data == "object" && typeof t.subscribe == "function" && typeof t.cancel == "function" && typeof t.resolveData == "function" } function vw(e) { return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.headers == "object" && typeof e.body < "u" } function yw(e) { return sw.has(e.toLowerCase()) } function St(e) { return iw.has(e.toLowerCase()) } async function jd(e, t, n, r, i, o) { for (let s = 0; s < n.length; s++) { let a = n[s], l = t[s]; if (!l) continue; let u = e.find(f => f.route.id === l.route.id), c = u != null && !hg(u, l) && (o && o[l.route.id]) !== void 0; if (Yn(a) && (i || c)) { let f = r[s]; H(f, "Expected an AbortSignal for revalidating fetcher deferred result"), await mg(a, f, i).then(d => { d && (n[s] = d || n[s]) }) } } } async function mg(e, t, n) { if (n === void 0 && (n = !1), !await e.deferredData.resolveData(t)) { if (n) try { return { type: pe.data, data: e.deferredData.unwrappedData } } catch (i) { return { type: pe.error, error: i } } return { type: pe.data, data: e.deferredData.data } } } function Sc(e) { return new URLSearchParams(e).getAll("index").some(t => t === "") } function cu(e, t) { let n = typeof t == "string" ? Ot(t).search : t.search; if (e[e.length - 1].route.index && Sc(n || "")) return e[e.length - 1]; let r = ag(e); return r[r.length - 1] } function Nd(e) { let { formMethod: t, formAction: n, formEncType: r, text: i, formData: o, json: s } = e; if (!(!t || !n || !r)) { if (i != null) return { formMethod: t, formAction: n, formEncType: r, formData: void 0, json: void 0, text: i }; if (o != null) return { formMethod: t, formAction: n, formEncType: r, formData: o, json: void 0, text: void 0 }; if (s !== void 0) return { formMethod: t, formAction: n, formEncType: r, formData: void 0, json: s, text: void 0 } } } function Xa(e, t) { return t ? { state: "loading", location: e, formMethod: t.formMethod, formAction: t.formAction, formEncType: t.formEncType, formData: t.formData, json: t.json, text: t.text } : { state: "loading", location: e, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 } } function ww(e, t) { return { state: "submitting", location: e, formMethod: t.formMethod, formAction: t.formAction, formEncType: t.formEncType, formData: t.formData, json: t.json, text: t.text } } function hi(e, t) { return e ? { state: "loading", formMethod: e.formMethod, formAction: e.formAction, formEncType: e.formEncType, formData: e.formData, json: e.json, text: e.text, data: t } : { state: "loading", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0, data: t } } function xw(e, t) { return { state: "submitting", formMethod: e.formMethod, formAction: e.formAction, formEncType: e.formEncType, formData: e.formData, json: e.json, text: e.text, data: t ? t.data : void 0 } } function sn(e) { return { state: "idle", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0, data: e } } function Sw(e, t) { try { let n = e.sessionStorage.getItem(dg); if (n) { let r = JSON.parse(n); for (let [i, o] of Object.entries(r || {})) o && Array.isArray(o) && t.set(i, new Set(o || [])) } } catch { } } function Cw(e, t) { if (t.size > 0) { let n = {}; for (let [r, i] of t) n[r] = [...i]; try { e.sessionStorage.setItem(dg, JSON.stringify(n)) } catch (r) { sr(!1, "Failed to save applied view transitions in sessionStorage (" + r + ").") } } }/**
 * React Router v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function no() { return no = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, no.apply(this, arguments) } const ho = x.createContext(null), ia = x.createContext(null), It = x.createContext(null), oa = x.createContext(null), zt = x.createContext({ outlet: null, matches: [], isDataRoute: !1 }), gg = x.createContext(null); function Pw(e, t) { let { relative: n } = t === void 0 ? {} : t; po() || H(!1); let { basename: r, navigator: i } = x.useContext(It), { hash: o, pathname: s, search: a } = mo(e, { relative: n }), l = s; return r !== "/" && (l = s === "/" ? r : Ft([r, s])), i.createHref({ pathname: l, search: a, hash: o }) } function po() { return x.useContext(oa) != null } function Xr() { return po() || H(!1), x.useContext(oa).location } function vg(e) { x.useContext(It).static || x.useLayoutEffect(e) } function Cc() { let { isDataRoute: e } = x.useContext(zt); return e ? Ow() : Ew() } function Ew() { po() || H(!1); let e = x.useContext(ho), { basename: t, future: n, navigator: r } = x.useContext(It), { matches: i } = x.useContext(zt), { pathname: o } = Xr(), s = JSON.stringify(yc(i, n.v7_relativeSplatPath)), a = x.useRef(!1); return vg(() => { a.current = !0 }), x.useCallback(function (u, c) { if (c === void 0 && (c = {}), !a.current) return; if (typeof u == "number") { r.go(u); return } let f = wc(u, JSON.parse(s), o, c.relative === "path"); e == null && t !== "/" && (f.pathname = f.pathname === "/" ? t : Ft([t, f.pathname])), (c.replace ? r.replace : r.push)(f, c.state, c) }, [t, r, s, o, e]) } const Tw = x.createContext(null); function kw(e) { let t = x.useContext(zt).outlet; return t && x.createElement(Tw.Provider, { value: e }, t) } function mo(e, t) { let { relative: n } = t === void 0 ? {} : t, { future: r } = x.useContext(It), { matches: i } = x.useContext(zt), { pathname: o } = Xr(), s = JSON.stringify(yc(i, r.v7_relativeSplatPath)); return x.useMemo(() => wc(e, JSON.parse(s), o, n === "path"), [e, s, o, n]) } function Rw(e, t, n, r) { po() || H(!1); let { navigator: i } = x.useContext(It), { matches: o } = x.useContext(zt), s = o[o.length - 1], a = s ? s.params : {}; s && s.pathname; let l = s ? s.pathnameBase : "/"; s && s.route; let u = Xr(), c; if (t) { var f; let S = typeof t == "string" ? Ot(t) : t; l === "/" || (f = S.pathname) != null && f.startsWith(l) || H(!1), c = S } else c = u; let d = c.pathname || "/", g = d; if (l !== "/") { let S = l.replace(/^\//, "").split("/"); g = "/" + d.replace(/^\//, "").split("/").slice(S.length).join("/") } let v = kr(e, { pathname: g }), y = jw(v && v.map(S => Object.assign({}, S, { params: Object.assign({}, a, S.params), pathname: Ft([l, i.encodeLocation ? i.encodeLocation(S.pathname).pathname : S.pathname]), pathnameBase: S.pathnameBase === "/" ? l : Ft([l, i.encodeLocation ? i.encodeLocation(S.pathnameBase).pathname : S.pathnameBase]) })), o, n, r); return t && y ? x.createElement(oa.Provider, { value: { location: no({ pathname: "/", search: "", hash: "", state: null, key: "default" }, c), navigationType: ve.Pop } }, y) : y } function Lw() { let e = wg(), t = lg(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return x.createElement(x.Fragment, null, x.createElement("h2", null, "Unexpected Application Error!"), x.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? x.createElement("pre", { style: i }, n) : null, null) } const Dw = x.createElement(Lw, null); class Mw extends x.Component { constructor(t) { super(t), this.state = { location: t.location, revalidation: t.revalidation, error: t.error } } static getDerivedStateFromError(t) { return { error: t } } static getDerivedStateFromProps(t, n) { return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? { error: t.error, location: t.location, revalidation: t.revalidation } : { error: t.error !== void 0 ? t.error : n.error, location: n.location, revalidation: t.revalidation || n.revalidation } } componentDidCatch(t, n) { console.error("React Router caught the following error during render", t, n) } render() { return this.state.error !== void 0 ? x.createElement(zt.Provider, { value: this.props.routeContext }, x.createElement(gg.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function Aw(e) { let { routeContext: t, match: n, children: r } = e, i = x.useContext(ho); return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), x.createElement(zt.Provider, { value: t }, r) } function jw(e, t, n, r) { var i; if (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null) { var o; if ((o = n) != null && o.errors) e = n.matches; else return null } let s = e, a = (i = n) == null ? void 0 : i.errors; if (a != null) { let c = s.findIndex(f => f.route.id && (a == null ? void 0 : a[f.route.id])); c >= 0 || H(!1), s = s.slice(0, Math.min(s.length, c + 1)) } let l = !1, u = -1; if (n && r && r.v7_partialHydration) for (let c = 0; c < s.length; c++) { let f = s[c]; if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (u = c), f.route.id) { let { loaderData: d, errors: g } = n, v = f.route.loader && d[f.route.id] === void 0 && (!g || g[f.route.id] === void 0); if (f.route.lazy || v) { l = !0, u >= 0 ? s = s.slice(0, u + 1) : s = [s[0]]; break } } } return s.reduceRight((c, f, d) => { let g, v = !1, y = null, S = null; n && (g = a && f.route.id ? a[f.route.id] : void 0, y = f.route.errorElement || Dw, l && (u < 0 && d === 0 ? (Iw("route-fallback", !1), v = !0, S = null) : u === d && (v = !0, S = f.route.hydrateFallbackElement || null))); let p = t.concat(s.slice(0, d + 1)), h = () => { let m; return g ? m = y : v ? m = S : f.route.Component ? m = x.createElement(f.route.Component, null) : f.route.element ? m = f.route.element : m = c, x.createElement(Aw, { match: f, routeContext: { outlet: c, matches: p, isDataRoute: n != null }, children: m }) }; return n && (f.route.ErrorBoundary || f.route.errorElement || d === 0) ? x.createElement(Mw, { location: n.location, revalidation: n.revalidation, component: y, error: g, children: h(), routeContext: { outlet: null, matches: p, isDataRoute: !0 } }) : h() }, null) } var yg = function (e) { return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e }(yg || {}), Ln = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(Ln || {}); function Nw(e) { let t = x.useContext(ho); return t || H(!1), t } function Pc(e) { let t = x.useContext(ia); return t || H(!1), t } function Vw(e) { let t = x.useContext(zt); return t || H(!1), t } function sa(e) { let t = Vw(), n = t.matches[t.matches.length - 1]; return n.route.id || H(!1), n.route.id } function Fw() { return sa(Ln.UseRouteId) } function _w() { return Pc(Ln.UseNavigation).navigation } function aa() { let e = Pc(Ln.UseLoaderData), t = sa(Ln.UseLoaderData); if (e.errors && e.errors[t] != null) { console.error("You cannot `useLoaderData` in an errorElement (routeId: " + t + ")"); return } return e.loaderData[t] } function wg() { var e; let t = x.useContext(gg), n = Pc(Ln.UseRouteError), r = sa(Ln.UseRouteError); return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r] } function Ow() { let { router: e } = Nw(yg.UseNavigateStable), t = sa(Ln.UseNavigateStable), n = x.useRef(!1); return vg(() => { n.current = !0 }), x.useCallback(function (i, o) { o === void 0 && (o = {}), n.current && (typeof i == "number" ? e.navigate(i) : e.navigate(i, no({ fromRouteId: t }, o))) }, [e, t]) } const Vd = {}; function Iw(e, t, n) { !t && !Vd[e] && (Vd[e] = !0) } function zw(e) { return kw(e.context) } function Uw(e) { let { basename: t = "/", children: n = null, location: r, navigationType: i = ve.Pop, navigator: o, static: s = !1, future: a } = e; po() && H(!1); let l = t.replace(/^\/*/, "/"), u = x.useMemo(() => ({ basename: l, navigator: o, static: s, future: no({ v7_relativeSplatPath: !1 }, a) }), [l, a, o, s]); typeof r == "string" && (r = Ot(r)); let { pathname: c = "/", search: f = "", hash: d = "", state: g = null, key: v = "default" } = r, y = x.useMemo(() => { let S = Lt(c, l); return S == null ? null : { location: { pathname: S, search: f, hash: d, state: g, key: v }, navigationType: i } }, [l, c, f, d, g, v, i]); return y == null ? null : x.createElement(It.Provider, { value: u }, x.createElement(oa.Provider, { children: n, value: y })) } new Promise(() => { }); function Bw(e) { let t = { hasErrorBoundary: e.ErrorBoundary != null || e.errorElement != null }; return e.Component && Object.assign(t, { element: x.createElement(e.Component), Component: void 0 }), e.HydrateFallback && Object.assign(t, { hydrateFallbackElement: x.createElement(e.HydrateFallback), HydrateFallback: void 0 }), e.ErrorBoundary && Object.assign(t, { errorElement: x.createElement(e.ErrorBoundary), ErrorBoundary: void 0 }), t }/**
 * React Router DOM v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function kt() { return kt = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, kt.apply(this, arguments) } function Ec(e, t) { if (e == null) return {}; var n = {}, r = Object.keys(e), i, o; for (o = 0; o < r.length; o++)i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]); return n } const is = "get", Za = "application/x-www-form-urlencoded"; function la(e) { return e != null && typeof e.tagName == "string" } function bw(e) { return la(e) && e.tagName.toLowerCase() === "button" } function Hw(e) { return la(e) && e.tagName.toLowerCase() === "form" } function Ww(e) { return la(e) && e.tagName.toLowerCase() === "input" } function $w(e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) } function Kw(e, t) { return e.button === 0 && (!t || t === "_self") && !$w(e) } let Ho = null; function Gw() { if (Ho === null) try { new FormData(document.createElement("form"), 0), Ho = !1 } catch { Ho = !0 } return Ho } const Qw = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); function Ja(e) { return e != null && !Qw.has(e) ? null : e } function Yw(e, t) { let n, r, i, o, s; if (Hw(e)) { let a = e.getAttribute("action"); r = a ? Lt(a, t) : null, n = e.getAttribute("method") || is, i = Ja(e.getAttribute("enctype")) || Za, o = new FormData(e) } else if (bw(e) || Ww(e) && (e.type === "submit" || e.type === "image")) { let a = e.form; if (a == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>'); let l = e.getAttribute("formaction") || a.getAttribute("action"); if (r = l ? Lt(l, t) : null, n = e.getAttribute("formmethod") || a.getAttribute("method") || is, i = Ja(e.getAttribute("formenctype")) || Ja(a.getAttribute("enctype")) || Za, o = new FormData(a, e), !Gw()) { let { name: u, type: c, value: f } = e; if (c === "image") { let d = u ? u + "." : ""; o.append(d + "x", "0"), o.append(d + "y", "0") } else u && o.append(u, f) } } else { if (la(e)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">'); n = is, r = null, i = Za, s = e } return o && i === "text/plain" && (s = o, o = void 0), { action: r, method: n.toLowerCase(), encType: i, formData: o, body: s } } const Xw = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"], Zw = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"], Jw = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"], qw = "6"; try { window.__reactRouterVersion = qw } catch { } function ex(e, t) { return cw({ basename: t == null ? void 0 : t.basename, future: kt({}, t == null ? void 0 : t.future, { v7_prependBasename: !0 }), history: F1({ window: t == null ? void 0 : t.window }), hydrationData: (t == null ? void 0 : t.hydrationData) || tx(), routes: e, mapRouteProperties: Bw, window: t == null ? void 0 : t.window }).initialize() } function tx() { var e; let t = (e = window) == null ? void 0 : e.__staticRouterHydrationData; return t && t.errors && (t = kt({}, t, { errors: nx(t.errors) })), t } function nx(e) { if (!e) return null; let t = Object.entries(e), n = {}; for (let [r, i] of t) if (i && i.__type === "RouteErrorResponse") n[r] = new xc(i.status, i.statusText, i.data, i.internal === !0); else if (i && i.__type === "Error") { if (i.__subType) { let o = window[i.__subType]; if (typeof o == "function") try { let s = new o(i.message); s.stack = "", n[r] = s } catch { } } if (n[r] == null) { let o = new Error(i.message); o.stack = "", n[r] = o } } else n[r] = i; return n } const xg = x.createContext({ isTransitioning: !1 }), Sg = x.createContext(new Map), rx = "startTransition", Fd = ls[rx], ix = "flushSync", _d = V1[ix], ox = "useId", Od = ls[ox]; function sx(e) { Fd ? Fd(e) : e() } function pi(e) { _d ? _d(e) : e() } class ax { constructor() { this.status = "pending", this.promise = new Promise((t, n) => { this.resolve = r => { this.status === "pending" && (this.status = "resolved", t(r)) }, this.reject = r => { this.status === "pending" && (this.status = "rejected", n(r)) } }) } } function lx(e) { let { fallbackElement: t, router: n, future: r } = e, [i, o] = x.useState(n.state), [s, a] = x.useState(), [l, u] = x.useState({ isTransitioning: !1 }), [c, f] = x.useState(), [d, g] = x.useState(), [v, y] = x.useState(), S = x.useRef(new Map), { v7_startTransition: p } = r || {}, h = x.useCallback(D => { p ? sx(D) : D() }, [p]), m = x.useCallback((D, k) => { let { deletedFetchers: j, unstable_flushSync: V, unstable_viewTransitionOpts: W } = k; j.forEach(de => S.current.delete(de)), D.fetchers.forEach((de, Be) => { de.data !== void 0 && S.current.set(Be, de.data) }); let fe = n.window == null || typeof n.window.document.startViewTransition != "function"; if (!W || fe) { V ? pi(() => o(D)) : h(() => o(D)); return } if (V) { pi(() => { d && (c && c.resolve(), d.skipTransition()), u({ isTransitioning: !0, flushSync: !0, currentLocation: W.currentLocation, nextLocation: W.nextLocation }) }); let de = n.window.document.startViewTransition(() => { pi(() => o(D)) }); de.finished.finally(() => { pi(() => { f(void 0), g(void 0), a(void 0), u({ isTransitioning: !1 }) }) }), pi(() => g(de)); return } d ? (c && c.resolve(), d.skipTransition(), y({ state: D, currentLocation: W.currentLocation, nextLocation: W.nextLocation })) : (a(D), u({ isTransitioning: !0, flushSync: !1, currentLocation: W.currentLocation, nextLocation: W.nextLocation })) }, [n.window, d, c, S, h]); x.useLayoutEffect(() => n.subscribe(m), [n, m]), x.useEffect(() => { l.isTransitioning && !l.flushSync && f(new ax) }, [l]), x.useEffect(() => { if (c && s && n.window) { let D = s, k = c.promise, j = n.window.document.startViewTransition(async () => { h(() => o(D)), await k }); j.finished.finally(() => { f(void 0), g(void 0), a(void 0), u({ isTransitioning: !1 }) }), g(j) } }, [h, s, c, n.window]), x.useEffect(() => { c && s && i.location.key === s.location.key && c.resolve() }, [c, d, i.location, s]), x.useEffect(() => { !l.isTransitioning && v && (a(v.state), u({ isTransitioning: !0, flushSync: !1, currentLocation: v.currentLocation, nextLocation: v.nextLocation }), y(void 0)) }, [l.isTransitioning, v]), x.useEffect(() => { }, []); let P = x.useMemo(() => ({ createHref: n.createHref, encodeLocation: n.encodeLocation, go: D => n.navigate(D), push: (D, k, j) => n.navigate(D, { state: k, preventScrollReset: j == null ? void 0 : j.preventScrollReset }), replace: (D, k, j) => n.navigate(D, { replace: !0, state: k, preventScrollReset: j == null ? void 0 : j.preventScrollReset }) }), [n]), R = n.basename || "/", w = x.useMemo(() => ({ router: n, navigator: P, static: !1, basename: R }), [n, P, R]); return x.createElement(x.Fragment, null, x.createElement(ho.Provider, { value: w }, x.createElement(ia.Provider, { value: i }, x.createElement(Sg.Provider, { value: S.current }, x.createElement(xg.Provider, { value: l }, x.createElement(Uw, { basename: R, location: i.location, navigationType: i.historyAction, navigator: P, future: { v7_relativeSplatPath: n.future.v7_relativeSplatPath } }, i.initialized || n.future.v7_partialHydration ? x.createElement(ux, { routes: n.routes, future: n.future, state: i }) : t))))), null) } function ux(e) { let { routes: t, future: n, state: r } = e; return Rw(t, void 0, r, n) } const cx = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", fx = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Cg = x.forwardRef(function (t, n) { let { onClick: r, relative: i, reloadDocument: o, replace: s, state: a, target: l, to: u, preventScrollReset: c, unstable_viewTransition: f } = t, d = Ec(t, Xw), { basename: g } = x.useContext(It), v, y = !1; if (typeof u == "string" && fx.test(u) && (v = u, cx)) try { let m = new URL(window.location.href), P = u.startsWith("//") ? new URL(m.protocol + u) : new URL(u), R = Lt(P.pathname, g); P.origin === m.origin && R != null ? u = R + P.search + P.hash : y = !0 } catch { } let S = Pw(u, { relative: i }), p = hx(u, { replace: s, state: a, target: l, preventScrollReset: c, relative: i, unstable_viewTransition: f }); function h(m) { r && r(m), m.defaultPrevented || p(m) } return x.createElement("a", kt({}, d, { href: v || S, onClick: y || o ? r : h, ref: n, target: l })) }), Pg = x.forwardRef(function (t, n) { let { "aria-current": r = "page", caseSensitive: i = !1, className: o = "", end: s = !1, style: a, to: l, unstable_viewTransition: u, children: c } = t, f = Ec(t, Zw), d = mo(l, { relative: f.relative }), g = Xr(), v = x.useContext(ia), { navigator: y, basename: S } = x.useContext(It), p = v != null && yx(d) && u === !0, h = y.encodeLocation ? y.encodeLocation(d).pathname : d.pathname, m = g.pathname, P = v && v.navigation && v.navigation.location ? v.navigation.location.pathname : null; i || (m = m.toLowerCase(), P = P ? P.toLowerCase() : null, h = h.toLowerCase()), P && S && (P = Lt(P, S) || P); const R = h !== "/" && h.endsWith("/") ? h.length - 1 : h.length; let w = m === h || !s && m.startsWith(h) && m.charAt(R) === "/", D = P != null && (P === h || !s && P.startsWith(h) && P.charAt(h.length) === "/"), k = { isActive: w, isPending: D, isTransitioning: p }, j = w ? r : void 0, V; typeof o == "function" ? V = o(k) : V = [o, w ? "active" : null, D ? "pending" : null, p ? "transitioning" : null].filter(Boolean).join(" "); let W = typeof a == "function" ? a(k) : a; return x.createElement(Cg, kt({}, f, { "aria-current": j, className: V, ref: n, style: W, to: l, unstable_viewTransition: u }), typeof c == "function" ? c(k) : c) }), $r = x.forwardRef((e, t) => { let { fetcherKey: n, navigate: r, reloadDocument: i, replace: o, state: s, method: a = is, action: l, onSubmit: u, relative: c, preventScrollReset: f, unstable_viewTransition: d } = e, g = Ec(e, Jw), v = kc(), y = gx(l, { relative: c }), S = a.toLowerCase() === "get" ? "get" : "post", p = h => { if (u && u(h), h.defaultPrevented) return; h.preventDefault(); let m = h.nativeEvent.submitter, P = (m == null ? void 0 : m.getAttribute("formmethod")) || a; v(m || h.currentTarget, { fetcherKey: n, method: P, navigate: r, replace: o, state: s, relative: c, preventScrollReset: f, unstable_viewTransition: d }) }; return x.createElement("form", kt({ ref: t, method: S, action: y, onSubmit: i ? u : p }, g)) }); var ro; (function (e) { e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState" })(ro || (ro = {})); var fu; (function (e) { e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration" })(fu || (fu = {})); function Tc(e) { let t = x.useContext(ho); return t || H(!1), t } function dx(e) { let t = x.useContext(ia); return t || H(!1), t } function hx(e, t) { let { target: n, replace: r, state: i, preventScrollReset: o, relative: s, unstable_viewTransition: a } = t === void 0 ? {} : t, l = Cc(), u = Xr(), c = mo(e, { relative: s }); return x.useCallback(f => { if (Kw(f, n)) { f.preventDefault(); let d = r !== void 0 ? r : Rn(u) === Rn(c); l(e, { replace: d, state: i, preventScrollReset: o, relative: s, unstable_viewTransition: a }) } }, [u, l, c, r, i, n, e, o, s, a]) } function px() { if (typeof document > "u") throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.") } let mx = 0, Eg = () => "__" + String(++mx) + "__"; function kc() { let { router: e } = Tc(ro.UseSubmit), { basename: t } = x.useContext(It), n = Fw(); return x.useCallback(function (r, i) { i === void 0 && (i = {}), px(); let { action: o, method: s, encType: a, formData: l, body: u } = Yw(r, t); if (i.navigate === !1) { let c = i.fetcherKey || Eg(); e.fetch(c, n, i.action || o, { preventScrollReset: i.preventScrollReset, formData: l, body: u, formMethod: i.method || s, formEncType: i.encType || a, unstable_flushSync: i.unstable_flushSync }) } else e.navigate(i.action || o, { preventScrollReset: i.preventScrollReset, formData: l, body: u, formMethod: i.method || s, formEncType: i.encType || a, replace: i.replace, state: i.state, fromRouteId: n, unstable_flushSync: i.unstable_flushSync, unstable_viewTransition: i.unstable_viewTransition }) }, [e, t, n]) } function gx(e, t) { let { relative: n } = t === void 0 ? {} : t, { basename: r } = x.useContext(It), i = x.useContext(zt); i || H(!1); let [o] = i.matches.slice(-1), s = kt({}, mo(e || ".", { relative: n })), a = Xr(); if (e == null) { s.search = a.search; let l = new URLSearchParams(s.search); l.has("index") && l.get("index") === "" && (l.delete("index"), s.search = l.toString() ? "?" + l.toString() : "") } return (!e || e === ".") && o.route.index && (s.search = s.search ? s.search.replace(/^\?/, "?index&") : "?index"), r !== "/" && (s.pathname = s.pathname === "/" ? r : Ft([r, s.pathname])), Rn(s) } function vx(e) { var t; let { key: n } = e === void 0 ? {} : e, { router: r } = Tc(ro.UseFetcher), i = dx(fu.UseFetcher), o = x.useContext(Sg), s = x.useContext(zt), a = (t = s.matches[s.matches.length - 1]) == null ? void 0 : t.route.id; o || H(!1), s || H(!1), a == null && H(!1); let l = Od ? Od() : "", [u, c] = x.useState(n || l); n && n !== u ? c(n) : u || c(Eg()), x.useEffect(() => (r.getFetcher(u), () => { r.deleteFetcher(u) }), [r, u]); let f = x.useCallback((h, m) => { a || H(!1), r.fetch(u, a, h, m) }, [u, a, r]), d = kc(), g = x.useCallback((h, m) => { d(h, kt({}, m, { navigate: !1, fetcherKey: u })) }, [u, d]), v = x.useMemo(() => x.forwardRef((m, P) => x.createElement($r, kt({}, m, { navigate: !1, fetcherKey: u, ref: P }))), [u]), y = i.fetchers.get(u) || cg, S = o.get(u); return x.useMemo(() => kt({ Form: v, submit: g, load: f }, y, { data: S }), [v, g, f, y, S]) } function yx(e, t) { t === void 0 && (t = {}); let n = x.useContext(xg); n == null && H(!1); let { basename: r } = Tc(ro.useViewTransitionState), i = mo(e, { relative: t.relative }); if (!n.isTransitioning) return !1; let o = Lt(n.currentLocation.pathname, r) || n.currentLocation.pathname, s = Lt(n.nextLocation.pathname, r) || n.nextLocation.pathname; return au(i.pathname, s) != null || au(i.pathname, o) != null } var du = {}, Id = vc; du.createRoot = Id.createRoot, du.hydrateRoot = Id.hydrateRoot; const zd = [{ id: "MkeDHds", createdAt: 1712185217702, first: "Nirmal", last: "Dinu", twitter: "Alfred_Adler", avatar: "ppl-3.jpg", notes: "The first one in the office every morning and the last one to leave. It wasn't about clocking hours; it was about a relentless pursuit of finding a better way. Her colleagues would often see scribbled notes, abandoned prototypes, and diagrams scattered across her desk –  evidence of restless nights and a mind always churning towards the next breakthrough." }, { id: "35vQdPb", createdAt: 1712185165737, first: "Cyan", last: "Arsène", twitter: "@adamsmith", avatar: "ppl-2.jpg", notes: "His workspace was a kaleidoscope of tools, half-built gadgets, and overflowing bookshelves. He was as much an inventor as an engineer, his greatest ideas often born from late-night tinkering. Failure was merely a stepping stone, and the word impossible simply fueled his determination to find an unconventional solution.", favorite: !1 }, { id: "r7tF6cP", createdAt: 1712336685232, first: "Ansgar", last: "Sieghard", twitter: "", avatar: "ppl-1.jpg", notes: "Meetings were never about status updates; they were battlegrounds for ideas. She challenged assumptions, tore down conventional thinking, and forced everyone to zoom out. Every obstacle became an invitation to create a new path forward. Her unwavering belief in the project was contagious, fueling her team's collective ambition.", favorite: !0 }, { id: "AQpWypc", createdAt: 1712336685232, first: "René", last: "Aldous", twitter: "", avatar: "ppl-4.jpg", notes: "To him, the finish line was merely a mirage. Each milestone achieved only spurred a hunger for the next challenge.  He relentlessly dissected every success and scrutinized every flaw. This relentless self-criticism wasn't perfectionism; it was an understanding that progress was a journey, not a destination.", favorite: !0 }, { id: "9JFkWpr", createdAt: 1712336685232, first: "Lillia", last: "Marylyn", twitter: "", avatar: "ppl-7.jpg", notes: "Her office door was always open. Junior engineers, designers, even interns—everyone felt their voice mattered. She understood that true innovation comes from collaboration, not just singular brilliance.  She was their fiercest advocate, their mentor, the wind beneath their wings.", favorite: !0 }, { id: "9abcWpr", createdAt: 1712336685232, first: "Alex", last: "Yusu", twitter: "", avatar: "ppl-6.jpg", notes: "Her office door was always open. Junior engineers, designers, even interns—everyone felt their voice mattered. She understood that true innovation comes from collaboration, not just singular brilliance.  She was their fiercest advocate, their mentor, the wind beneath their wings.", favorite: !0 }]; async function Rc(e) { await ca(`filterContactsByQuery:${e}`); let t = await Gr.getItem("contacts"); return t || (t = []), e && (t = Cy(t, e, { keys: ["first", "last"] })), t.sort(Py("last", "createdAt")) } async function wx() { await ca(); let t = { id: Math.random().toString(36).substring(2, 9), createdAt: Date.now() }, n = await Rc(); return n.unshift(t), await ua(n), t } async function xx(e) { return await ca(`contact:${e}`), (await Gr.getItem("contacts")).find(r => r.id === e) ?? null } async function Tg(e, t) { await ca(); let n = await Gr.getItem("contacts"), r = n.find(i => i.id === e); if (!r) throw new Error("No contact found for", e); return Object.assign(r, t), await ua(n), r } async function Sx(e) { let t = await Gr.getItem("contacts"), n = t.findIndex(r => r.id === e); return n > -1 ? (t.splice(n, 1), await ua(t), !0) : !1 } async function Cx() { console.log("loadContacts() sample_contacts:", zd); let e = await Gr.getItem("contacts"); console.log("storage_contacts:", e); try { zd.forEach(t => { e.some(r => r.id === t.id) || e.unshift(t) }), await ua(e) } catch (t) { console.error("Error fetching sample_contacts.JSON:", t) } return e } function ua(e) { return Gr.setItem("contacts", e) } let qa = {}; async function ca(e) { if (e || (qa = {}), !qa[e]) return qa[e] = !0, new Promise(t => { setTimeout(t, Math.random() * 800) }) } const Lc = x.createContext({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }), fa = x.createContext({}), da = x.createContext(null), Dc = typeof document < "u", Mc = Dc ? x.useLayoutEffect : x.useEffect, kg = x.createContext({ strict: !1 }), Ac = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), Px = "framerAppearId", Rg = "data-" + Ac(Px), Ex = { skipAnimations: !1, useManualTiming: !1 }; class Ud { constructor() { this.order = [], this.scheduled = new Set } add(t) { if (!this.scheduled.has(t)) return this.scheduled.add(t), this.order.push(t), !0 } remove(t) { const n = this.order.indexOf(t); n !== -1 && (this.order.splice(n, 1), this.scheduled.delete(t)) } clear() { this.order.length = 0, this.scheduled.clear() } } function Tx(e) { let t = new Ud, n = new Ud, r = 0, i = !1, o = !1; const s = new WeakSet, a = { schedule: (l, u = !1, c = !1) => { const f = c && i, d = f ? t : n; return u && s.add(l), d.add(l) && f && i && (r = t.order.length), l }, cancel: l => { n.remove(l), s.delete(l) }, process: l => { if (i) { o = !0; return } if (i = !0, [t, n] = [n, t], n.clear(), r = t.order.length, r) for (let u = 0; u < r; u++) { const c = t.order[u]; s.has(c) && (a.schedule(c), e()), c(l) } i = !1, o && (o = !1, a.process(l)) } }; return a } const Wo = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], kx = 40; function Lg(e, t) { let n = !1, r = !0; const i = { delta: 0, timestamp: 0, isProcessing: !1 }, o = Wo.reduce((f, d) => (f[d] = Tx(() => n = !0), f), {}), s = f => { o[f].process(i) }, a = () => { const f = performance.now(); n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(f - i.timestamp, kx), 1), i.timestamp = f, i.isProcessing = !0, Wo.forEach(s), i.isProcessing = !1, n && t && (r = !1, e(a)) }, l = () => { n = !0, r = !0, i.isProcessing || e(a) }; return { schedule: Wo.reduce((f, d) => { const g = o[d]; return f[d] = (v, y = !1, S = !1) => (n || l(), g.schedule(v, y, S)), f }, {}), cancel: f => Wo.forEach(d => o[d].cancel(f)), state: i, steps: o } } const { schedule: jc, cancel: a2 } = Lg(queueMicrotask, !1); function Rx(e, t, n, r) { const { visualElement: i } = x.useContext(fa), o = x.useContext(kg), s = x.useContext(da), a = x.useContext(Lc).reducedMotion, l = x.useRef(); r = r || o.renderer, !l.current && r && (l.current = r(e, { visualState: t, parent: i, props: n, presenceContext: s, blockInitialAnimation: s ? s.initial === !1 : !1, reducedMotionConfig: a })); const u = l.current; x.useInsertionEffect(() => { u && u.update(n, s) }); const c = x.useRef(!!(n[Rg] && !window.HandoffComplete)); return Mc(() => { u && (jc.postRender(u.render), c.current && u.animationState && u.animationState.animateChanges()) }), x.useEffect(() => { u && (u.updateFeatures(), !c.current && u.animationState && u.animationState.animateChanges(), c.current && (c.current = !1, window.HandoffComplete = !0)) }), u } function Lr(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } function Lx(e, t, n) { return x.useCallback(r => { r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : Lr(n) && (n.current = r)) }, [t]) } function io(e) { return typeof e == "string" || Array.isArray(e) } function ha(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } const Nc = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], Vc = ["initial", ...Nc]; function pa(e) { return ha(e.animate) || Vc.some(t => io(e[t])) } function Dg(e) { return !!(pa(e) || e.variants) } function Dx(e, t) { if (pa(e)) { const { initial: n, animate: r } = e; return { initial: n === !1 || io(n) ? n : void 0, animate: io(r) ? r : void 0 } } return e.inherit !== !1 ? t : {} } function Mx(e) { const { initial: t, animate: n } = Dx(e, x.useContext(fa)); return x.useMemo(() => ({ initial: t, animate: n }), [Bd(t), Bd(n)]) } function Bd(e) { return Array.isArray(e) ? e.join(" ") : e } const bd = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, oo = {}; for (const e in bd) oo[e] = { isEnabled: t => bd[e].some(n => !!t[n]) }; function Ax(e) { for (const t in e) oo[t] = { ...oo[t], ...e[t] } } const Fc = x.createContext({}), Mg = x.createContext({}), jx = Symbol.for("motionComponentSymbol"); function Nx({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: i }) { e && Ax(e); function o(a, l) { let u; const c = { ...x.useContext(Lc), ...a, layoutId: Vx(a) }, { isStatic: f } = c, d = Mx(a), g = r(a, f); if (!f && Dc) { d.visualElement = Rx(i, g, c, t); const v = x.useContext(Mg), y = x.useContext(kg).strict; d.visualElement && (u = d.visualElement.loadFeatures(c, y, e, v)) } return x.createElement(fa.Provider, { value: d }, u && d.visualElement ? x.createElement(u, { visualElement: d.visualElement, ...c }) : null, n(i, a, Lx(g, d.visualElement, l), g, f, d.visualElement)) } const s = x.forwardRef(o); return s[jx] = i, s } function Vx({ layoutId: e }) { const t = x.useContext(Fc).id; return t && e !== void 0 ? t + "-" + e : e } function Fx(e) { function t(r, i = {}) { return Nx(e(r, i)) } if (typeof Proxy > "u") return t; const n = new Map; return new Proxy(t, { get: (r, i) => (n.has(i) || n.set(i, t(i)), n.get(i)) }) } const _x = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function _c(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(_x.indexOf(e) > -1 || /[A-Z]/u.test(e)) } const Ns = {}; function Ox(e) { Object.assign(Ns, e) } const go = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], ur = new Set(go); function Ag(e, { layout: t, layoutId: n }) { return ur.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Ns[e] || e === "opacity") } const Ie = e => !!(e && e.getVelocity), Ix = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, zx = go.length; function Ux(e, { enableHardwareAcceleration: t = !0, allowTransformNone: n = !0 }, r, i) { let o = ""; for (let s = 0; s < zx; s++) { const a = go[s]; if (e[a] !== void 0) { const l = Ix[a] || a; o += `${l}(${e[a]}) ` } } return t && !e.z && (o += "translateZ(0)"), o = o.trim(), i ? o = i(e, r ? "" : o) : n && r && (o = "none"), o } const jg = e => t => typeof t == "string" && t.startsWith(e), Ng = jg("--"), Bx = jg("var(--"), Oc = e => Bx(e) ? bx.test(e.split("/*")[0].trim()) : !1, bx = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Hx = (e, t) => t && typeof e == "number" ? t.transform(e) : e, Dn = (e, t, n) => n > t ? t : n < e ? e : n, Zr = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, Ni = { ...Zr, transform: e => Dn(0, 1, e) }, $o = { ...Zr, default: 1 }, Vi = e => Math.round(e * 1e5) / 1e5, Ic = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, Wx = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, $x = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; function vo(e) { return typeof e == "string" } const yo = e => ({ test: t => vo(t) && t.endsWith(e) && t.split(" ").length === 1, parse: parseFloat, transform: t => `${t}${e}` }), an = yo("deg"), _t = yo("%"), I = yo("px"), Kx = yo("vh"), Gx = yo("vw"), Hd = { ..._t, parse: e => _t.parse(e) / 100, transform: e => _t.transform(e * 100) }, Wd = { ...Zr, transform: Math.round }, Vg = { borderWidth: I, borderTopWidth: I, borderRightWidth: I, borderBottomWidth: I, borderLeftWidth: I, borderRadius: I, radius: I, borderTopLeftRadius: I, borderTopRightRadius: I, borderBottomRightRadius: I, borderBottomLeftRadius: I, width: I, maxWidth: I, height: I, maxHeight: I, size: I, top: I, right: I, bottom: I, left: I, padding: I, paddingTop: I, paddingRight: I, paddingBottom: I, paddingLeft: I, margin: I, marginTop: I, marginRight: I, marginBottom: I, marginLeft: I, rotate: an, rotateX: an, rotateY: an, rotateZ: an, scale: $o, scaleX: $o, scaleY: $o, scaleZ: $o, skew: an, skewX: an, skewY: an, distance: I, translateX: I, translateY: I, translateZ: I, x: I, y: I, z: I, perspective: I, transformPerspective: I, opacity: Ni, originX: Hd, originY: Hd, originZ: I, zIndex: Wd, backgroundPositionX: I, backgroundPositionY: I, fillOpacity: Ni, strokeOpacity: Ni, numOctaves: Wd }; function zc(e, t, n, r) { const { style: i, vars: o, transform: s, transformOrigin: a } = e; let l = !1, u = !1, c = !0; for (const f in t) { const d = t[f]; if (Ng(f)) { o[f] = d; continue } const g = Vg[f], v = Hx(d, g); if (ur.has(f)) { if (l = !0, s[f] = v, !c) continue; d !== (g.default || 0) && (c = !1) } else f.startsWith("origin") ? (u = !0, a[f] = v) : i[f] = v } if (t.transform || (l || r ? i.transform = Ux(e.transform, n, c, r) : i.transform && (i.transform = "none")), u) { const { originX: f = "50%", originY: d = "50%", originZ: g = 0 } = a; i.transformOrigin = `${f} ${d} ${g}` } } const Uc = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function Fg(e, t, n) { for (const r in t) !Ie(t[r]) && !Ag(r, n) && (e[r] = t[r]) } function Qx({ transformTemplate: e }, t, n) { return x.useMemo(() => { const r = Uc(); return zc(r, t, { enableHardwareAcceleration: !n }, e), Object.assign({}, r.vars, r.style) }, [t]) } function Yx(e, t, n) { const r = e.style || {}, i = {}; return Fg(i, r, e), Object.assign(i, Qx(e, t, n)), i } function Xx(e, t, n) { const r = {}, i = Yx(e, t, n); return e.drag && e.dragListener !== !1 && (r.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (r.tabIndex = 0), r.style = i, r } const Zx = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function Vs(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || Zx.has(e) } let _g = e => !Vs(e); function Jx(e) { e && (_g = t => t.startsWith("on") ? !Vs(t) : e(t)) } try { Jx(require("@emotion/is-prop-valid").default) } catch { } function qx(e, t, n) { const r = {}; for (const i in e) i === "values" && typeof e.values == "object" || (_g(i) || n === !0 && Vs(i) || !t && !Vs(i) || e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]); return r } function $d(e, t, n) { return typeof e == "string" ? e : I.transform(t + n * e) } function eS(e, t, n) { const r = $d(t, e.x, e.width), i = $d(n, e.y, e.height); return `${r} ${i}` } const tS = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, nS = { offset: "strokeDashoffset", array: "strokeDasharray" }; function rS(e, t, n = 1, r = 0, i = !0) { e.pathLength = 1; const o = i ? tS : nS; e[o.offset] = I.transform(-r); const s = I.transform(t), a = I.transform(n); e[o.array] = `${s} ${a}` } function Bc(e, { attrX: t, attrY: n, attrScale: r, originX: i, originY: o, pathLength: s, pathSpacing: a = 1, pathOffset: l = 0, ...u }, c, f, d) { if (zc(e, u, c, d), f) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; const { attrs: g, style: v, dimensions: y } = e; g.transform && (y && (v.transform = g.transform), delete g.transform), y && (i !== void 0 || o !== void 0 || v.transform) && (v.transformOrigin = eS(y, i !== void 0 ? i : .5, o !== void 0 ? o : .5)), t !== void 0 && (g.x = t), n !== void 0 && (g.y = n), r !== void 0 && (g.scale = r), s !== void 0 && rS(g, s, a, l, !1) } const Og = () => ({ ...Uc(), attrs: {} }), bc = e => typeof e == "string" && e.toLowerCase() === "svg"; function iS(e, t, n, r) { const i = x.useMemo(() => { const o = Og(); return Bc(o, t, { enableHardwareAcceleration: !1 }, bc(r), e.transformTemplate), { ...o.attrs, style: { ...o.style } } }, [t]); if (e.style) { const o = {}; Fg(o, e.style, e), i.style = { ...o, ...i.style } } return i } function oS(e = !1) { return (n, r, i, { latestValues: o }, s) => { const l = (_c(n) ? iS : Xx)(r, o, s, n), u = qx(r, typeof n == "string", e), c = n !== x.Fragment ? { ...u, ...l, ref: i } : {}, { children: f } = r, d = x.useMemo(() => Ie(f) ? f.get() : f, [f]); return x.createElement(n, { ...c, children: d }) } } function Ig(e, { style: t, vars: n }, r, i) { Object.assign(e.style, t, i && i.getProjectionStyles(r)); for (const o in n) e.style.setProperty(o, n[o]) } const zg = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function Ug(e, t, n, r) { Ig(e, t, void 0, r); for (const i in t.attrs) e.setAttribute(zg.has(i) ? i : Ac(i), t.attrs[i]) } function Hc(e, t, n) { var r; const { style: i } = e, o = {}; for (const s in i) (Ie(i[s]) || t.style && Ie(t.style[s]) || Ag(s, e) || ((r = n == null ? void 0 : n.getValue(s)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (o[s] = i[s]); return o } function Bg(e, t, n) { const r = Hc(e, t, n); for (const i in e) if (Ie(e[i]) || Ie(t[i])) { const o = go.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i; r[o] = e[i] } return r } function Wc(e, t, n, r = {}, i = {}) { return typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, r, i)), typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, r, i)), t } function bg(e) { const t = x.useRef(null); return t.current === null && (t.current = e()), t.current } const hu = e => Array.isArray(e), sS = e => !!(e && typeof e == "object" && e.mix && e.toValue), aS = e => hu(e) ? e[e.length - 1] || 0 : e; function os(e) { const t = Ie(e) ? e.get() : e; return sS(t) ? t.toValue() : t } function lS({ scrapeMotionValuesFromProps: e, createRenderState: t, onMount: n }, r, i, o) { const s = { latestValues: uS(r, i, o, e), renderState: t() }; return n && (s.mount = a => n(r, a, s)), s } const Hg = e => (t, n) => { const r = x.useContext(fa), i = x.useContext(da), o = () => lS(e, t, r, i); return n ? o() : bg(o) }; function uS(e, t, n, r) { const i = {}, o = r(e, {}); for (const d in o) i[d] = os(o[d]); let { initial: s, animate: a } = e; const l = pa(e), u = Dg(e); t && u && !l && e.inherit !== !1 && (s === void 0 && (s = t.initial), a === void 0 && (a = t.animate)); let c = n ? n.initial === !1 : !1; c = c || s === !1; const f = c ? a : s; return f && typeof f != "boolean" && !ha(f) && (Array.isArray(f) ? f : [f]).forEach(g => { const v = Wc(e, g); if (!v) return; const { transitionEnd: y, transition: S, ...p } = v; for (const h in p) { let m = p[h]; if (Array.isArray(m)) { const P = c ? m.length - 1 : 0; m = m[P] } m !== null && (i[h] = m) } for (const h in y) i[h] = y[h] }), i } const ze = e => e, { schedule: Re, cancel: Mn, state: Ae, steps: el } = Lg(typeof requestAnimationFrame < "u" ? requestAnimationFrame : ze, !0), cS = { useVisualState: Hg({ scrapeMotionValuesFromProps: Bg, createRenderState: Og, onMount: (e, t, { renderState: n, latestValues: r }) => { Re.read(() => { try { n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect() } catch { n.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), Re.render(() => { Bc(n, r, { enableHardwareAcceleration: !1 }, bc(t.tagName), e.transformTemplate), Ug(t, n) }) } }) }, fS = { useVisualState: Hg({ scrapeMotionValuesFromProps: Hc, createRenderState: Uc }) }; function dS(e, { forwardMotionProps: t = !1 }, n, r) { return { ..._c(e) ? cS : fS, preloadedFeatures: n, useRender: oS(t), createVisualElement: r, Component: e } } function Wt(e, t, n, r = { passive: !0 }) { return e.addEventListener(t, n, r), () => e.removeEventListener(t, n) } const Wg = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1; function ma(e, t = "page") { return { point: { x: e[t + "X"], y: e[t + "Y"] } } } const hS = e => t => Wg(t) && e(t, ma(t)); function Kt(e, t, n, r) { return Wt(e, t, hS(n), r) } const pS = (e, t) => n => t(e(n)), Gt = (...e) => e.reduce(pS); function $g(e) { let t = null; return () => { const n = () => { t = null }; return t === null ? (t = e, n) : !1 } } const Kd = $g("dragHorizontal"), Gd = $g("dragVertical"); function Kg(e) { let t = !1; if (e === "y") t = Gd(); else if (e === "x") t = Kd(); else { const n = Kd(), r = Gd(); n && r ? t = () => { n(), r() } : (n && n(), r && r()) } return t } function Gg() { const e = Kg(!0); return e ? (e(), !1) : !0 } class On { constructor(t) { this.isMounted = !1, this.node = t } update() { } } function Qd(e, t) { const n = "pointer" + (t ? "enter" : "leave"), r = "onHover" + (t ? "Start" : "End"), i = (o, s) => { if (o.pointerType === "touch" || Gg()) return; const a = e.getProps(); e.animationState && a.whileHover && e.animationState.setActive("whileHover", t), a[r] && a[r](o, s) }; return Kt(e.current, n, i, { passive: !e.getProps()[r] }) } class mS extends On { mount() { this.unmount = Gt(Qd(this.node, !0), Qd(this.node, !1)) } unmount() { } } class gS extends On { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let t = !1; try { t = this.node.current.matches(":focus-visible") } catch { t = !0 } !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = Gt(Wt(this.node.current, "focus", () => this.onFocus()), Wt(this.node.current, "blur", () => this.onBlur())) } unmount() { } } const Qg = (e, t) => t ? e === t ? !0 : Qg(e, t.parentElement) : !1; function tl(e, t) { if (!t) return; const n = new PointerEvent("pointer" + e); t(n, ma(n)) } class vS extends On { constructor() { super(...arguments), this.removeStartListeners = ze, this.removeEndListeners = ze, this.removeAccessibleListeners = ze, this.startPointerPress = (t, n) => { if (this.isPressing) return; this.removeEndListeners(); const r = this.node.getProps(), o = Kt(window, "pointerup", (a, l) => { if (!this.checkPressEnd()) return; const { onTap: u, onTapCancel: c, globalTapTarget: f } = this.node.getProps(); !f && !Qg(this.node.current, a.target) ? c && c(a, l) : u && u(a, l) }, { passive: !(r.onTap || r.onPointerUp) }), s = Kt(window, "pointercancel", (a, l) => this.cancelPress(a, l), { passive: !(r.onTapCancel || r.onPointerCancel) }); this.removeEndListeners = Gt(o, s), this.startPress(t, n) }, this.startAccessiblePress = () => { const t = o => { if (o.key !== "Enter" || this.isPressing) return; const s = a => { a.key !== "Enter" || !this.checkPressEnd() || tl("up", (l, u) => { const { onTap: c } = this.node.getProps(); c && c(l, u) }) }; this.removeEndListeners(), this.removeEndListeners = Wt(this.node.current, "keyup", s), tl("down", (a, l) => { this.startPress(a, l) }) }, n = Wt(this.node.current, "keydown", t), r = () => { this.isPressing && tl("cancel", (o, s) => this.cancelPress(o, s)) }, i = Wt(this.node.current, "blur", r); this.removeAccessibleListeners = Gt(n, i) } } startPress(t, n) { this.isPressing = !0; const { onTapStart: r, whileTap: i } = this.node.getProps(); i && this.node.animationState && this.node.animationState.setActive("whileTap", !0), r && r(t, n) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !Gg() } cancelPress(t, n) { if (!this.checkPressEnd()) return; const { onTapCancel: r } = this.node.getProps(); r && r(t, n) } mount() { const t = this.node.getProps(), n = Kt(t.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(t.onTapStart || t.onPointerStart) }), r = Wt(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = Gt(n, r) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } } const pu = new WeakMap, nl = new WeakMap, yS = e => { const t = pu.get(e.target); t && t(e) }, wS = e => { e.forEach(yS) }; function xS({ root: e, ...t }) { const n = e || document; nl.has(n) || nl.set(n, {}); const r = nl.get(n), i = JSON.stringify(t); return r[i] || (r[i] = new IntersectionObserver(wS, { root: e, ...t })), r[i] } function SS(e, t, n) { const r = xS(t); return pu.set(e, n), r.observe(e), () => { pu.delete(e), r.unobserve(e) } } const CS = { some: 0, all: 1 }; class PS extends On { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: o } = t, s = { root: n ? n.current : void 0, rootMargin: r, threshold: typeof i == "number" ? i : CS[i] }, a = l => { const { isIntersecting: u } = l; if (this.isInView === u || (this.isInView = u, o && !u && this.hasEnteredView)) return; u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u); const { onViewportEnter: c, onViewportLeave: f } = this.node.getProps(), d = u ? c : f; d && d(l) }; return SS(this.node.current, s, a) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: t, prevProps: n } = this.node;["amount", "margin", "root"].some(ES(t, n)) && this.startObserver() } unmount() { } } function ES({ viewport: e = {} }, { viewport: t = {} } = {}) { return n => e[n] !== t[n] } const TS = { inView: { Feature: PS }, tap: { Feature: vS }, focus: { Feature: gS }, hover: { Feature: mS } }; function Yg(e, t) { if (!Array.isArray(t)) return !1; const n = t.length; if (n !== e.length) return !1; for (let r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } function kS(e) { const t = {}; return e.values.forEach((n, r) => t[r] = n.get()), t } function RS(e) { const t = {}; return e.values.forEach((n, r) => t[r] = n.getVelocity()), t } function ga(e, t, n) { const r = e.getProps(); return Wc(r, t, n !== void 0 ? n : r.custom, kS(e), RS(e)) } const Pn = e => e * 1e3, Qt = e => e / 1e3, LS = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, DS = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), MS = { type: "keyframes", duration: .8 }, AS = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, jS = (e, { keyframes: t }) => t.length > 2 ? MS : ur.has(e) ? e.startsWith("scale") ? DS(t[1]) : LS : AS; function NS({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: l, elapsed: u, ...c }) { return !!Object.keys(c).length } function $c(e, t) { return e[t] || e.default || e } const VS = e => e !== null; function va(e, { repeat: t, repeatType: n = "loop" }, r) { const i = e.filter(VS), o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1; return !o || r === void 0 ? i[o] : r } let ss; function FS() { ss = void 0 } const En = { now: () => (ss === void 0 && En.set(Ae.isProcessing || Ex.useManualTiming ? Ae.timestamp : performance.now()), ss), set: e => { ss = e, queueMicrotask(FS) } }, Xg = e => /^0[^.\s]+$/u.test(e); function _S(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || Xg(e) : !0 } let Zg = ze; const Jg = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), OS = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function IS(e) { const t = OS.exec(e); if (!t) return [,]; const [, n, r, i] = t; return [`--${n ?? r}`, i] } function qg(e, t, n = 1) { const [r, i] = IS(e); if (!r) return; const o = window.getComputedStyle(t).getPropertyValue(r); if (o) { const s = o.trim(); return Jg(s) ? parseFloat(s) : s } return Oc(i) ? qg(i, t, n + 1) : i } const zS = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), Yd = e => e === Zr || e === I, Xd = (e, t) => parseFloat(e.split(", ")[t]), Zd = (e, t) => (n, { transform: r }) => { if (r === "none" || !r) return 0; const i = r.match(/^matrix3d\((.+)\)$/u); if (i) return Xd(i[1], t); { const o = r.match(/^matrix\((.+)\)$/u); return o ? Xd(o[1], e) : 0 } }, US = new Set(["x", "y", "z"]), BS = go.filter(e => !US.has(e)); function Jd(e) { const t = []; return BS.forEach(n => { const r = e.getValue(n); r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), t } const Kr = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: Zd(4, 13), y: Zd(5, 14) }; Kr.translateX = Kr.x; Kr.translateY = Kr.y; const ev = e => t => t.test(e), bS = { test: e => e === "auto", parse: e => e }, tv = [Zr, I, _t, an, Gx, Kx, bS], qd = e => tv.find(ev(e)), er = new Set; let mu = !1, gu = !1; function nv() { if (gu) { const e = Array.from(er).filter(r => r.needsMeasurement), t = new Set(e.map(r => r.element)), n = new Map; t.forEach(r => { Jd(r).length && (n.set(r, Jd(r)), r.render()) }), e.forEach(r => r.measureInitialState()), t.forEach(r => { r.render() }), e.forEach(r => r.measureEndState()), e.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } gu = !1, mu = !1, er.forEach(e => e.complete()), er.clear() } function rv() { er.forEach(e => { e.readKeyframes(), e.needsMeasurement && (gu = !0) }) } function HS() { rv(), nv() } class Kc { constructor(t, n, r, i, o, s = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = o, this.isAsync = s } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (er.add(this), mu || (mu = !0, Re.read(rv), Re.resolveKeyframes(nv))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this; for (let o = 0; o < t.length; o++)if (t[o] === null) if (o === 0) { const s = i == null ? void 0 : i.get(), a = t[t.length - 1]; if (s !== void 0) t[0] = s; else if (r && n) { const l = r.readValue(n, a); l != null && (t[0] = l) } t[0] === void 0 && (t[0] = a), i && s === void 0 && i.set(t[0]) } else t[o] = t[o - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), er.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, er.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const Gc = (e, t) => n => !!(vo(n) && $x.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t)), iv = (e, t, n) => r => { if (!vo(r)) return r; const [i, o, s, a] = r.match(Ic); return { [e]: parseFloat(i), [t]: parseFloat(o), [n]: parseFloat(s), alpha: a !== void 0 ? parseFloat(a) : 1 } }, WS = e => Dn(0, 255, e), rl = { ...Zr, transform: e => Math.round(WS(e)) }, Zn = { test: Gc("rgb", "red"), parse: iv("red", "green", "blue"), transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + rl.transform(e) + ", " + rl.transform(t) + ", " + rl.transform(n) + ", " + Vi(Ni.transform(r)) + ")" }; function $S(e) { let t = "", n = "", r = "", i = ""; return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), { red: parseInt(t, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } } const vu = { test: Gc("#"), parse: $S, transform: Zn.transform }, Dr = { test: Gc("hsl", "hue"), parse: iv("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + _t.transform(Vi(t)) + ", " + _t.transform(Vi(n)) + ", " + Vi(Ni.transform(r)) + ")" }, _e = { test: e => Zn.test(e) || vu.test(e) || Dr.test(e), parse: e => Zn.test(e) ? Zn.parse(e) : Dr.test(e) ? Dr.parse(e) : vu.parse(e), transform: e => vo(e) ? e : e.hasOwnProperty("red") ? Zn.transform(e) : Dr.transform(e) }; function KS(e) { var t, n; return isNaN(e) && vo(e) && (((t = e.match(Ic)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(Wx)) === null || n === void 0 ? void 0 : n.length) || 0) > 0 } const ov = "number", sv = "color", GS = "var", QS = "var(", eh = "${}", YS = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Fs(e) { const t = e.toString(), n = [], r = { color: [], number: [], var: [] }, i = []; let o = 0; const a = t.replace(YS, l => (_e.test(l) ? (r.color.push(o), i.push(sv), n.push(_e.parse(l))) : l.startsWith(QS) ? (r.var.push(o), i.push(GS), n.push(l)) : (r.number.push(o), i.push(ov), n.push(parseFloat(l))), ++o, eh)).split(eh); return { values: n, split: a, indexes: r, types: i } } function av(e) { return Fs(e).values } function lv(e) { const { split: t, types: n } = Fs(e), r = t.length; return i => { let o = ""; for (let s = 0; s < r; s++)if (o += t[s], i[s] !== void 0) { const a = n[s]; a === ov ? o += Vi(i[s]) : a === sv ? o += _e.transform(i[s]) : o += i[s] } return o } } const XS = e => typeof e == "number" ? 0 : e; function ZS(e) { const t = av(e); return lv(e)(t.map(XS)) } const An = { test: KS, parse: av, createTransformer: lv, getAnimatableNone: ZS }, JS = new Set(["brightness", "contrast", "saturate", "opacity"]); function qS(e) { const [t, n] = e.slice(0, -1).split("("); if (t === "drop-shadow") return e; const [r] = n.match(Ic) || []; if (!r) return e; const i = n.replace(r, ""); let o = JS.has(t) ? 1 : 0; return r !== n && (o *= 100), t + "(" + o + i + ")" } const eC = /\b([a-z-]*)\(.*?\)/gu, yu = { ...An, getAnimatableNone: e => { const t = e.match(eC); return t ? t.map(qS).join(" ") : e } }, tC = { ...Vg, color: _e, backgroundColor: _e, outlineColor: _e, fill: _e, stroke: _e, borderColor: _e, borderTopColor: _e, borderRightColor: _e, borderBottomColor: _e, borderLeftColor: _e, filter: yu, WebkitFilter: yu }, Qc = e => tC[e]; function uv(e, t) { let n = Qc(e); return n !== yu && (n = An), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0 } function nC(e, t, n) { let r = 0, i; for (; r < e.length && !i;)typeof e[r] == "string" && e[r] !== "none" && e[r] !== "0" && (i = e[r]), r++; if (i && n) for (const o of t) e[o] = uv(n, i) } class cv extends Kc { constructor(t, n, r, i) { super(t, n, r, i, i == null ? void 0 : i.owner, !0) } readKeyframes() { const { unresolvedKeyframes: t, element: n, name: r } = this; if (!n.current) return; super.readKeyframes(); for (let l = 0; l < t.length; l++) { const u = t[l]; if (typeof u == "string" && Oc(u)) { const c = qg(u, n.current); c !== void 0 && (t[l] = c) } } if (!zS.has(r) || t.length !== 2) return this.resolveNoneKeyframes(); const [i, o] = t, s = qd(i), a = qd(o); if (s !== a) if (Yd(s) && Yd(a)) for (let l = 0; l < t.length; l++) { const u = t[l]; typeof u == "string" && (t[l] = parseFloat(u)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: t, name: n } = this, r = []; for (let i = 0; i < t.length; i++)_S(t[i]) && r.push(i); r.length && nC(t, r, n) } measureInitialState() { const { element: t, unresolvedKeyframes: n, name: r } = this; if (!t.current) return; r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Kr[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin; const i = n[n.length - 1]; i !== void 0 && t.getValue(r, i).jump(i, !1) } measureEndState() { var t; const { element: n, name: r, unresolvedKeyframes: i } = this; if (!n.current) return; const o = n.getValue(r); o && o.jump(this.measuredOrigin, !1); const s = i.length - 1, a = i[s]; i[s] = Kr[r](n.measureViewportBox(), window.getComputedStyle(n.current)), a !== null && (this.finalKeyframe = a), !((t = this.removedTransforms) === null || t === void 0) && t.length && this.removedTransforms.forEach(([l, u]) => { n.getValue(l).set(u) }), this.resolveNoneKeyframes() } } function rC(e) { let t; return () => (t === void 0 && (t = e()), t) } const th = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (An.test(e) || e === "0") && !e.startsWith("url(")); function iC(e) { const t = e[0]; if (e.length === 1) return !0; for (let n = 0; n < e.length; n++)if (e[n] !== t) return !0 } function oC(e, t, n, r) { const i = e[0]; if (i === null) return !1; const o = e[e.length - 1], s = th(i, t), a = th(o, t); return !s || !a ? !1 : iC(e) || n === "spring" && r } class fv { constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: o = 0, repeatType: s = "loop", ...a }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.options = { autoplay: t, delay: n, type: r, repeat: i, repeatDelay: o, repeatType: s, ...a }, this.updateFinishedPromise() } get resolved() { return !this._resolved && !this.hasAttemptedResolve && HS(), this._resolved } onKeyframesResolved(t, n) { this.hasAttemptedResolve = !0; const { name: r, type: i, velocity: o, delay: s, onComplete: a, onUpdate: l, isGenerator: u } = this.options; if (!u && !oC(t, r, i, o)) if (s) this.options.duration = 0; else { l == null || l(va(t, this.options, n)), a == null || a(), this.resolveFinishedPromise(); return } const c = this.initPlayback(t, n); c !== !1 && (this._resolved = { keyframes: t, finalKeyframe: n, ...c }, this.onPostResolved()) } onPostResolved() { } then(t, n) { return this.currentFinishedPromise.then(t, n) } updateFinishedPromise() { this.currentFinishedPromise = new Promise(t => { this.resolveFinishedPromise = t }) } } function dv(e, t) { return t ? e * (1e3 / t) : 0 } const sC = 5; function hv(e, t, n) { const r = Math.max(t - sC, 0); return dv(n - e(r), t - r) } const il = .001, aC = .01, lC = 10, uC = .05, cC = 1; function fC({ duration: e = 800, bounce: t = .25, velocity: n = 0, mass: r = 1 }) { let i, o, s = 1 - t; s = Dn(uC, cC, s), e = Dn(aC, lC, Qt(e)), s < 1 ? (i = u => { const c = u * s, f = c * e, d = c - n, g = wu(u, s), v = Math.exp(-f); return il - d / g * v }, o = u => { const f = u * s * e, d = f * n + n, g = Math.pow(s, 2) * Math.pow(u, 2) * e, v = Math.exp(-f), y = wu(Math.pow(u, 2), s); return (-i(u) + il > 0 ? -1 : 1) * ((d - g) * v) / y }) : (i = u => { const c = Math.exp(-u * e), f = (u - n) * e + 1; return -il + c * f }, o = u => { const c = Math.exp(-u * e), f = (n - u) * (e * e); return c * f }); const a = 5 / e, l = hC(i, o, a); if (e = Pn(e), isNaN(l)) return { stiffness: 100, damping: 10, duration: e }; { const u = Math.pow(l, 2) * r; return { stiffness: u, damping: s * 2 * Math.sqrt(r * u), duration: e } } } const dC = 12; function hC(e, t, n) { let r = n; for (let i = 1; i < dC; i++)r = r - e(r) / t(r); return r } function wu(e, t) { return e * Math.sqrt(1 - t * t) } const pC = ["duration", "bounce"], mC = ["stiffness", "damping", "mass"]; function nh(e, t) { return t.some(n => e[n] !== void 0) } function gC(e) { let t = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...e }; if (!nh(e, mC) && nh(e, pC)) { const n = fC(e); t = { ...t, ...n, mass: 1 }, t.isResolvedFromDuration = !0 } return t } function pv({ keyframes: e, restDelta: t, restSpeed: n, ...r }) { const i = e[0], o = e[e.length - 1], s = { done: !1, value: i }, { stiffness: a, damping: l, mass: u, duration: c, velocity: f, isResolvedFromDuration: d } = gC({ ...r, velocity: -Qt(r.velocity || 0) }), g = f || 0, v = l / (2 * Math.sqrt(a * u)), y = o - i, S = Qt(Math.sqrt(a / u)), p = Math.abs(y) < 5; n || (n = p ? .01 : 2), t || (t = p ? .005 : .5); let h; if (v < 1) { const m = wu(S, v); h = P => { const R = Math.exp(-v * S * P); return o - R * ((g + v * S * y) / m * Math.sin(m * P) + y * Math.cos(m * P)) } } else if (v === 1) h = m => o - Math.exp(-S * m) * (y + (g + S * y) * m); else { const m = S * Math.sqrt(v * v - 1); h = P => { const R = Math.exp(-v * S * P), w = Math.min(m * P, 300); return o - R * ((g + v * S * y) * Math.sinh(w) + m * y * Math.cosh(w)) / m } } return { calculatedDuration: d && c || null, next: m => { const P = h(m); if (d) s.done = m >= c; else { let R = g; m !== 0 && (v < 1 ? R = hv(h, m, P) : R = 0); const w = Math.abs(R) <= n, D = Math.abs(o - P) <= t; s.done = w && D } return s.value = s.done ? o : P, s } } } function rh({ keyframes: e, velocity: t = 0, power: n = .8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: a, max: l, restDelta: u = .5, restSpeed: c }) { const f = e[0], d = { done: !1, value: f }, g = k => a !== void 0 && k < a || l !== void 0 && k > l, v = k => a === void 0 ? l : l === void 0 || Math.abs(a - k) < Math.abs(l - k) ? a : l; let y = n * t; const S = f + y, p = s === void 0 ? S : s(S); p !== S && (y = p - f); const h = k => -y * Math.exp(-k / r), m = k => p + h(k), P = k => { const j = h(k), V = m(k); d.done = Math.abs(j) <= u, d.value = d.done ? p : V }; let R, w; const D = k => { g(d.value) && (R = k, w = pv({ keyframes: [d.value, v(d.value)], velocity: hv(m, k, d.value), damping: i, stiffness: o, restDelta: u, restSpeed: c })) }; return D(0), { calculatedDuration: null, next: k => { let j = !1; return !w && R === void 0 && (j = !0, P(k), D(k)), R !== void 0 && k >= R ? w.next(k - R) : (!j && P(k), d) } } } const mv = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, vC = 1e-7, yC = 12; function wC(e, t, n, r, i) { let o, s, a = 0; do s = t + (n - t) / 2, o = mv(s, r, i) - e, o > 0 ? n = s : t = s; while (Math.abs(o) > vC && ++a < yC); return s } function wo(e, t, n, r) { if (e === t && n === r) return ze; const i = o => wC(o, 0, 1, e, n); return o => o === 0 || o === 1 ? o : mv(i(o), t, r) } const xC = wo(.42, 0, 1, 1), SC = wo(0, 0, .58, 1), gv = wo(.42, 0, .58, 1), CC = e => Array.isArray(e) && typeof e[0] != "number", vv = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, yv = e => t => 1 - e(1 - t), Yc = e => 1 - Math.sin(Math.acos(e)), wv = yv(Yc), PC = vv(Yc), xv = wo(.33, 1.53, .69, .99), Xc = yv(xv), EC = vv(Xc), TC = e => (e *= 2) < 1 ? .5 * Xc(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))), kC = { linear: ze, easeIn: xC, easeInOut: gv, easeOut: SC, circIn: Yc, circInOut: PC, circOut: wv, backIn: Xc, backInOut: EC, backOut: xv, anticipate: TC }, ih = e => { if (Array.isArray(e)) { Zg(e.length === 4); const [t, n, r, i] = e; return wo(t, n, r, i) } else if (typeof e == "string") return kC[e]; return e }, so = (e, t, n) => { const r = t - e; return r === 0 ? 1 : (n - e) / r }, le = (e, t, n) => e + (t - e) * n; function ol(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function RC({ hue: e, saturation: t, lightness: n, alpha: r }) { e /= 360, t /= 100, n /= 100; let i = 0, o = 0, s = 0; if (!t) i = o = s = n; else { const a = n < .5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a; i = ol(l, a, e + 1 / 3), o = ol(l, a, e), s = ol(l, a, e - 1 / 3) } return { red: Math.round(i * 255), green: Math.round(o * 255), blue: Math.round(s * 255), alpha: r } } const sl = (e, t, n) => { const r = e * e, i = n * (t * t - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, LC = [vu, Zn, Dr], DC = e => LC.find(t => t.test(e)); function oh(e) { const t = DC(e); let n = t.parse(e); return t === Dr && (n = RC(n)), n } const sh = (e, t) => { const n = oh(e), r = oh(t), i = { ...n }; return o => (i.red = sl(n.red, r.red, o), i.green = sl(n.green, r.green, o), i.blue = sl(n.blue, r.blue, o), i.alpha = le(n.alpha, r.alpha, o), Zn.transform(i)) }; function xu(e, t) { return n => n > 0 ? t : e } function MC(e, t) { return n => le(e, t, n) } function Zc(e) { return typeof e == "number" ? MC : typeof e == "string" ? Oc(e) ? xu : _e.test(e) ? sh : NC : Array.isArray(e) ? Sv : typeof e == "object" ? _e.test(e) ? sh : AC : xu } function Sv(e, t) { const n = [...e], r = n.length, i = e.map((o, s) => Zc(o)(o, t[s])); return o => { for (let s = 0; s < r; s++)n[s] = i[s](o); return n } } function AC(e, t) { const n = { ...e, ...t }, r = {}; for (const i in n) e[i] !== void 0 && t[i] !== void 0 && (r[i] = Zc(e[i])(e[i], t[i])); return i => { for (const o in r) n[o] = r[o](i); return n } } function jC(e, t) { var n; const r = [], i = { color: 0, var: 0, number: 0 }; for (let o = 0; o < t.values.length; o++) { const s = t.types[o], a = e.indexes[s][i[s]], l = (n = e.values[a]) !== null && n !== void 0 ? n : 0; r[o] = l, i[s]++ } return r } const NC = (e, t) => { const n = An.createTransformer(t), r = Fs(e), i = Fs(t); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? Gt(Sv(jC(r, i), i.values), n) : xu(e, t) }; function Cv(e, t, n) { return typeof e == "number" && typeof t == "number" && typeof n == "number" ? le(e, t, n) : Zc(e)(e, t) } function VC(e, t, n) { const r = [], i = n || Cv, o = e.length - 1; for (let s = 0; s < o; s++) { let a = i(e[s], e[s + 1]); if (t) { const l = Array.isArray(t) ? t[s] || ze : t; a = Gt(l, a) } r.push(a) } return r } function FC(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) { const o = e.length; if (Zg(o === t.length), o === 1) return () => t[0]; if (o === 2 && e[0] === e[1]) return () => t[1]; e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse()); const s = VC(t, r, i), a = s.length, l = u => { let c = 0; if (a > 1) for (; c < e.length - 2 && !(u < e[c + 1]); c++); const f = so(e[c], e[c + 1], u); return s[c](f) }; return n ? u => l(Dn(e[0], e[o - 1], u)) : l } function _C(e, t) { const n = e[e.length - 1]; for (let r = 1; r <= t; r++) { const i = so(0, t, r); e.push(le(n, 1, i)) } } function OC(e) { const t = [0]; return _C(t, e.length - 1), t } function IC(e, t) { return e.map(n => n * t) } function zC(e, t) { return e.map(() => t || gv).splice(0, e.length - 1) } function _s({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) { const i = CC(r) ? r.map(ih) : ih(r), o = { done: !1, value: t[0] }, s = IC(n && n.length === t.length ? n : OC(t), e), a = FC(s, t, { ease: Array.isArray(i) ? i : zC(t, i) }); return { calculatedDuration: e, next: l => (o.value = a(l), o.done = l >= e, o) } } const ah = 2e4; function UC(e) { let t = 0; const n = 50; let r = e.next(t); for (; !r.done && t < ah;)t += n, r = e.next(t); return t >= ah ? 1 / 0 : t } const BC = e => { const t = ({ timestamp: n }) => e(n); return { start: () => Re.update(t, !0), stop: () => Mn(t), now: () => Ae.isProcessing ? Ae.timestamp : En.now() } }, bC = { decay: rh, inertia: rh, tween: _s, keyframes: _s, spring: pv }, HC = e => e / 100; class Jc extends fv { constructor({ KeyframeResolver: t = Kc, ...n }) { super(n), this.holdTime = null, this.startTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.state = "idle"; const { name: r, motionValue: i, keyframes: o } = this.options, s = (a, l) => this.onKeyframesResolved(a, l); r && i && i.owner ? this.resolver = i.owner.resolveKeyframes(o, s, r, i) : this.resolver = new t(o, s, r, i), this.resolver.scheduleResolve() } initPlayback(t) { const { type: n = "keyframes", repeat: r = 0, repeatDelay: i = 0, repeatType: o, velocity: s = 0 } = this.options, a = bC[n] || _s; let l, u; a !== _s && typeof t[0] != "number" && (l = Gt(HC, Cv(t[0], t[1])), t = [0, 100]); const c = a({ ...this.options, keyframes: t }); o === "mirror" && (u = a({ ...this.options, keyframes: [...t].reverse(), velocity: -s })), c.calculatedDuration === null && (c.calculatedDuration = UC(c)); const { calculatedDuration: f } = c, d = f + i, g = d * (r + 1) - i; return { generator: c, mirroredGenerator: u, mapPercentToKeyframes: l, calculatedDuration: f, resolvedDuration: d, totalDuration: g } } onPostResolved() { const { autoplay: t = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState } tick(t, n = !1) { const { resolved: r } = this; if (!r) { const { keyframes: k } = this.options; return { done: !0, value: k[k.length - 1] } } const { finalKeyframe: i, generator: o, mirroredGenerator: s, mapPercentToKeyframes: a, keyframes: l, calculatedDuration: u, totalDuration: c, resolvedDuration: f } = r; if (this.startTime === null) return o.next(0); const { delay: d, repeat: g, repeatType: v, repeatDelay: y, onUpdate: S } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - c / this.speed, this.startTime)), n ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed; const p = this.currentTime - d * (this.speed >= 0 ? 1 : -1), h = this.speed >= 0 ? p < 0 : p > c; this.currentTime = Math.max(p, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = c); let m = this.currentTime, P = o; if (g) { const k = Math.min(this.currentTime, c) / f; let j = Math.floor(k), V = k % 1; !V && k >= 1 && (V = 1), V === 1 && j--, j = Math.min(j, g + 1), !!(j % 2) && (v === "reverse" ? (V = 1 - V, y && (V -= y / f)) : v === "mirror" && (P = s)), m = Dn(0, 1, V) * f } const R = h ? { done: !1, value: l[0] } : P.next(m); a && (R.value = a(R.value)); let { done: w } = R; !h && u !== null && (w = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0); const D = this.holdTime === null && (this.state === "finished" || this.state === "running" && w); return D && i !== void 0 && (R.value = va(l, this.options, i)), S && S(R.value), D && this.finish(), R } get duration() { const { resolved: t } = this; return t ? Qt(t.calculatedDuration) : 0 } get time() { return Qt(this.currentTime) } set time(t) { t = Pn(t), this.currentTime = t, this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed) } get speed() { return this.playbackSpeed } set speed(t) { const n = this.playbackSpeed !== t; this.playbackSpeed = t, n && (this.time = Qt(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; const { driver: t = BC, onPlay: n } = this.options; this.driver || (this.driver = t(i => this.tick(i))), n && n(); const r = this.driver.now(); this.holdTime !== null ? this.startTime = r - this.holdTime : (!this.startTime || this.state === "finished") && (this.startTime = r), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var t; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0 } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); const { onStop: t } = this.options; t && t() } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: t } = this.options; t && t() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(t) { return this.startTime = 0, this.tick(t, !0) } } const Pv = e => Array.isArray(e) && typeof e[0] == "number"; function Ev(e) { return !!(!e || typeof e == "string" && Tv[e] || Pv(e) || Array.isArray(e) && e.every(Ev)) } const Ci = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, Tv = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: Ci([0, .65, .55, 1]), circOut: Ci([.55, 0, 1, .45]), backIn: Ci([.31, .01, .66, -.59]), backOut: Ci([.33, 1.53, .69, .99]) }; function kv(e) { if (e) return Pv(e) ? Ci(e) : Array.isArray(e) ? e.map(kv) : Tv[e] } function WC(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: a, times: l } = {}) { const u = { [t]: n }; l && (u.offset = l); const c = kv(a); return Array.isArray(c) && (u.easing = c), e.animate(u, { delay: r, duration: i, easing: Array.isArray(c) ? "linear" : c, fill: "both", iterations: o + 1, direction: s === "reverse" ? "alternate" : "normal" }) } const $C = rC(() => Object.hasOwnProperty.call(Element.prototype, "animate")), KC = new Set(["opacity", "clipPath", "filter", "transform"]), Os = 10, GC = 2e4; function QC(e) { return e.type === "spring" || e.name === "backgroundColor" || !Ev(e.ease) } function YC(e, t) { const n = new Jc({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 }); let r = { done: !1, value: e[0] }; const i = []; let o = 0; for (; !r.done && o < GC;)r = n.sample(o), i.push(r.value), o += Os; return { times: void 0, keyframes: i, duration: o - Os, ease: "linear" } } class lh extends fv { constructor(t) { super(t); const { name: n, motionValue: r, keyframes: i } = this.options; this.resolver = new cv(i, (o, s) => this.onKeyframesResolved(o, s), n, r), this.resolver.scheduleResolve() } initPlayback(t, n) { var r; let { duration: i = 300, times: o, ease: s, type: a, motionValue: l, name: u } = this.options; if (!(!((r = l.owner) === null || r === void 0) && r.current)) return !1; if (QC(this.options)) { const { onComplete: f, onUpdate: d, motionValue: g, ...v } = this.options, y = YC(t, v); t = y.keyframes, t.length === 1 && (t[1] = t[0]), i = y.duration, o = y.times, s = y.ease, a = "keyframes" } const c = WC(l.owner.current, u, t, { ...this.options, duration: i, times: o, ease: s }); return c.startTime = En.now(), this.pendingTimeline ? (c.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : c.onfinish = () => { const { onComplete: f } = this.options; l.set(va(t, this.options, n)), f && f(), this.cancel(), this.resolveFinishedPromise() }, { animation: c, duration: i, times: o, type: a, ease: s, keyframes: t } } get duration() { const { resolved: t } = this; if (!t) return 0; const { duration: n } = t; return Qt(n) } get time() { const { resolved: t } = this; if (!t) return 0; const { animation: n } = t; return Qt(n.currentTime || 0) } set time(t) { const { resolved: n } = this; if (!n) return; const { animation: r } = n; r.currentTime = Pn(t) } get speed() { const { resolved: t } = this; if (!t) return 1; const { animation: n } = t; return n.playbackRate } set speed(t) { const { resolved: n } = this; if (!n) return; const { animation: r } = n; r.playbackRate = t } get state() { const { resolved: t } = this; if (!t) return "idle"; const { animation: n } = t; return n.playState } attachTimeline(t) { if (!this._resolved) this.pendingTimeline = t; else { const { resolved: n } = this; if (!n) return ze; const { animation: r } = n; r.timeline = t, r.onfinish = null } return ze } play() { if (this.isStopped) return; const { resolved: t } = this; if (!t) return; const { animation: n } = t; n.playState === "finished" && this.updateFinishedPromise(), n.play() } pause() { const { resolved: t } = this; if (!t) return; const { animation: n } = t; n.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; const { resolved: t } = this; if (!t) return; const { animation: n, keyframes: r, duration: i, type: o, ease: s, times: a } = t; if (!(n.playState === "idle" || n.playState === "finished")) { if (this.time) { const { motionValue: l, onUpdate: u, onComplete: c, ...f } = this.options, d = new Jc({ ...f, keyframes: r, duration: i, type: o, ease: s, times: a, isGenerator: !0 }), g = Pn(this.time); l.setWithVelocity(d.sample(g - Os).value, d.sample(g).value, Os) } this.cancel() } } complete() { const { resolved: t } = this; t && t.animation.finish() } cancel() { const { resolved: t } = this; t && t.animation.cancel() } static supports(t) { const { motionValue: n, name: r, repeatDelay: i, repeatType: o, damping: s, type: a } = t; return $C() && r && KC.has(r) && n && n.owner && n.owner.current instanceof HTMLElement && !n.owner.getProps().onUpdate && !i && o !== "mirror" && s !== 0 && a !== "inertia" } } const qc = (e, t, n, r = {}, i, o) => s => { const a = $c(r, e) || {}, l = a.delay || r.delay || 0; let { elapsed: u = 0 } = r; u = u - Pn(l); let c = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: t.getVelocity(), ...a, delay: -u, onUpdate: d => { t.set(d), a.onUpdate && a.onUpdate(d) }, onComplete: () => { s(), a.onComplete && a.onComplete() }, name: e, motionValue: t, element: o ? void 0 : i }; NS(a) || (c = { ...c, ...jS(e, c) }), c.duration && (c.duration = Pn(c.duration)), c.repeatDelay && (c.repeatDelay = Pn(c.repeatDelay)), c.from !== void 0 && (c.keyframes[0] = c.from); let f = !1; if ((c.type === !1 || c.duration === 0 && !c.repeatDelay) && (c.duration = 0, c.delay === 0 && (f = !0)), f && !o && t.get() !== void 0) { const d = va(c.keyframes, a); if (d !== void 0) { Re.update(() => { c.onUpdate(d), c.onComplete() }); return } } return !o && lh.supports(c) ? new lh(c) : new Jc(c) }; function Is(e) { return !!(Ie(e) && e.add) } function ef(e, t) { e.indexOf(t) === -1 && e.push(t) } function tf(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } class nf { constructor() { this.subscriptions = [] } add(t) { return ef(this.subscriptions, t), () => tf(this.subscriptions, t) } notify(t, n, r) { const i = this.subscriptions.length; if (i) if (i === 1) this.subscriptions[0](t, n, r); else for (let o = 0; o < i; o++) { const s = this.subscriptions[o]; s && s(t, n, r) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const uh = 30, XC = e => !isNaN(parseFloat(e)); class ZC { constructor(t, n = {}) { this.version = "11.0.27", this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (r, i = !0) => { const o = En.now(); this.updatedAt !== o && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(t), this.canTrackVelocity = XC(this.current), this.owner = n.owner } setCurrent(t) { this.current = t, this.updatedAt = En.now() } setPrevFrameValue(t = this.current) { this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt } onChange(t) { return this.on("change", t) } on(t, n) { this.events[t] || (this.events[t] = new nf); const r = this.events[t].add(n); return t === "change" ? () => { r(), Re.read(() => { this.events.change.getSize() || this.stop() }) } : r } clearListeners() { for (const t in this.events) this.events[t].clear() } attach(t, n) { this.passiveEffect = t, this.stopPassiveEffect = n } set(t, n = !0) { !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify) } setWithVelocity(t, n, r) { this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r } jump(t, n = !0) { this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const t = En.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > uh) return 0; const n = Math.min(this.updatedAt - this.prevUpdatedAt, uh); return dv(parseFloat(this.current) - parseFloat(this.prevFrameValue), n) } start(t) { return this.stop(), new Promise(n => { this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function ao(e, t) { return new ZC(e, t) } function JC(e, t, n) { e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, ao(n)) } function qC(e, t) { const n = ga(e, t); let { transitionEnd: r = {}, transition: i = {}, ...o } = n || {}; o = { ...o, ...r }; for (const s in o) { const a = aS(o[s]); JC(e, s, a) } } function eP({ protectedKeys: e, needsAnimating: t }, n) { const r = e.hasOwnProperty(n) && t[n] !== !0; return t[n] = !1, r } function Rv(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) { var o; let { transition: s = e.getDefaultTransition(), transitionEnd: a, ...l } = t; const u = e.getValue("willChange"); r && (s = r); const c = [], f = i && e.animationState && e.animationState.getState()[i]; for (const d in l) { const g = e.getValue(d, (o = e.latestValues[d]) !== null && o !== void 0 ? o : null), v = l[d]; if (v === void 0 || f && eP(f, d)) continue; const y = { delay: n, elapsed: 0, ...$c(s || {}, d) }; let S = !1; if (window.HandoffAppearAnimations) { const h = e.getProps()[Rg]; if (h) { const m = window.HandoffAppearAnimations(h, d); m !== null && (y.elapsed = m, S = !0) } } g.start(qc(d, g, v, e.shouldReduceMotion && ur.has(d) ? { type: !1 } : y, e, S)); const p = g.animation; p && (Is(u) && (u.add(d), p.then(() => u.remove(d))), c.push(p)) } return a && Promise.all(c).then(() => { Re.update(() => { a && qC(e, a) }) }), c } function Su(e, t, n = {}) { var r; const i = ga(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0); let { transition: o = e.getDefaultTransition() || {} } = i || {}; n.transitionOverride && (o = n.transitionOverride); const s = i ? () => Promise.all(Rv(e, i, n)) : () => Promise.resolve(), a = e.variantChildren && e.variantChildren.size ? (u = 0) => { const { delayChildren: c = 0, staggerChildren: f, staggerDirection: d } = o; return tP(e, t, c + u, f, d, n) } : () => Promise.resolve(), { when: l } = o; if (l) { const [u, c] = l === "beforeChildren" ? [s, a] : [a, s]; return u().then(() => c()) } else return Promise.all([s(), a(n.delay)]) } function tP(e, t, n = 0, r = 0, i = 1, o) { const s = [], a = (e.variantChildren.size - 1) * r, l = i === 1 ? (u = 0) => u * r : (u = 0) => a - u * r; return Array.from(e.variantChildren).sort(nP).forEach((u, c) => { u.notify("AnimationStart", t), s.push(Su(u, t, { ...o, delay: n + l(c) }).then(() => u.notify("AnimationComplete", t))) }), Promise.all(s) } function nP(e, t) { return e.sortNodePosition(t) } function rP(e, t, n = {}) { e.notify("AnimationStart", t); let r; if (Array.isArray(t)) { const i = t.map(o => Su(e, o, n)); r = Promise.all(i) } else if (typeof t == "string") r = Su(e, t, n); else { const i = typeof t == "function" ? ga(e, t, n.custom) : t; r = Promise.all(Rv(e, i, n)) } return r.then(() => { Re.postRender(() => { e.notify("AnimationComplete", t) }) }) } const iP = [...Nc].reverse(), oP = Nc.length; function sP(e) { return t => Promise.all(t.map(({ animation: n, options: r }) => rP(e, n, r))) } function aP(e) { let t = sP(e); const n = uP(); let r = !0; const i = l => (u, c) => { var f; const d = ga(e, c, l === "exit" ? (f = e.presenceContext) === null || f === void 0 ? void 0 : f.custom : void 0); if (d) { const { transition: g, transitionEnd: v, ...y } = d; u = { ...u, ...y, ...v } } return u }; function o(l) { t = l(e) } function s(l) { const u = e.getProps(), c = e.getVariantContext(!0) || {}, f = [], d = new Set; let g = {}, v = 1 / 0; for (let S = 0; S < oP; S++) { const p = iP[S], h = n[p], m = u[p] !== void 0 ? u[p] : c[p], P = io(m), R = p === l ? h.isActive : null; R === !1 && (v = S); let w = m === c[p] && m !== u[p] && P; if (w && r && e.manuallyAnimateOnMount && (w = !1), h.protectedKeys = { ...g }, !h.isActive && R === null || !m && !h.prevProp || ha(m) || typeof m == "boolean") continue; let k = lP(h.prevProp, m) || p === l && h.isActive && !w && P || S > v && P, j = !1; const V = Array.isArray(m) ? m : [m]; let W = V.reduce(i(p), {}); R === !1 && (W = {}); const { prevResolvedValues: fe = {} } = h, de = { ...fe, ...W }, Be = he => { k = !0, d.has(he) && (j = !0, d.delete(he)), h.needsAnimating[he] = !0; const Ce = e.getValue(he); Ce && (Ce.liveStyle = !1) }; for (const he in de) { const Ce = W[he], J = fe[he]; if (g.hasOwnProperty(he)) continue; let N = !1; hu(Ce) && hu(J) ? N = !Yg(Ce, J) : N = Ce !== J, N ? Ce != null ? Be(he) : d.add(he) : Ce !== void 0 && d.has(he) ? Be(he) : h.protectedKeys[he] = !0 } h.prevProp = m, h.prevResolvedValues = W, h.isActive && (g = { ...g, ...W }), r && e.blockInitialAnimation && (k = !1), k && (!w || j) && f.push(...V.map(he => ({ animation: he, options: { type: p } }))) } if (d.size) { const S = {}; d.forEach(p => { const h = e.getBaseTarget(p), m = e.getValue(p); m && (m.liveStyle = !0), S[p] = h === void 0 ? null : h }), f.push({ animation: S }) } let y = !!f.length; return r && (u.initial === !1 || u.initial === u.animate) && !e.manuallyAnimateOnMount && (y = !1), r = !1, y ? t(f) : Promise.resolve() } function a(l, u) { var c; if (n[l].isActive === u) return Promise.resolve(); (c = e.variantChildren) === null || c === void 0 || c.forEach(d => { var g; return (g = d.animationState) === null || g === void 0 ? void 0 : g.setActive(l, u) }), n[l].isActive = u; const f = s(l); for (const d in n) n[d].protectedKeys = {}; return f } return { animateChanges: s, setActive: a, setAnimateFunction: o, getState: () => n } } function lP(e, t) { return typeof t == "string" ? t !== e : Array.isArray(t) ? !Yg(t, e) : !1 } function Un(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function uP() { return { animate: Un(!0), whileInView: Un(), whileHover: Un(), whileTap: Un(), whileDrag: Un(), whileFocus: Un(), exit: Un() } } class cP extends On { constructor(t) { super(t), t.animationState || (t.animationState = aP(t)) } updateAnimationControlsSubscription() { const { animate: t } = this.node.getProps(); this.unmount(), ha(t) && (this.unmount = t.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {}; t !== n && this.updateAnimationControlsSubscription() } unmount() { } } let fP = 0; class dP extends On { constructor() { super(...arguments), this.id = fP++ } update() { if (!this.node.presenceContext) return; const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || t === r) return; const i = this.node.animationState.setActive("exit", !t); n && !t && i.then(() => n(this.id)) } mount() { const { register: t } = this.node.presenceContext || {}; t && (this.unmount = t(this.id)) } unmount() { } } const hP = { animation: { Feature: cP }, exit: { Feature: dP } }, ch = (e, t) => Math.abs(e - t); function pP(e, t) { const n = ch(e.x, t.x), r = ch(e.y, t.y); return Math.sqrt(n ** 2 + r ** 2) } class Lv { constructor(t, n, { transformPagePoint: r, contextWindow: i, dragSnapToOrigin: o = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const f = ll(this.lastMoveEventInfo, this.history), d = this.startEvent !== null, g = pP(f.offset, { x: 0, y: 0 }) >= 3; if (!d && !g) return; const { point: v } = f, { timestamp: y } = Ae; this.history.push({ ...v, timestamp: y }); const { onStart: S, onMove: p } = this.handlers; d || (S && S(this.lastMoveEvent, f), this.startEvent = this.lastMoveEvent), p && p(this.lastMoveEvent, f) }, this.handlePointerMove = (f, d) => { this.lastMoveEvent = f, this.lastMoveEventInfo = al(d, this.transformPagePoint), Re.update(this.updatePoint, !0) }, this.handlePointerUp = (f, d) => { this.end(); const { onEnd: g, onSessionEnd: v, resumeAnimation: y } = this.handlers; if (this.dragSnapToOrigin && y && y(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const S = ll(f.type === "pointercancel" ? this.lastMoveEventInfo : al(d, this.transformPagePoint), this.history); this.startEvent && g && g(f, S), v && v(f, S) }, !Wg(t)) return; this.dragSnapToOrigin = o, this.handlers = n, this.transformPagePoint = r, this.contextWindow = i || window; const s = ma(t), a = al(s, this.transformPagePoint), { point: l } = a, { timestamp: u } = Ae; this.history = [{ ...l, timestamp: u }]; const { onSessionStart: c } = n; c && c(t, ll(a, this.history)), this.removeListeners = Gt(Kt(this.contextWindow, "pointermove", this.handlePointerMove), Kt(this.contextWindow, "pointerup", this.handlePointerUp), Kt(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(t) { this.handlers = t } end() { this.removeListeners && this.removeListeners(), Mn(this.updatePoint) } } function al(e, t) { return t ? { point: t(e.point) } : e } function fh(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function ll({ point: e }, t) { return { point: e, delta: fh(e, Dv(t)), offset: fh(e, mP(t)), velocity: gP(t, .1) } } function mP(e) { return e[0] } function Dv(e) { return e[e.length - 1] } function gP(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let n = e.length - 1, r = null; const i = Dv(e); for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > Pn(t)));)n--; if (!r) return { x: 0, y: 0 }; const o = Qt(i.timestamp - r.timestamp); if (o === 0) return { x: 0, y: 0 }; const s = { x: (i.x - r.x) / o, y: (i.y - r.y) / o }; return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s } function ot(e) { return e.max - e.min } function Cu(e, t = 0, n = .01) { return Math.abs(e - t) <= n } function dh(e, t, n, r = .5) { e.origin = r, e.originPoint = le(t.min, t.max, e.origin), e.scale = ot(n) / ot(t), (Cu(e.scale, 1, 1e-4) || isNaN(e.scale)) && (e.scale = 1), e.translate = le(n.min, n.max, e.origin) - e.originPoint, (Cu(e.translate) || isNaN(e.translate)) && (e.translate = 0) } function Fi(e, t, n, r) { dh(e.x, t.x, n.x, r ? r.originX : void 0), dh(e.y, t.y, n.y, r ? r.originY : void 0) } function hh(e, t, n) { e.min = n.min + t.min, e.max = e.min + ot(t) } function vP(e, t, n) { hh(e.x, t.x, n.x), hh(e.y, t.y, n.y) } function ph(e, t, n) { e.min = t.min - n.min, e.max = e.min + ot(t) } function _i(e, t, n) { ph(e.x, t.x, n.x), ph(e.y, t.y, n.y) } function yP(e, { min: t, max: n }, r) { return t !== void 0 && e < t ? e = r ? le(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? le(n, e, r.max) : Math.min(e, n)), e } function mh(e, t, n) { return { min: t !== void 0 ? e.min + t : void 0, max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0 } } function wP(e, { top: t, left: n, bottom: r, right: i }) { return { x: mh(e.x, n, i), y: mh(e.y, t, r) } } function gh(e, t) { let n = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r } } function xP(e, t) { return { x: gh(e.x, t.x), y: gh(e.y, t.y) } } function SP(e, t) { let n = .5; const r = ot(e), i = ot(t); return i > r ? n = so(t.min, t.max - r, e.min) : r > i && (n = so(e.min, e.max - i, t.min)), Dn(0, 1, n) } function CP(e, t) { const n = {}; return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n } const Pu = .35; function PP(e = Pu) { return e === !1 ? e = 0 : e === !0 && (e = Pu), { x: vh(e, "left", "right"), y: vh(e, "top", "bottom") } } function vh(e, t, n) { return { min: yh(e, t), max: yh(e, n) } } function yh(e, t) { return typeof e == "number" ? e : e[t] || 0 } const wh = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Mr = () => ({ x: wh(), y: wh() }), xh = () => ({ min: 0, max: 0 }), ge = () => ({ x: xh(), y: xh() }); function ut(e) { return [e("x"), e("y")] } function Mv({ top: e, left: t, right: n, bottom: r }) { return { x: { min: t, max: n }, y: { min: e, max: r } } } function EP({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function TP(e, t) { if (!t) return e; const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function ul(e) { return e === void 0 || e === 1 } function Eu({ scale: e, scaleX: t, scaleY: n }) { return !ul(e) || !ul(t) || !ul(n) } function Hn(e) { return Eu(e) || Av(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function Av(e) { return Sh(e.x) || Sh(e.y) } function Sh(e) { return e && e !== "0%" } function zs(e, t, n) { const r = e - n, i = t * r; return n + i } function Ch(e, t, n, r, i) { return i !== void 0 && (e = zs(e, i, r)), zs(e, n, r) + t } function Tu(e, t = 0, n = 1, r, i) { e.min = Ch(e.min, t, n, r, i), e.max = Ch(e.max, t, n, r, i) } function jv(e, { x: t, y: n }) { Tu(e.x, t.translate, t.scale, t.originPoint), Tu(e.y, n.translate, n.scale, n.originPoint) } function kP(e, t, n, r = !1) { const i = n.length; if (!i) return; t.x = t.y = 1; let o, s; for (let a = 0; a < i; a++) { o = n[a], s = o.projectionDelta; const l = o.instance; l && l.style && l.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && Ar(e, { x: -o.scroll.offset.x, y: -o.scroll.offset.y }), s && (t.x *= s.x.scale, t.y *= s.y.scale, jv(e, s)), r && Hn(o.latestValues) && Ar(e, o.latestValues)) } t.x = Ph(t.x), t.y = Ph(t.y) } function Ph(e) { return Number.isInteger(e) || e > 1.0000000000001 || e < .999999999999 ? e : 1 } function cn(e, t) { e.min = e.min + t, e.max = e.max + t } function Eh(e, t, [n, r, i]) { const o = t[i] !== void 0 ? t[i] : .5, s = le(e.min, e.max, o); Tu(e, t[n], t[r], s, t.scale) } const RP = ["x", "scaleX", "originX"], LP = ["y", "scaleY", "originY"]; function Ar(e, t) { Eh(e.x, t, RP), Eh(e.y, t, LP) } function Nv(e, t) { return Mv(TP(e.getBoundingClientRect(), t)) } function DP(e, t, n) { const r = Nv(e, n), { scroll: i } = t; return i && (cn(r.x, i.offset.x), cn(r.y, i.offset.y)), r } const Vv = ({ current: e }) => e ? e.ownerDocument.defaultView : null, MP = new WeakMap; class AP { constructor(t) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ge(), this.visualElement = t } start(t, { snapToCursor: n = !1 } = {}) { const { presenceContext: r } = this.visualElement; if (r && r.isPresent === !1) return; const i = c => { const { dragSnapToOrigin: f } = this.getProps(); f ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(ma(c, "page").point) }, o = (c, f) => { const { drag: d, dragPropagation: g, onDragStart: v } = this.getProps(); if (d && !g && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Kg(d), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), ut(S => { let p = this.getAxisMotionValue(S).get() || 0; if (_t.test(p)) { const { projection: h } = this.visualElement; if (h && h.layout) { const m = h.layout.layoutBox[S]; m && (p = ot(m) * (parseFloat(p) / 100)) } } this.originPoint[S] = p }), v && v(c, f); const { animationState: y } = this.visualElement; y && y.setActive("whileDrag", !0) }, s = (c, f) => { const { dragPropagation: d, dragDirectionLock: g, onDirectionLock: v, onDrag: y } = this.getProps(); if (!d && !this.openGlobalLock) return; const { offset: S } = f; if (g && this.currentDirection === null) { this.currentDirection = jP(S), this.currentDirection !== null && v && v(this.currentDirection); return } this.updateAxis("x", f.point, S), this.updateAxis("y", f.point, S), this.visualElement.render(), y && y(c, f) }, a = (c, f) => this.stop(c, f), l = () => ut(c => { var f; return this.getAnimationState(c) === "paused" && ((f = this.getAxisMotionValue(c).animation) === null || f === void 0 ? void 0 : f.play()) }), { dragSnapToOrigin: u } = this.getProps(); this.panSession = new Lv(t, { onSessionStart: i, onStart: o, onMove: s, onSessionEnd: a, resumeAnimation: l }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: u, contextWindow: Vv(this.visualElement) }) } stop(t, n) { const r = this.isDragging; if (this.cancel(), !r) return; const { velocity: i } = n; this.startAnimation(i); const { onDragEnd: o } = this.getProps(); o && o(t, n) } cancel() { this.isDragging = !1; const { projection: t, animationState: n } = this.visualElement; t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: r } = this.getProps(); !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1) } updateAxis(t, n, r) { const { drag: i } = this.getProps(); if (!r || !Ko(t, i, this.currentDirection)) return; const o = this.getAxisMotionValue(t); let s = this.originPoint[t] + r[t]; this.constraints && this.constraints[t] && (s = yP(s, this.constraints[t], this.elastic[t])), o.set(s) } resolveConstraints() { var t; const { dragConstraints: n, dragElastic: r } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, o = this.constraints; n && Lr(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && i ? this.constraints = wP(i.layoutBox, n) : this.constraints = !1, this.elastic = PP(r), o !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && ut(s => { this.getAxisMotionValue(s) && (this.constraints[s] = CP(i.layoutBox[s], this.constraints[s])) }) } resolveRefConstraints() { const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps(); if (!t || !Lr(t)) return !1; const r = t.current, { projection: i } = this.visualElement; if (!i || !i.layout) return !1; const o = DP(r, i.root, this.visualElement.getTransformPagePoint()); let s = xP(i.layout.layoutBox, o); if (n) { const a = n(EP(s)); this.hasMutatedConstraints = !!a, a && (s = Mv(a)) } return s } startAnimation(t) { const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: o, dragSnapToOrigin: s, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, u = ut(c => { if (!Ko(c, n, this.currentDirection)) return; let f = l && l[c] || {}; s && (f = { min: 0, max: 0 }); const d = i ? 200 : 1e6, g = i ? 40 : 1e7, v = { type: "inertia", velocity: r ? t[c] : 0, bounceStiffness: d, bounceDamping: g, timeConstant: 750, restDelta: 1, restSpeed: 10, ...o, ...f }; return this.startAxisValueAnimation(c, v) }); return Promise.all(u).then(a) } startAxisValueAnimation(t, n) { const r = this.getAxisMotionValue(t); return r.start(qc(t, r, 0, n, this.visualElement)) } stopAnimation() { ut(t => this.getAxisMotionValue(t).stop()) } pauseAnimation() { ut(t => { var n; return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause() }) } getAnimationState(t) { var n; return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state } getAxisMotionValue(t) { const n = "_drag" + t.toUpperCase(), r = this.visualElement.getProps(), i = r[n]; return i || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0) } snapToCursor(t) { ut(n => { const { drag: r } = this.getProps(); if (!Ko(n, r, this.currentDirection)) return; const { projection: i } = this.visualElement, o = this.getAxisMotionValue(n); if (i && i.layout) { const { min: s, max: a } = i.layout.layoutBox[n]; o.set(t[n] - le(s, a, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement; if (!Lr(n) || !r || !this.constraints) return; this.stopAnimation(); const i = { x: 0, y: 0 }; ut(s => { const a = this.getAxisMotionValue(s); if (a) { const l = a.get(); i[s] = SP({ min: l, max: l }, this.constraints[s]) } }); const { transformTemplate: o } = this.visualElement.getProps(); this.visualElement.current.style.transform = o ? o({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), ut(s => { if (!Ko(s, t, null)) return; const a = this.getAxisMotionValue(s), { min: l, max: u } = this.constraints[s]; a.set(le(l, u, i[s])) }) } addListeners() { if (!this.visualElement.current) return; MP.set(this.visualElement, this); const t = this.visualElement.current, n = Kt(t, "pointerdown", l => { const { drag: u, dragListener: c = !0 } = this.getProps(); u && c && this.start(l) }), r = () => { const { dragConstraints: l } = this.getProps(); Lr(l) && (this.constraints = this.resolveRefConstraints()) }, { projection: i } = this.visualElement, o = i.addEventListener("measure", r); i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), r(); const s = Wt(window, "resize", () => this.scalePositionWithinConstraints()), a = i.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: u }) => { this.isDragging && u && (ut(c => { const f = this.getAxisMotionValue(c); f && (this.originPoint[c] += l[c].translate, f.set(f.get() + l[c].translate)) }), this.visualElement.render()) }); return () => { s(), n(), o(), a && a() } } getProps() { const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: s = Pu, dragMomentum: a = !0 } = t; return { ...t, drag: n, dragDirectionLock: r, dragPropagation: i, dragConstraints: o, dragElastic: s, dragMomentum: a } } } function Ko(e, t, n) { return (t === !0 || t === e) && (n === null || n === e) } function jP(e, t = 10) { let n = null; return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n } class NP extends On { constructor(t) { super(t), this.removeGroupControls = ze, this.removeListeners = ze, this.controls = new AP(t) } mount() { const { dragControls: t } = this.node.getProps(); t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || ze } unmount() { this.removeGroupControls(), this.removeListeners() } } const Th = e => (t, n) => { e && e(t, n) }; class VP extends On { constructor() { super(...arguments), this.removePointerDownListener = ze } onPointerDown(t) { this.session = new Lv(t, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: Vv(this.node) }) } createPanHandlers() { const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps(); return { onSessionStart: Th(t), onStart: Th(n), onMove: r, onEnd: (o, s) => { delete this.session, i && i(o, s) } } } mount() { this.removePointerDownListener = Kt(this.node.current, "pointerdown", t => this.onPointerDown(t)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } function FP() { const e = x.useContext(da); if (e === null) return [!0, null]; const { isPresent: t, onExitComplete: n, register: r } = e, i = x.useId(); return x.useEffect(() => r(i), []), !t && n ? [!1, () => n && n(i)] : [!0] } const as = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function kh(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } const mi = { correct: (e, t) => { if (!t.target) return e; if (typeof e == "string") if (I.test(e)) e = parseFloat(e); else return e; const n = kh(e, t.target.x), r = kh(e, t.target.y); return `${n}% ${r}%` } }, _P = { correct: (e, { treeScale: t, projectionDelta: n }) => { const r = e, i = An.parse(e); if (i.length > 5) return r; const o = An.createTransformer(e), s = typeof i[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y; i[0 + s] /= a, i[1 + s] /= l; const u = le(a, l, .5); return typeof i[2 + s] == "number" && (i[2 + s] /= u), typeof i[3 + s] == "number" && (i[3 + s] /= u), o(i) } }; class OP extends Pt.Component { componentDidMount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: o } = t; Ox(IP), o && (n.group && n.group.add(o), r && r.register && i && r.register(o), o.root.didUpdate(), o.addEventListener("animationComplete", () => { this.safeToRemove() }), o.setOptions({ ...o.options, onExitComplete: () => this.safeToRemove() })), as.hasEverUpdated = !0 } getSnapshotBeforeUpdate(t) { const { layoutDependency: n, visualElement: r, drag: i, isPresent: o } = this.props, s = r.projection; return s && (s.isPresent = o, i || t.layoutDependency !== n || n === void 0 ? s.willUpdate() : this.safeToRemove(), t.isPresent !== o && (o ? s.promote() : s.relegate() || Re.postRender(() => { const a = s.getStack(); (!a || !a.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: t } = this.props.visualElement; t && (t.root.didUpdate(), jc.postRender(() => { !t.currentAnimation && t.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = t; i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i)) } safeToRemove() { const { safeToRemove: t } = this.props; t && t() } render() { return null } } function Fv(e) { const [t, n] = FP(), r = x.useContext(Fc); return Pt.createElement(OP, { ...e, layoutGroup: r, switchLayoutGroup: x.useContext(Mg), isPresent: t, safeToRemove: n }) } const IP = { borderRadius: { ...mi, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: mi, borderTopRightRadius: mi, borderBottomLeftRadius: mi, borderBottomRightRadius: mi, boxShadow: _P }, _v = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], zP = _v.length, Rh = e => typeof e == "string" ? parseFloat(e) : e, Lh = e => typeof e == "number" || I.test(e); function UP(e, t, n, r, i, o) { i ? (e.opacity = le(0, n.opacity !== void 0 ? n.opacity : 1, BP(r)), e.opacityExit = le(t.opacity !== void 0 ? t.opacity : 1, 0, bP(r))) : o && (e.opacity = le(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r)); for (let s = 0; s < zP; s++) { const a = `border${_v[s]}Radius`; let l = Dh(t, a), u = Dh(n, a); if (l === void 0 && u === void 0) continue; l || (l = 0), u || (u = 0), l === 0 || u === 0 || Lh(l) === Lh(u) ? (e[a] = Math.max(le(Rh(l), Rh(u), r), 0), (_t.test(u) || _t.test(l)) && (e[a] += "%")) : e[a] = u } (t.rotate || n.rotate) && (e.rotate = le(t.rotate || 0, n.rotate || 0, r)) } function Dh(e, t) { return e[t] !== void 0 ? e[t] : e.borderRadius } const BP = Ov(0, .5, wv), bP = Ov(.5, .95, ze); function Ov(e, t, n) { return r => r < e ? 0 : r > t ? 1 : n(so(e, t, r)) } function Mh(e, t) { e.min = t.min, e.max = t.max } function lt(e, t) { Mh(e.x, t.x), Mh(e.y, t.y) } function Ah(e, t, n, r, i) { return e -= t, e = zs(e, 1 / n, r), i !== void 0 && (e = zs(e, 1 / i, r)), e } function HP(e, t = 0, n = 1, r = .5, i, o = e, s = e) { if (_t.test(t) && (t = parseFloat(t), t = le(s.min, s.max, t / 100) - s.min), typeof t != "number") return; let a = le(o.min, o.max, r); e === o && (a -= t), e.min = Ah(e.min, t, n, a, i), e.max = Ah(e.max, t, n, a, i) } function jh(e, t, [n, r, i], o, s) { HP(e, t[n], t[r], t[i], t.scale, o, s) } const WP = ["x", "scaleX", "originX"], $P = ["y", "scaleY", "originY"]; function Nh(e, t, n, r) { jh(e.x, t, WP, n ? n.x : void 0, r ? r.x : void 0), jh(e.y, t, $P, n ? n.y : void 0, r ? r.y : void 0) } function Vh(e) { return e.translate === 0 && e.scale === 1 } function Iv(e) { return Vh(e.x) && Vh(e.y) } function KP(e, t) { return e.x.min === t.x.min && e.x.max === t.x.max && e.y.min === t.y.min && e.y.max === t.y.max } function zv(e, t) { return Math.round(e.x.min) === Math.round(t.x.min) && Math.round(e.x.max) === Math.round(t.x.max) && Math.round(e.y.min) === Math.round(t.y.min) && Math.round(e.y.max) === Math.round(t.y.max) } function Fh(e) { return ot(e.x) / ot(e.y) } class GP { constructor() { this.members = [] } add(t) { ef(this.members, t), t.scheduleRender() } remove(t) { if (tf(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) { const n = this.members[this.members.length - 1]; n && this.promote(n) } } relegate(t) { const n = this.members.findIndex(i => t === i); if (n === 0) return !1; let r; for (let i = n; i >= 0; i--) { const o = this.members[i]; if (o.isPresent !== !1) { r = o; break } } return r ? (this.promote(r), !0) : !1 } promote(t, n) { const r = this.lead; if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) { r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0); const { crossfade: i } = t.options; i === !1 && r.hide() } } exitAnimationComplete() { this.members.forEach(t => { const { options: n, resumingFrom: r } = t; n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete() }) } scheduleRender() { this.members.forEach(t => { t.instance && t.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function _h(e, t, n) { let r = ""; const i = e.x.translate / t.x, o = e.y.translate / t.y, s = (n == null ? void 0 : n.z) || 0; if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) { const { transformPerspective: u, rotate: c, rotateX: f, rotateY: d, skewX: g, skewY: v } = n; u && (r = `perspective(${u}px) ${r}`), c && (r += `rotate(${c}deg) `), f && (r += `rotateX(${f}deg) `), d && (r += `rotateY(${d}deg) `), g && (r += `skewX(${g}deg) `), v && (r += `skewY(${v}deg) `) } const a = e.x.scale * t.x, l = e.y.scale * t.y; return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none" } const QP = (e, t) => e.depth - t.depth; class YP { constructor() { this.children = [], this.isDirty = !1 } add(t) { ef(this.children, t), this.isDirty = !0 } remove(t) { tf(this.children, t), this.isDirty = !0 } forEach(t) { this.isDirty && this.children.sort(QP), this.isDirty = !1, this.children.forEach(t) } } function XP(e, t) { const n = En.now(), r = ({ timestamp: i }) => { const o = i - n; o >= t && (Mn(r), e(o - t)) }; return Re.read(r, !0), () => Mn(r) } function ZP(e) { window.MotionDebug && window.MotionDebug.record(e) } function JP(e) { return e instanceof SVGElement && e.tagName !== "svg" } function qP(e, t, n) { const r = Ie(e) ? e : ao(e); return r.start(qc("", r, t, n)), r.animation } const cl = ["", "X", "Y", "Z"], eE = { visibility: "hidden" }, Oh = 1e3; let tE = 0; const Wn = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }; function fl(e, t, n, r) { const { latestValues: i } = t; i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function Uv({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) { return class { constructor(s = {}, a = t == null ? void 0 : t()) { this.id = tE++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, Wn.totalNodes = Wn.resolvedTargetDeltas = Wn.recalculatedProjection = 0, this.nodes.forEach(iE), this.nodes.forEach(uE), this.nodes.forEach(cE), this.nodes.forEach(oE), ZP(Wn) }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0; for (let l = 0; l < this.path.length; l++)this.path[l].shouldResetTransform = !0; this.root === this && (this.nodes = new YP) } addEventListener(s, a) { return this.eventHandlers.has(s) || this.eventHandlers.set(s, new nf), this.eventHandlers.get(s).add(a) } notifyListeners(s, ...a) { const l = this.eventHandlers.get(s); l && l.notify(...a) } hasListeners(s) { return this.eventHandlers.has(s) } mount(s, a = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = JP(s), this.instance = s; const { layoutId: l, layout: u, visualElement: c } = this.options; if (c && !c.current && c.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (u || l) && (this.isLayoutDirty = !0), e) { let f; const d = () => this.root.updateBlockedByResize = !1; e(s, () => { this.root.updateBlockedByResize = !0, f && f(), f = XP(d, 250), as.hasAnimatedSinceResize && (as.hasAnimatedSinceResize = !1, this.nodes.forEach(zh)) }) } l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && c && (l || u) && this.addEventListener("didUpdate", ({ delta: f, hasLayoutChanged: d, hasRelativeTargetChanged: g, layout: v }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const y = this.options.transition || c.getDefaultTransition() || mE, { onLayoutAnimationStart: S, onLayoutAnimationComplete: p } = c.getProps(), h = !this.targetLayout || !zv(this.targetLayout, v) || g, m = !d && g; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || m || d && (h || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(f, m); const P = { ...$c(y, "layout"), onPlay: S, onComplete: p }; (c.shouldReduceMotion || this.options.layoutRoot) && (P.delay = 0, P.type = !1), this.startAnimation(P) } else d || zh(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = v }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const s = this.getStack(); s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Mn(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(fE), this.animationId++) } getTransformTemplate() { const { visualElement: s } = this.options; return s && s.getProps().transformTemplate } willUpdate(s = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let c = 0; c < this.path.length; c++) { const f = this.path[c]; f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1) } const { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; const u = this.getTransformTemplate(); this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Ih); return } this.isUpdating || this.nodes.forEach(aE), this.isUpdating = !1, window.HandoffCancelAllAnimations && window.HandoffCancelAllAnimations(), this.nodes.forEach(lE), this.nodes.forEach(nE), this.nodes.forEach(rE), this.clearAllSnapshots(); const a = En.now(); Ae.delta = Dn(0, 1e3 / 60, a - Ae.timestamp), Ae.timestamp = a, Ae.isProcessing = !0, el.update.process(Ae), el.preRender.process(Ae), el.render.process(Ae), Ae.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, jc.read(() => this.update())) } clearAllSnapshots() { this.nodes.forEach(sE), this.sharedNodes.forEach(dE) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Re.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Re.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); const s = this.layout; this.layout = this.measure(!1), this.layoutCorrected = ge(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0) } updateScroll(s = "measure") { let a = !!(this.options.layoutScroll && this.instance); this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a && (this.scroll = { animationId: this.root.animationId, phase: s, isRoot: r(this.instance), offset: n(this.instance) }) } resetTransform() { if (!i) return; const s = this.isLayoutDirty || this.shouldResetTransform, a = this.projectionDelta && !Iv(this.projectionDelta), l = this.getTransformTemplate(), u = l ? l(this.latestValues, "") : void 0, c = u !== this.prevTransformTemplateValue; s && (a || Hn(this.latestValues) || c) && (i(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender()) } measure(s = !0) { const a = this.measurePageBox(); let l = this.removeElementScroll(a); return s && (l = this.removeTransform(l)), gE(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: s } = this.options; if (!s) return ge(); const a = s.measureViewportBox(), { scroll: l } = this.root; return l && (cn(a.x, l.offset.x), cn(a.y, l.offset.y)), a } removeElementScroll(s) { const a = ge(); lt(a, s); for (let l = 0; l < this.path.length; l++) { const u = this.path[l], { scroll: c, options: f } = u; if (u !== this.root && c && f.layoutScroll) { if (c.isRoot) { lt(a, s); const { scroll: d } = this.root; d && (cn(a.x, -d.offset.x), cn(a.y, -d.offset.y)) } cn(a.x, c.offset.x), cn(a.y, c.offset.y) } } return a } applyTransform(s, a = !1) { const l = ge(); lt(l, s); for (let u = 0; u < this.path.length; u++) { const c = this.path[u]; !a && c.options.layoutScroll && c.scroll && c !== c.root && Ar(l, { x: -c.scroll.offset.x, y: -c.scroll.offset.y }), Hn(c.latestValues) && Ar(l, c.latestValues) } return Hn(this.latestValues) && Ar(l, this.latestValues), l } removeTransform(s) { const a = ge(); lt(a, s); for (let l = 0; l < this.path.length; l++) { const u = this.path[l]; if (!u.instance || !Hn(u.latestValues)) continue; Eu(u.latestValues) && u.updateSnapshot(); const c = ge(), f = u.measurePageBox(); lt(c, f), Nh(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, c) } return Hn(this.latestValues) && Nh(a, this.latestValues), a } setTargetDelta(s) { this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(s) { this.options = { ...this.options, ...s, crossfade: s.crossfade !== void 0 ? s.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ae.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(s = !1) { var a; const l = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty); const u = !!this.resumingFrom || this !== l; if (!(s || u && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget)) return; const { layout: f, layoutId: d } = this.options; if (!(!this.layout || !(f || d))) { if (this.resolvedRelativeTargetAt = Ae.timestamp, !this.targetDelta && !this.relativeTarget) { const g = this.getClosestProjectingParent(); g && g.layout && this.animationProgress !== 1 ? (this.relativeParent = g, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ge(), this.relativeTargetOrigin = ge(), _i(this.relativeTargetOrigin, this.layout.layoutBox, g.layout.layoutBox), lt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = ge(), this.targetWithTransforms = ge()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), vP(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : lt(this.target, this.layout.layoutBox), jv(this.target, this.targetDelta)) : lt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const g = this.getClosestProjectingParent(); g && !!g.resumingFrom == !!this.resumingFrom && !g.options.layoutScroll && g.target && this.animationProgress !== 1 ? (this.relativeParent = g, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ge(), this.relativeTargetOrigin = ge(), _i(this.relativeTargetOrigin, this.target, g.target), lt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } Wn.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || Eu(this.parent.latestValues) || Av(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var s; const a = this.getLead(), l = !!this.resumingFrom || this !== a; let u = !0; if ((this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty) && (u = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (u = !1), this.resolvedRelativeTargetAt === Ae.timestamp && (u = !1), u) return; const { layout: c, layoutId: f } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(c || f)) return; lt(this.layoutCorrected, this.layout.layoutBox); const d = this.treeScale.x, g = this.treeScale.y; kP(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = ge()); const { target: v } = a; if (!v) { this.projectionTransform && (this.projectionDelta = Mr(), this.projectionTransform = "none", this.scheduleRender()); return } this.projectionDelta || (this.projectionDelta = Mr(), this.projectionDeltaWithTransform = Mr()); const y = this.projectionTransform; Fi(this.projectionDelta, this.layoutCorrected, v, this.latestValues), this.projectionTransform = _h(this.projectionDelta, this.treeScale), (this.projectionTransform !== y || this.treeScale.x !== d || this.treeScale.y !== g) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", v)), Wn.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(s = !0) { if (this.options.scheduleRender && this.options.scheduleRender(), s) { const a = this.getStack(); a && a.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } setAnimationOrigin(s, a = !1) { const l = this.snapshot, u = l ? l.latestValues : {}, c = { ...this.latestValues }, f = Mr(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; const d = ge(), g = l ? l.source : void 0, v = this.layout ? this.layout.source : void 0, y = g !== v, S = this.getStack(), p = !S || S.members.length <= 1, h = !!(y && !p && this.options.crossfade === !0 && !this.path.some(pE)); this.animationProgress = 0; let m; this.mixTargetDelta = P => { const R = P / 1e3; Uh(f.x, s.x, R), Uh(f.y, s.y, R), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (_i(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox), hE(this.relativeTarget, this.relativeTargetOrigin, d, R), m && KP(this.relativeTarget, m) && (this.isProjectionDirty = !1), m || (m = ge()), lt(m, this.relativeTarget)), y && (this.animationValues = c, UP(c, u, this.latestValues, R, h, p)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = R }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(s) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Mn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Re.update(() => { as.hasAnimatedSinceResize = !0, this.currentAnimation = qP(0, Oh, { ...s, onUpdate: a => { this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a) }, onComplete: () => { s.onComplete && s.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const s = this.getStack(); s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Oh), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const s = this.getLead(); let { targetWithTransforms: a, target: l, layout: u, latestValues: c } = s; if (!(!a || !l || !u)) { if (this !== s && this.layout && u && Bv(this.options.animationType, this.layout.layoutBox, u.layoutBox)) { l = this.target || ge(); const f = ot(this.layout.layoutBox.x); l.x.min = s.target.x.min, l.x.max = l.x.min + f; const d = ot(this.layout.layoutBox.y); l.y.min = s.target.y.min, l.y.max = l.y.min + d } lt(a, l), Ar(a, c), Fi(this.projectionDeltaWithTransform, this.layoutCorrected, a, c) } } registerSharedNode(s, a) { this.sharedNodes.has(s) || this.sharedNodes.set(s, new GP), this.sharedNodes.get(s).add(a); const u = a.options.initialPromotionConfig; a.promote({ transition: u ? u.transition : void 0, preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { const s = this.getStack(); return s ? s.lead === this : !0 } getLead() { var s; const { layoutId: a } = this.options; return a ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this } getPrevLead() { var s; const { layoutId: a } = this.options; return a ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0 } getStack() { const { layoutId: s } = this.options; if (s) return this.root.sharedNodes.get(s) } promote({ needsReset: s, transition: a, preserveFollowOpacity: l } = {}) { const u = this.getStack(); u && u.promote(this, l), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { const s = this.getStack(); return s ? s.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: s } = this.options; if (!s) return; let a = !1; const { latestValues: l } = s; if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return; const u = {}; l.z && fl("z", s, u, this.animationValues); for (let c = 0; c < cl.length; c++)fl(`rotate${cl[c]}`, s, u, this.animationValues), fl(`skew${cl[c]}`, s, u, this.animationValues); s.render(); for (const c in u) s.setStaticValue(c, u[c]), this.animationValues && (this.animationValues[c] = u[c]); s.scheduleRender() } getProjectionStyles(s) { var a, l; if (!this.instance || this.isSVG) return; if (!this.isVisible) return eE; const u = { visibility: "" }, c = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, u.opacity = "", u.pointerEvents = os(s == null ? void 0 : s.pointerEvents) || "", u.transform = c ? c(this.latestValues, "") : "none", u; const f = this.getLead(); if (!this.projectionDelta || !this.layout || !f.target) { const y = {}; return this.options.layoutId && (y.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, y.pointerEvents = os(s == null ? void 0 : s.pointerEvents) || ""), this.hasProjected && !Hn(this.latestValues) && (y.transform = c ? c({}, "") : "none", this.hasProjected = !1), y } const d = f.animationValues || f.latestValues; this.applyTransformsToTarget(), u.transform = _h(this.projectionDeltaWithTransform, this.treeScale, d), c && (u.transform = c(d, u.transform)); const { x: g, y: v } = this.projectionDelta; u.transformOrigin = `${g.origin * 100}% ${v.origin * 100}% 0`, f.animationValues ? u.opacity = f === this ? (l = (a = d.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : u.opacity = f === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0; for (const y in Ns) { if (d[y] === void 0) continue; const { correct: S, applyTo: p } = Ns[y], h = u.transform === "none" ? d[y] : S(d[y], f); if (p) { const m = p.length; for (let P = 0; P < m; P++)u[p[P]] = h } else u[y] = h } return this.options.layoutId && (u.pointerEvents = f === this ? os(s == null ? void 0 : s.pointerEvents) || "" : "none"), u } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(s => { var a; return (a = s.currentAnimation) === null || a === void 0 ? void 0 : a.stop() }), this.root.nodes.forEach(Ih), this.root.sharedNodes.clear() } } } function nE(e) { e.updateLayout() } function rE(e) { var t; const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot; if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) { const { layoutBox: r, measuredBox: i } = e.layout, { animationType: o } = e.options, s = n.source !== e.layout.source; o === "size" ? ut(f => { const d = s ? n.measuredBox[f] : n.layoutBox[f], g = ot(d); d.min = r[f].min, d.max = d.min + g }) : Bv(o, n.layoutBox, r) && ut(f => { const d = s ? n.measuredBox[f] : n.layoutBox[f], g = ot(r[f]); d.max = d.min + g, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[f].max = e.relativeTarget[f].min + g) }); const a = Mr(); Fi(a, r, n.layoutBox); const l = Mr(); s ? Fi(l, e.applyTransform(i, !0), n.measuredBox) : Fi(l, r, n.layoutBox); const u = !Iv(a); let c = !1; if (!e.resumeFrom) { const f = e.getClosestProjectingParent(); if (f && !f.resumeFrom) { const { snapshot: d, layout: g } = f; if (d && g) { const v = ge(); _i(v, n.layoutBox, d.layoutBox); const y = ge(); _i(y, r, g.layoutBox), zv(v, y) || (c = !0), f.options.layoutRoot && (e.relativeTarget = y, e.relativeTargetOrigin = v, e.relativeParent = f) } } } e.notifyListeners("didUpdate", { layout: r, snapshot: n, delta: l, layoutDelta: a, hasLayoutChanged: u, hasRelativeTargetChanged: c }) } else if (e.isLead()) { const { onExitComplete: r } = e.options; r && r() } e.options.transition = void 0 } function iE(e) { Wn.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function oE(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function sE(e) { e.clearSnapshot() } function Ih(e) { e.clearMeasurements() } function aE(e) { e.isLayoutDirty = !1 } function lE(e) { const { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function zh(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function uE(e) { e.resolveTargetDelta() } function cE(e) { e.calcProjection() } function fE(e) { e.resetSkewAndRotation() } function dE(e) { e.removeLeadSnapshot() } function Uh(e, t, n) { e.translate = le(t.translate, 0, n), e.scale = le(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint } function Bh(e, t, n, r) { e.min = le(t.min, n.min, r), e.max = le(t.max, n.max, r) } function hE(e, t, n, r) { Bh(e.x, t.x, n.x, r), Bh(e.y, t.y, n.y, r) } function pE(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } const mE = { duration: .45, ease: [.4, 0, .1, 1] }, bh = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), Hh = bh("applewebkit/") && !bh("chrome/") ? Math.round : ze; function Wh(e) { e.min = Hh(e.min), e.max = Hh(e.max) } function gE(e) { Wh(e.x), Wh(e.y) } function Bv(e, t, n) { return e === "position" || e === "preserve-aspect" && !Cu(Fh(t), Fh(n), .2) } const vE = Uv({ attachResizeListener: (e, t) => Wt(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), dl = { current: void 0 }, bv = Uv({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!dl.current) { const e = new vE({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), dl.current = e } return dl.current }, resetTransform: (e, t) => { e.style.transform = t !== void 0 ? t : "none" }, checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed" }), yE = { pan: { Feature: VP }, drag: { Feature: NP, ProjectionNode: bv, MeasureLayout: Fv } }, ku = { current: null }, Hv = { current: !1 }; function wE() { if (Hv.current = !0, !!Dc) if (window.matchMedia) { const e = window.matchMedia("(prefers-reduced-motion)"), t = () => ku.current = e.matches; e.addListener(t), t() } else ku.current = !1 } function xE(e, t, n) { const { willChange: r } = t; for (const i in t) { const o = t[i], s = n[i]; if (Ie(o)) e.addValue(i, o), Is(r) && r.add(i); else if (Ie(s)) e.addValue(i, ao(o, { owner: e })), Is(r) && r.remove(i); else if (s !== o) if (e.hasValue(i)) { const a = e.getValue(i); a.liveStyle === !0 ? a.jump(o) : a.hasAnimated || a.set(o) } else { const a = e.getStaticValue(i); e.addValue(i, ao(a !== void 0 ? a : o, { owner: e })) } } for (const i in n) t[i] === void 0 && e.removeValue(i); return t } const $h = new WeakMap, SE = [...tv, _e, An], CE = e => SE.find(ev(e)), Wv = Object.keys(oo), PE = Wv.length, Kh = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], EE = Vc.length; function $v(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : $v(e.parent) } class TE { constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: o, visualState: s }, a = {}) { this.resolveKeyframes = (d, g, v, y) => new this.KeyframeResolver(d, g, v, y, this), this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = Kc, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.scheduleRender = () => Re.render(this.render, !1, !0); const { latestValues: l, renderState: u } = s; this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = u, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!o, this.isControllingVariants = pa(n), this.isVariantNode = Dg(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current); const { willChange: c, ...f } = this.scrapeMotionValuesFromProps(n, {}, this); for (const d in f) { const g = f[d]; l[d] !== void 0 && Ie(g) && (g.set(l[d], !1), Is(c) && c.add(d)) } } scrapeMotionValuesFromProps(t, n, r) { return {} } mount(t) { this.current = t, $h.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), Hv.current || wE(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : ku.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { $h.delete(this.current), this.projection && this.projection.unmount(), Mn(this.notifyUpdate), Mn(this.render), this.valueSubscriptions.forEach(t => t()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const t in this.events) this.events[t].clear(); for (const t in this.features) this.features[t].unmount(); this.current = null } bindToMotionValue(t, n) { const r = ur.has(t), i = n.on("change", s => { this.latestValues[t] = s, this.props.onUpdate && Re.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0) }), o = n.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(t, () => { i(), o(), n.owner && n.stop() }) } sortNodePosition(t) { return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current) } loadFeatures({ children: t, ...n }, r, i, o) { let s, a; for (let l = 0; l < PE; l++) { const u = Wv[l], { isEnabled: c, Feature: f, ProjectionNode: d, MeasureLayout: g } = oo[u]; d && (s = d), c(n) && (!this.features[u] && f && (this.features[u] = new f(this)), g && (a = g)) } if ((this.type === "html" || this.type === "svg") && !this.projection && s) { this.projection = new s(this.latestValues, $v(this.parent)); const { layoutId: l, layout: u, drag: c, dragConstraints: f, layoutScroll: d, layoutRoot: g } = n; this.projection.setOptions({ layoutId: l, layout: u, alwaysMeasureLayout: !!c || f && Lr(f), visualElement: this, scheduleRender: () => this.scheduleRender(), animationType: typeof u == "string" ? u : "both", initialPromotionConfig: o, layoutScroll: d, layoutRoot: g }) } return a } updateFeatures() { for (const t in this.features) { const n = this.features[t]; n.isMounted ? n.update() : (n.mount(), n.isMounted = !0) } } triggerBuild() { this.build(this.renderState, this.latestValues, this.options, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ge() } getStaticValue(t) { return this.latestValues[t] } setStaticValue(t, n) { this.latestValues[t] = n } update(t, n) { (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n; for (let r = 0; r < Kh.length; r++) { const i = Kh[r]; this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]); const o = t["on" + i]; o && (this.propEventSubscriptions[i] = this.on(i, o)) } this.prevMotionValues = xE(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(t) { return this.props.variants ? this.props.variants[t] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext(t = !1) { if (t) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { const r = this.parent ? this.parent.getVariantContext() || {} : {}; return this.props.initial !== void 0 && (r.initial = this.props.initial), r } const n = {}; for (let r = 0; r < EE; r++) { const i = Vc[r], o = this.props[i]; (io(o) || o === !1) && (n[i] = o) } return n } addVariantChild(t) { const n = this.getClosestVariantNode(); if (n) return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t) } addValue(t, n) { n !== this.values.get(t) && (this.removeValue(t), this.bindToMotionValue(t, n)), this.values.set(t, n), this.latestValues[t] = n.get() } removeValue(t) { this.values.delete(t); const n = this.valueSubscriptions.get(t); n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState) } hasValue(t) { return this.values.has(t) } getValue(t, n) { if (this.props.values && this.props.values[t]) return this.props.values[t]; let r = this.values.get(t); return r === void 0 && n !== void 0 && (r = ao(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r } readValue(t, n) { var r; let i = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (r = this.getBaseTargetFromProps(this.props, t)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, t, this.options); return i != null && (typeof i == "string" && (Jg(i) || Xg(i)) ? i = parseFloat(i) : !CE(i) && An.test(n) && (i = uv(t, n)), this.setBaseTarget(t, Ie(i) ? i.get() : i)), Ie(i) ? i.get() : i } setBaseTarget(t, n) { this.baseTarget[t] = n } getBaseTarget(t) { var n, r; const { initial: i } = this.props, o = typeof i == "string" || typeof i == "object" ? (r = Wc(this.props, i, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom)) === null || r === void 0 ? void 0 : r[t] : void 0; if (i && o !== void 0) return o; const s = this.getBaseTargetFromProps(this.props, t); return s !== void 0 && !Ie(s) ? s : this.initialValues[t] !== void 0 && o === void 0 ? void 0 : this.baseTarget[t] } on(t, n) { return this.events[t] || (this.events[t] = new nf), this.events[t].add(n) } notify(t, ...n) { this.events[t] && this.events[t].notify(...n) } } class Kv extends TE { constructor() { super(...arguments), this.KeyframeResolver = cv } sortInstanceNodePosition(t, n) { return t.compareDocumentPosition(n) & 2 ? 1 : -1 } getBaseTargetFromProps(t, n) { return t.style ? t.style[n] : void 0 } removeValueFromRenderState(t, { vars: n, style: r }) { delete n[t], delete r[t] } } function kE(e) { return window.getComputedStyle(e) } class RE extends Kv { constructor() { super(...arguments), this.type = "html" } readValueFromInstance(t, n) { if (ur.has(n)) { const r = Qc(n); return r && r.default || 0 } else { const r = kE(t), i = (Ng(n) ? r.getPropertyValue(n) : r[n]) || 0; return typeof i == "string" ? i.trim() : i } } measureInstanceViewportBox(t, { transformPagePoint: n }) { return Nv(t, n) } build(t, n, r, i) { zc(t, n, r, i.transformTemplate) } scrapeMotionValuesFromProps(t, n, r) { return Hc(t, n, r) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: t } = this.props; Ie(t) && (this.childSubscription = t.on("change", n => { this.current && (this.current.textContent = `${n}`) })) } renderInstance(t, n, r, i) { Ig(t, n, r, i) } } class LE extends Kv { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1 } getBaseTargetFromProps(t, n) { return t[n] } readValueFromInstance(t, n) { if (ur.has(n)) { const r = Qc(n); return r && r.default || 0 } return n = zg.has(n) ? n : Ac(n), t.getAttribute(n) } measureInstanceViewportBox() { return ge() } scrapeMotionValuesFromProps(t, n) { return Bg(t, n, this) } build(t, n, r, i) { Bc(t, n, r, this.isSVGTag, i.transformTemplate) } renderInstance(t, n, r, i) { Ug(t, n, r, i) } mount(t) { this.isSVGTag = bc(t.tagName), super.mount(t) } } const DE = (e, t) => _c(e) ? new LE(t, { enableHardwareAcceleration: !1 }) : new RE(t, { allowProjection: e !== x.Fragment, enableHardwareAcceleration: !0 }), ME = { layout: { ProjectionNode: bv, MeasureLayout: Fv } }, AE = { ...hP, ...TS, ...yE, ...ME }, jn = Fx((e, t) => dS(e, t, AE, DE)); function Gv() { const e = x.useRef(!1); return Mc(() => (e.current = !0, () => { e.current = !1 }), []), e } function jE() { const e = Gv(), [t, n] = x.useState(0), r = x.useCallback(() => { e.current && n(t + 1) }, [t]); return [x.useCallback(() => Re.postRender(r), [r]), t] } class NE extends x.Component { getSnapshotBeforeUpdate(t) { const n = this.props.childRef.current; if (n && t.isPresent && !this.props.isPresent) { const r = this.props.sizeRef.current; r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } } function VE({ children: e, isPresent: t }) {
  const n = x.useId(), r = x.useRef(null), i = x.useRef({ width: 0, height: 0, top: 0, left: 0 }), { nonce: o } = x.useContext(Lc); return x.useInsertionEffect(() => {
    const { width: s, height: a, top: l, left: u } = i.current; if (t || !r.current || !s || !a) return; r.current.dataset.motionPopId = n; const c = document.createElement("style"); return o && (c.nonce = o), document.head.appendChild(c), c.sheet && c.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${u}px !important;
          }
        `), () => { document.head.removeChild(c) }
  }, [t]), x.createElement(NE, { isPresent: t, childRef: r, sizeRef: i }, x.cloneElement(e, { ref: r }))
} const hl = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s }) => { const a = bg(FE), l = x.useId(), u = x.useMemo(() => ({ id: l, initial: t, isPresent: n, custom: i, onExitComplete: c => { a.set(c, !0); for (const f of a.values()) if (!f) return; r && r() }, register: c => (a.set(c, !1), () => a.delete(c)) }), o ? void 0 : [n]); return x.useMemo(() => { a.forEach((c, f) => a.set(f, !1)) }, [n]), x.useEffect(() => { !n && !a.size && r && r() }, [n]), s === "popLayout" && (e = x.createElement(VE, { isPresent: n }, e)), x.createElement(da.Provider, { value: u }, e) }; function FE() { return new Map } function _E(e) { return x.useEffect(() => () => e(), []) } const $n = e => e.key || ""; function OE(e, t) { e.forEach(n => { const r = $n(n); t.set(r, n) }) } function IE(e) { const t = []; return x.Children.forEach(e, n => { x.isValidElement(n) && t.push(n) }), t } const zE = ({ children: e, custom: t, initial: n = !0, onExitComplete: r, exitBeforeEnter: i, presenceAffectsLayout: o = !0, mode: s = "sync" }) => { const a = x.useContext(Fc).forceRender || jE()[0], l = Gv(), u = IE(e); let c = u; const f = x.useRef(new Map).current, d = x.useRef(c), g = x.useRef(new Map).current, v = x.useRef(!0); if (Mc(() => { v.current = !1, OE(u, g), d.current = c }), _E(() => { v.current = !0, g.clear(), f.clear() }), v.current) return x.createElement(x.Fragment, null, c.map(h => x.createElement(hl, { key: $n(h), isPresent: !0, initial: n ? void 0 : !1, presenceAffectsLayout: o, mode: s }, h))); c = [...c]; const y = d.current.map($n), S = u.map($n), p = y.length; for (let h = 0; h < p; h++) { const m = y[h]; S.indexOf(m) === -1 && !f.has(m) && f.set(m, void 0) } return s === "wait" && f.size && (c = []), f.forEach((h, m) => { if (S.indexOf(m) !== -1) return; const P = g.get(m); if (!P) return; const R = y.indexOf(m); let w = h; if (!w) { const D = () => { f.delete(m); const k = Array.from(g.keys()).filter(j => !S.includes(j)); if (k.forEach(j => g.delete(j)), d.current = u.filter(j => { const V = $n(j); return V === m || k.includes(V) }), !f.size) { if (l.current === !1) return; a(), r && r() } }; w = x.createElement(hl, { key: $n(P), isPresent: !1, onExitComplete: D, custom: t, presenceAffectsLayout: o, mode: s }, P), f.set(m, w) } c.splice(R, 0, w) }), c = c.map(h => { const m = h.key; return f.has(m) ? h : x.createElement(hl, { key: $n(h), isPresent: !0, presenceAffectsLayout: o, mode: s }, h) }), x.createElement(x.Fragment, null, f.size ? c : c.map(h => x.cloneElement(h))) }, UE = { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0, transition: { delay: .2 } }, transition: { duration: .3 } }, BE = { initial: { x: "-100%" }, animate: { x: 0 }, exit: { x: "-100%" }, transition: { duration: .3 } }, Gh = e => ({ initial: { opacity: 0, x: -50 }, animate: { opacity: 1, x: 0 }, transition: { delay: .5 + e / 10 } }); var Qv = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, Qh = Pt.createContext && Pt.createContext(Qv), bE = ["attr", "size", "title"]; function HE(e, t) { if (e == null) return {}; var n = WE(e, t), r, i; if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (i = 0; i < o.length; i++)r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]) } return n } function WE(e, t) { if (e == null) return {}; var n = {}, r = Object.keys(e), i, o; for (o = 0; o < r.length; o++)i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]); return n } function Us() { return Us = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Us.apply(this, arguments) } function Yh(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(e, i).enumerable })), n.push.apply(n, r) } return n } function Bs(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? Yh(Object(n), !0).forEach(function (r) { $E(e, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Yh(Object(n)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r)) }) } return e } function $E(e, t, n) { return t = KE(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function KE(e) { var t = GE(e, "string"); return typeof t == "symbol" ? t : String(t) } function GE(e, t) { if (typeof e != "object" || e === null) return e; var n = e[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(e, t || "default"); if (typeof r != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (t === "string" ? String : Number)(e) } function Yv(e) { return e && e.map((t, n) => Pt.createElement(t.tag, Bs({ key: n }, t.attr), Yv(t.child))) } function xo(e) { return t => Pt.createElement(QE, Us({ attr: Bs({}, e.attr) }, t), Yv(e.child)) } function QE(e) { var t = n => { var { attr: r, size: i, title: o } = e, s = HE(e, bE), a = i || n.size || "1em", l; return n.className && (l = n.className), e.className && (l = (l ? l + " " : "") + e.className), Pt.createElement("svg", Us({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, n.attr, r, s, { className: l, style: Bs(Bs({ color: e.color || n.color }, n.style), e.style), height: a, width: a, xmlns: "http://www.w3.org/2000/svg" }), o && Pt.createElement("title", null, o), e.children) }; return Qh !== void 0 ? Pt.createElement(Qh.Consumer, null, n => t(n)) : t(Qv) } function YE(e) { return xo({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M793 242H366v-74c0-6.7-7.7-10.4-12.9-6.3l-142 112a8 8 0 0 0 0 12.6l142 112c5.2 4.1 12.9.4 12.9-6.3v-74h415v470H175c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h618c35.3 0 64-28.7 64-64V306c0-35.3-28.7-64-64-64z" }, child: [] }] })(e) } function XE(e) { return xo({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M12.5 9a3.5 3.5 0 1 1 0 7 3.5 3.5 0 0 1 0-7Zm.354 5.854 1.5-1.5a.5.5 0 0 0-.708-.708l-.646.647V10.5a.5.5 0 0 0-1 0v2.793l-.646-.647a.5.5 0 0 0-.708.708l1.5 1.5a.5.5 0 0 0 .708 0Z" }, child: [] }, { tag: "path", attr: { d: "M12.096 6.223A4.92 4.92 0 0 0 13 5.698V7c0 .289-.213.654-.753 1.007a4.493 4.493 0 0 1 1.753.25V4c0-1.007-.875-1.755-1.904-2.223C11.022 1.289 9.573 1 8 1s-3.022.289-4.096.777C2.875 2.245 2 2.993 2 4v9c0 1.007.875 1.755 1.904 2.223C4.978 15.71 6.427 16 8 16c.536 0 1.058-.034 1.555-.097a4.525 4.525 0 0 1-.813-.927C8.5 14.992 8.252 15 8 15c-1.464 0-2.766-.27-3.682-.687C3.356 13.875 3 13.373 3 13v-1.302c.271.202.58.378.904.525C4.978 12.71 6.427 13 8 13h.027a4.552 4.552 0 0 1 0-1H8c-1.464 0-2.766-.27-3.682-.687C3.356 10.875 3 10.373 3 10V8.698c.271.202.58.378.904.525C4.978 9.71 6.427 10 8 10c.262 0 .52-.008.774-.024a4.525 4.525 0 0 1 1.102-1.132C9.298 8.944 8.666 9 8 9c-1.464 0-2.766-.27-3.682-.687C3.356 7.875 3 7.373 3 7V5.698c.271.202.58.378.904.525C4.978 6.711 6.427 7 8 7s3.022-.289 4.096-.777ZM3 4c0-.374.356-.875 1.318-1.313C5.234 2.271 6.536 2 8 2s2.766.27 3.682.687C12.644 3.125 13 3.627 13 4c0 .374-.356.875-1.318 1.313C10.766 5.729 9.464 6 8 6s-2.766-.27-3.682-.687C3.356 4.875 3 4.373 3 4Z" }, child: [] }] })(e) } function ZE(e) { return xo({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M15 14s1 0 1-1-1-4-5-4-5 3-5 4 1 1 1 1h8Zm-7.978-1A.261.261 0 0 1 7 12.996c.001-.264.167-1.03.76-1.72C8.312 10.629 9.282 10 11 10c1.717 0 2.687.63 3.24 1.276.593.69.758 1.457.76 1.72l-.008.002a.274.274 0 0 1-.014.002H7.022ZM11 7a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm3-2a3 3 0 1 1-6 0 3 3 0 0 1 6 0ZM6.936 9.28a5.88 5.88 0 0 0-1.23-.247A7.35 7.35 0 0 0 5 9c-4 0-5 3-5 4 0 .667.333 1 1 1h4.216A2.238 2.238 0 0 1 5 13c0-1.01.377-2.042 1.09-2.904.243-.294.526-.569.846-.816ZM4.92 10A5.493 5.493 0 0 0 4 13H1c0-.26.164-1.03.76-1.724.545-.636 1.492-1.256 3.16-1.275ZM1.5 5.5a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm3-2a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z" }, child: [] }] })(e) } function JE(e) { return xo({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M19 21.0001H5C4.44772 21.0001 4 20.5524 4 20.0001V11.0001L1 11.0001L11.3273 1.61162C11.7087 1.26488 12.2913 1.26488 12.6727 1.61162L23 11.0001L20 11.0001V20.0001C20 20.5524 19.5523 21.0001 19 21.0001ZM6 19.0001H18V9.15757L12 3.70302L6 9.15757V19.0001ZM12 15.0001C10.6193 15.0001 9.5 13.8808 9.5 12.5001C9.5 11.1194 10.6193 10.0001 12 10.0001C13.3807 10.0001 14.5 11.1194 14.5 12.5001C14.5 13.8808 13.3807 15.0001 12 15.0001Z" }, child: [] }] })(e) } function Xv(e) { return xo({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "none" }, child: [{ tag: "path", attr: { fillRule: "evenodd", clipRule: "evenodd", d: "M16 9C16 11.2091 14.2091 13 12 13C9.79086 13 8 11.2091 8 9C8 6.79086 9.79086 5 12 5C14.2091 5 16 6.79086 16 9ZM14 9C14 10.1046 13.1046 11 12 11C10.8954 11 10 10.1046 10 9C10 7.89543 10.8954 7 12 7C13.1046 7 14 7.89543 14 9Z", fill: "currentColor" }, child: [] }, { tag: "path", attr: { fillRule: "evenodd", clipRule: "evenodd", d: "M12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1ZM3 12C3 14.0902 3.71255 16.014 4.90798 17.5417C6.55245 15.3889 9.14627 14 12.0645 14C14.9448 14 17.5092 15.3531 19.1565 17.4583C20.313 15.9443 21 14.0524 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12ZM12 21C9.84977 21 7.87565 20.2459 6.32767 18.9878C7.59352 17.1812 9.69106 16 12.0645 16C14.4084 16 16.4833 17.1521 17.7538 18.9209C16.1939 20.2191 14.1881 21 12 21Z", fill: "currentColor" }, child: [] }] })(e) } const gi = 2, So = e => { let t = { scale: 1.1 }; return e && e.includes("shake") && (t.x = [-gi, gi, -gi, gi, -gi, 0], t.transition = { duration: .4, ease: "easeInOut", times: [0, .2, .4, .6, .8, 1] }), t }; function qE(e) { return T.jsx(jn.button, { whileHover: So("shake"), onClick: e.action, className: `appIcon absolute right-[theme('sidebarMargin.default')]  ${e.className}`, "aria-label": "close sidebar", children: T.jsx(YE, {}) }) } function eT(e) { return T.jsx(jn.button, { whileHover: So("shake"), onClick: e.action, className: `appIcon  ${e.className}`, "aria-label": "toggle sidebar", children: T.jsx(ZE, {}) }) } function tT(e) { const { action: t, className: n, ...r } = e; return T.jsx(jn.button, { whileHover: So, onClick: t, className: `appIcon  ${n || ""}`, "aria-label": "toggle home", children: T.jsx(JE, {}) }) } function nT(e) { const { action: t, className: n, ...r } = e; return T.jsx(jn.button, { whileHover: So, onClick: t, className: `appIcon  ${n || ""}`, "aria-label": "toggle load data", ...r, children: T.jsx(XE, {}) }) } function rT(e) { const { action: t, className: n, ...r } = e; return T.jsx(jn.button, { whileHover: So, onClick: t, className: `appIcon  ${n || ""}`, "aria-label": "toggle load customer", ...r, children: T.jsx(Xv, {}) }) } var Zv = { exports: {} }, Jv = {};/**
 * @license React
 * use-sync-external-store-with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Co = x; function iT(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var oT = typeof Object.is == "function" ? Object.is : iT, sT = Co.useSyncExternalStore, aT = Co.useRef, lT = Co.useEffect, uT = Co.useMemo, cT = Co.useDebugValue; Jv.useSyncExternalStoreWithSelector = function (e, t, n, r, i) { var o = aT(null); if (o.current === null) { var s = { hasValue: !1, value: null }; o.current = s } else s = o.current; o = uT(function () { function l(g) { if (!u) { if (u = !0, c = g, g = r(g), i !== void 0 && s.hasValue) { var v = s.value; if (i(v, g)) return f = v } return f = g } if (v = f, oT(c, g)) return v; var y = r(g); return i !== void 0 && i(v, y) ? v : (c = g, f = y) } var u = !1, c, f, d = n === void 0 ? null : n; return [function () { return l(t()) }, d === null ? void 0 : function () { return l(d()) }] }, [t, n, r, i]); var a = sT(e, o[0], o[1]); return lT(function () { s.hasValue = !0, s.value = a }, [a]), cT(a), a }; Zv.exports = Jv; var fT = Zv.exports, nt = "default" in ls ? Pt : ls, Xh = Symbol.for("react-redux-context"), Zh = typeof globalThis < "u" ? globalThis : {}; function dT() { if (!nt.createContext) return {}; const e = Zh[Xh] ?? (Zh[Xh] = new Map); let t = e.get(nt.createContext); return t || (t = nt.createContext(null), e.set(nt.createContext, t)), t } var Nn = dT(), hT = () => { throw new Error("uSES not initialized!") }; function rf(e = Nn) { return function () { return nt.useContext(e) } } var qv = rf(), ey = hT, pT = e => { ey = e }, mT = (e, t) => e === t; function gT(e = Nn) { const t = e === Nn ? qv : rf(e), n = (r, i = {}) => { const { equalityFn: o = mT, devModeChecks: s = {} } = typeof i == "function" ? { equalityFn: i } : i, { store: a, subscription: l, getServerState: u, stabilityCheck: c, identityFunctionCheck: f } = t(); nt.useRef(!0); const d = nt.useCallback({ [r.name](v) { return r(v) } }[r.name], [r, c, s.stabilityCheck]), g = ey(l.addNestedSub, a.getState, u || a.getState, d, o); return nt.useDebugValue(g), g }; return Object.assign(n, { withTypes: () => n }), n } var vT = gT(); function yT(e) { e() } function wT() { let e = null, t = null; return { clear() { e = null, t = null }, notify() { yT(() => { let n = e; for (; n;)n.callback(), n = n.next }) }, get() { const n = []; let r = e; for (; r;)n.push(r), r = r.next; return n }, subscribe(n) { let r = !0; const i = t = { callback: n, next: null, prev: t }; return i.prev ? i.prev.next = i : e = i, function () { !r || e === null || (r = !1, i.next ? i.next.prev = i.prev : t = i.prev, i.prev ? i.prev.next = i.next : e = i.next) } } } } var Jh = { notify() { }, get: () => [] }; function xT(e, t) { let n, r = Jh, i = 0, o = !1; function s(y) { c(); const S = r.subscribe(y); let p = !1; return () => { p || (p = !0, S(), f()) } } function a() { r.notify() } function l() { v.onStateChange && v.onStateChange() } function u() { return o } function c() { i++, n || (n = t ? t.addNestedSub(l) : e.subscribe(l), r = wT()) } function f() { i--, n && i === 0 && (n(), n = void 0, r.clear(), r = Jh) } function d() { o || (o = !0, c()) } function g() { o && (o = !1, f()) } const v = { addNestedSub: s, notifyNestedSubs: a, handleChangeWrapper: l, isSubscribed: u, trySubscribe: d, tryUnsubscribe: g, getListeners: () => r }; return v } var ST = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", CT = ST ? nt.useLayoutEffect : nt.useEffect; function PT({ store: e, context: t, children: n, serverState: r, stabilityCheck: i = "once", identityFunctionCheck: o = "once" }) { const s = nt.useMemo(() => { const u = xT(e); return { store: e, subscription: u, getServerState: r ? () => r : void 0, stabilityCheck: i, identityFunctionCheck: o } }, [e, r, i, o]), a = nt.useMemo(() => e.getState(), [e]); CT(() => { const { subscription: u } = s; return u.onStateChange = u.notifyNestedSubs, u.trySubscribe(), a !== e.getState() && u.notifyNestedSubs(), () => { u.tryUnsubscribe(), u.onStateChange = void 0 } }, [s, a]); const l = t || Nn; return nt.createElement(l.Provider, { value: s }, n) } var ET = PT; function ty(e = Nn) { const t = e === Nn ? qv : rf(e), n = () => { const { store: r } = t(); return r }; return Object.assign(n, { withTypes: () => n }), n } var TT = ty(); function kT(e = Nn) { const t = e === Nn ? TT : ty(e), n = () => t().dispatch; return Object.assign(n, { withTypes: () => n }), n } var RT = kT(); pT(fT.useSyncExternalStoreWithSelector); const LT = "contactlist"; function DT({ list: e, framerText: t }) { return T.jsxs("div", { className: `${LT}`, children: [T.jsx("li", { children: T.jsx("h3", { className: "list-header bg-contrast2", children: "Contacts" }) }), e.length ? e.map((n, r) => T.jsx(jn.li, { ...t(r), children: T.jsxs(Pg, { as: "NavLink", to: `contacts/${n.id}`, className: ({ isActive: i, isPending: o }) => i ? "active" : o ? "pending" : "", children: [n.first || n.last ? T.jsxs(T.Fragment, { children: [n.first, " ", n.last] }) : T.jsx("i", { children: "No Name" }), " ", n.favorite && T.jsx("span", { children: "★" })] }) }, n.id)) : T.jsx("li", { children: T.jsx("a", { href: "#", disabled: !0, children: T.jsx("i", { children: "No contacts" }) }) })] }) } const MT = `{
  products(first: 10) {  
    edges {
      node {
        id
        title
        handle
        description
        images(first: 1) {
          edges {
            node {
              originalSrc
            }
          }
        }
        variants(first: 5) {
          edges {
            node {
              priceV2 {
                amount
                currencyCode
              }
            }
          }
        }
      }
    }
  }
}
`; async function AT() { return (await (await fetch("https://vzine.myshopify.com/api/2024-07/graphql.json", { method: "POST", headers: { "Content-Type": "application/json", "X-Shopify-Storefront-Access-Token": "7205448e608af45a59ff19512e93792b" }, body: JSON.stringify({ query: MT }) })).json()).data.products.edges } const jT = "productlist"; async function NT() { try { const e = await AT(); return console.log("===> productsLoader() data", e), { data: e } } catch (e) { throw e } } function ny({ framerText: e }) { const { data: t } = aa(), [n, r] = x.useState([]); return x.useEffect(() => { r(t) }, [t]), T.jsxs("div", { className: `${jT}`, children: [T.jsx("li", { children: T.jsx("h3", { className: "list-header bg-contrast2", children: "Products" }) }), n && n.length ? n.map((i, o) => (i = i.node, T.jsx("li", { children: i.title }, o))) : T.jsx("li", { children: T.jsx("a", { href: "#", disabled: !0, children: T.jsx("i", { children: "No products" }) }) })] }) } const VT = ({ initialActiveTab: e = "contacts", contactsState: t, customersState: n }) => { const [r, i] = x.useState(e); Cc(); const o = s => { i(s), s === "products" && ra(s) }; return T.jsxs(T.Fragment, { children: [T.jsx("div", { children: "TabSwitch" }), T.jsxs("div", { children: [T.jsxs("div", { className: "tab-controls", children: [T.jsx("button", { className: r === "contacts" ? "active" : "", onClick: () => o("contacts"), children: "contacts" }), T.jsx("button", { className: r === "customers" ? "active" : "", onClick: () => o("customers"), children: "customers" }), T.jsx("button", { className: r === "products" ? "active" : "", onClick: () => o("products"), children: "products" }), T.jsx("div", { onClick: () => o("products"), children: T.jsx(Pg, { to: "products", className: r === "products" ? "active" : "", children: "here products" }) })] }), T.jsxs("div", { className: "tab-content", children: [r === "contacts" && T.jsx("div", { className: "panel", children: T.jsx(DT, { list: t, framerText: Gh }) }), r === "customers" && T.jsx("div", { className: "panel", children: "customers" }), r === "products" && T.jsx("div", { className: "panel", children: T.jsx(ny, { framerText: Gh }) })] })] })] }) }; async function FT({ request: e }) { console.log("===> loader for root"); const n = new URL(e.url).searchParams.get("q"); return { contacts: await Rc(n), q: n } } async function _T() { const e = await wx(); return ra(`/contacts/${e.id}/edit`) } function OT() {
  const { contacts: e, q: t } = aa(), [n, r] = x.useState([]); x.useEffect(() => { r(e) }, [e]); const i = _w(), o = kc(), s = i.location && new URLSearchParams(i.location.search).has("q"); x.useEffect(() => { let d = document.getElementById("react_searchbar_q"); d && (d.value = t) }, [t]); async function a() { await Cx(); let d = await Rc(""); r(d) } const [l, u] = x.useState(!1), c = () => u(d => !d), f = RT(); return x.useEffect(() => { f(Ey()) }, [f]), T.jsxs(T.Fragment, {
    children: [T.jsx("div", { id: "react-app-icons-container", className: "fixed bg-zinc-800 border-r-2 border-2 border-zinc-100 p-3", children: T.jsx(eT, { className: "", action: c }) }), T.jsx(zE, {
      mode: "wait", initial: !1, children: l && T.jsxs(jn.div, {
        ...UE, id: "react-contact-app", className: "fixed bottom-0 left-0 right-0 top-0 backdrop-blur-sm flex", children: [T.jsx(jn.div, {
          ...BE, id: "sidebar", className: `container z-10 flex h-screen 
                
                w-[300px] min-w-[300px] 
                md:w-[30rem] md:min-w-[30rem]
                flex-col overflow-y-auto py-5 px-0`, children: T.jsxs("div", { className: "sidebar_innerContainer py-5", children: [T.jsxs("div", { className: "sidebar_row_1 mb-4 flex relative px-[theme('sidebarMargin.default')]", children: [T.jsx(qE, { className: "", action: c }), T.jsx("h1", { className: "text-2xl ", children: "React Router Contacts" })] }), T.jsxs("div", { className: "contactFormWrapper px-[theme('sidebarMargin.default')] flex flex-row space-x-4 text-3xl   justify-between", children: [T.jsxs($r, { id: "search-form", className: "my-5 h-[theme('btnHeight.default')] bg-white  grow  ", role: "search", children: [T.jsx(vi, { size: "xl", id: "react_searchbar_q", className: ` ${s ? "loading" : ""} text-contrast`, "aria-label": "Search contacts", placeholder: "Search", type: "search", name: "q", defaultValue: t, onChange: d => { const g = t === null; o(d.currentTarget.form, { replace: !g }) } }), T.jsx("div", { id: "search-spinner", "aria-hidden": !0, "data-searching": s, "data-hidden": !s, className: " roundanimate-spin block" }), T.jsx("div", { className: "sr-only", "aria-live": "polite" })] }), T.jsx($r, { method: "post", className: "my-5 ml-3", children: T.jsx(Oi, { type: "submit", variant: "default", size: "xl", className: "w-full text-contrast2 ", children: "New" }) })] }), T.jsx("nav", { children: T.jsxs("div", { className: "app-display-list", children: [T.jsx("li", { className: "app-tool-bar", children: T.jsxs(Cg, { to: "/", children: [T.jsx(tT, {}), T.jsx(nT, { action: a }), T.jsx(rT, { action: () => f(Ty()) })] }) }), T.jsx(VT, { initialActiveTab: "contacts", contactsState: n, customersState: !0 }), T.jsx("hr", {})] }) })] })
        }), T.jsx("div", { id: "detail", className: i.state === "loading" ? "loading" : "", children: T.jsx(zw, {}) })]
      })
    })]
  })
} function qh() { const e = wg(); return console.error(e), x.useEffect(() => (e ? document.getElementById(Go).classList.add("error-state") : document.getElementById(Go).classList.remove("error-state"), () => { document.getElementById(Go).classList.remove("error-state") }), [e]), T.jsxs("div", { id: "error-page", children: [T.jsx("h1", { children: "Oops!" }), T.jsx("p", { children: "Sorry, an unexpected error has occurred." }), T.jsx("p", { children: T.jsx("i", { children: e.statusText || e.message }) })] }) } async function ep({ params: e }) { const t = await xx(e.contactId); if (!t) throw new Response("", { status: 404, statusText: "Contact Not Found" }); return { contact: t } } async function IT({ request: e, params: t }) { let n = await e.formData(); return Tg(t.contactId, { favorite: n.get("favorite") === "true" }) } function zT() {
  const { contact: e } = aa(), [t, n] = x.useState(), { placeholderImages: r, imageLoadingError: i } = vT(s => s.contact); x.useEffect(() => { if (!e || !e.avatar) { console.log("====> contact or contact.avatar undefined "); return } return n(e.avatar.trim()), () => { n("") } }, [e.avatar]); const o = x.useCallback(() => { try { console.log("====>  getImgUrls() avatarURL", t); let s = t; if (!s || s.trim() === "") return console.log("===> render a default profile img", r["ppl-1"]), r["ppl-1"]; if (wy(s) && xy(s)) { let a = s; return a = Sy(a), r[a] } else return t } catch (s) { return console.error("Error getting placeholder imgs:", s), "" } }, [t]); return i ? T.jsxs("div", { children: ["Error loading images: ", i.message] }) : T.jsxs("div", {
    id: "contact", className: "my-10 flex flex-col md:flex-row border-[0.5px] border-solid border-border", children: [T.jsx("div", {
      className: `contact-img-wrapper   flex 
      w-full
      md:w-[300px] md:min-w-[300px]
      
      flex-shrink  flex-grow-0 justify-center bg-lightgray p-8 align-middle`, children: t && t.trim() !== "" ? T.jsx("img", { className: "h-full w-full border bg-lightgray  object-cover w", src: o() }, t) : T.jsx(Xv, { className: " text-slate-200 w-full h-full" })
    }), T.jsxs("div", { className: "contact-info-wrapper flex-shrink flex-grow  basis-auto p-8", children: [T.jsxs("h1", { children: [e.first || e.last ? T.jsxs(T.Fragment, { children: [e.first, " ", e.last] }) : T.jsx("i", { children: "No Name" }), " ", T.jsx(UT, { contact: e })] }), e.twitter && T.jsx("p", { children: T.jsx("a", { target: "_blank", href: `https://twitter.com/${e.twitter}`, children: e.twitter }) }), e.notes && T.jsx("p", { children: e.notes }), T.jsxs("div", { className: "contact-btn-wrapper my-4 flex", children: [T.jsx($r, { action: "edit", children: T.jsx(Oi, { className: " text-contrast2 ", type: "submit", size: "xl", children: "Edit" }) }), T.jsx($r, { method: "post", action: "destroy", onSubmit: s => { confirm("Please confirm you want to delete this record.") || s.preventDefault() }, children: T.jsx(Oi, { className: "ml-4  text-contrast2 ", type: "submit", size: "xl", children: "Delete" }) })] })] })]
  })
} function UT({ contact: e }) { const t = vx(); let n = e.favorite; return t.formData && (n = t.formData.get("favorite") === "true"), T.jsx(t.Form, { method: "post", children: T.jsx("button", { name: "favorite", value: n ? "false" : "true", "aria-label": n ? "Remove from favorites" : "Add to favorites", children: n ? "★" : "☆" }) }) } async function BT({ request: e, params: t }) { const n = await e.formData(), r = Object.fromEntries(n); return await Tg(t.contactId, r), ra(`/contacts/${t.contactId}`) } function bT() { const { contact: e } = aa(), t = Cc(); return T.jsxs($r, { method: "post", id: "contact-form", children: [T.jsxs("p", { className: "form-row", children: [T.jsx("span", { className: "form-label", children: "Name" }), T.jsx(vi, { size: "xl", placeholder: "First", "aria-label": "First name", type: "text", name: "first", defaultValue: e.first }), T.jsx(vi, { className: " ml-4", size: "xl", placeholder: "Last", "aria-label": "Last name", type: "text", name: "last", defaultValue: e.last })] }), T.jsx("p", { className: "form-row", children: T.jsxs("label", { className: "form-row-wrapper", children: [T.jsx("span", { className: "form-label", children: "Twitter" }), T.jsx(vi, { size: "xl", type: "text", name: "twitter", placeholder: "@jack", defaultValue: e.twitter })] }) }), T.jsx("p", { className: "form-row", children: T.jsxs("label", { className: "form-row-wrapper", children: [T.jsx("span", { className: "form-label", children: "Avatar URL" }), T.jsx(vi, { size: "xl", placeholder: "https://example.com/avatar.jpg", "aria-label": "Avatar URL", type: "text", name: "avatar", defaultValue: e.avatar })] }) }), T.jsx("p", { className: "form-row", children: T.jsxs("label", { className: "form-row-wrapper", children: [T.jsx("span", { className: "form-label", children: "Notes" }), T.jsx("textarea", { className: " w-full  text-contrast2", name: "notes", defaultValue: e.notes, rows: 6 })] }) }), T.jsxs("p", { className: "form-row", children: [T.jsx("span", { className: "form-label" }), T.jsx(Oi, { type: "submit", size: "xl", className: "  text-contrast2", children: "Save" }), T.jsx(Oi, { type: "button", size: "xl", className: "ml-4 text-contrast2", onClick: () => { t(-1) }, children: "Cancel" })] })] }) } async function HT({ params: e }) { return await Sx(e.contactId), ra("/") } function tp() { return T.jsx("p", { id: "zero-state", className: " bg-transparent" }) } x.createContext(null); x.createContext(null); const WT = Ly({ reducer: { contact: ky, customers: Ry } }), $T = ex([{ path: "/", element: T.jsx(OT, {}), errorElement: T.jsx(qh, {}), loader: FT, action: _T, children: [{ errorElement: T.jsx(qh, {}), children: [{ index: !0, element: T.jsx(tp, {}) }, { path: "contacts", element: T.jsx(tp, {}) }, { path: "contacts/:contactId", element: T.jsx(zT, {}), loader: ep, action: IT }, { path: "contacts/:contactId/edit", element: T.jsx(bT, {}), loader: ep, action: BT }, { path: "contacts/:contactId/destroy", action: HT, errorElement: T.jsx("div", { children: "Oops! There was an error." }) }, { path: "products", element: T.jsx(ny, {}), loader: NT }] }] }]), KT = () => T.jsx(Pt.StrictMode, { children: T.jsx(ET, { store: WT, children: T.jsx(lx, { router: $T }) }) }), GT = du.createRoot(document.getElementById(Go)); GT.render(T.jsx(KT, {}));
